<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Share and Create</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://detachment.club/"/>
  <updated>2016-12-28T08:00:56.554Z</updated>
  <id>http://detachment.club/</id>
  
  <author>
    <name>Detachment</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客构建笔记</title>
    <link href="http://detachment.club/2016/12/28/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://detachment.club/2016/12/28/博客构建笔记/</id>
    <published>2016-12-27T16:00:00.000Z</published>
    <updated>2016-12-28T08:00:56.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;记录总结学习过程的重要性不言自明。博客正好就是这一过程的体现平台，所以构建并完善这个平台就显得尤为重要了。由于周期性的懒癌发作，所以可惜的是构建此博客的前期并未记录下来，这两天因为开始写年终总结了，所以连续为博客增加了两项功能，至此我认为应该记录一下。</p>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一直都知道很多博客有订阅 rss 的功能，但是从来没有使用过，所以前期构建的时候并没有将这个功能作为博客的核心功能。直到邮件订阅了一些网站之后，只要有更新就会自动推送邮件，并且在邮件中就能看到更新的内容。这才感受到这个功能的便捷性，然后决定我也要给我的博客增加这个功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;经过一番探索，经过以下步骤可以实现 rss 及邮件订阅的功能：</p>
<ol>
<li>利用 npm 下载安装 hexo-generator-feed 插件，命令如下：<br><code>$ npm install --save hexo-generator-feed</code></li>
<li><p>在主题配置文件 <code>_config.yml</code> 中增加以下内容：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#Feed configuration</span></span><br><span class="line"><span class="symbol">plugin:</span></span><br><span class="line">- hexo-generator-feed</span><br><span class="line"><span class="symbol"></span><br><span class="line">feed:</span></span><br><span class="line"><span class="symbol">  type:</span> atom      <span class="comment">// Feed type. (atom/rss2)</span></span><br><span class="line"><span class="symbol">  path:</span> atom.xml  <span class="comment">// Feed path. (Default: atom.xml/rss2.xml)</span></span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">20</span>       <span class="comment">// Maximum number of posts in the feed.</span></span><br><span class="line"><span class="symbol">  hub:</span>            <span class="comment">// URL of the PubSubHubbub hubs (Leave it empty if you don't use it)</span></span><br><span class="line"><span class="symbol">  content:</span> true   <span class="comment">// (optional) set to 'true' to include the contents of the entire post in the feed.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在主题配置文件 <code>_config.yml</code> 中设置 rss 项：<br><code>rss: &quot;/atom.xml&quot;</code></p>
</li>
<li>至此，更新部署博客就能看到有 rss 订阅功能了，需要邮件订阅功能则需要从下面一步开始；</li>
<li>利用 feedbuner 来制作一个feed（如果没有账号可以注册一个或者用谷歌账号登录）：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner1.JPG" alt="第一张图"></li>
<li>在上图中填入你的博客订阅地址，如下所示：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner2.JPG" alt="第二张图"></li>
<li>之后直接点击 next 就成功制作了一个feed：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner3.JPG" alt="第三张图"></li>
<li>制作完之后在种子信息面板开启邮件订阅的功能：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner4.JPG" alt="第四张图"></li>
<li>至此，你已经得到了两种形式的代码了，根据自己的需要使用到自己的网站上，我使用的是超链接的形式。</li>
</ol>
<hr>
<h3 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这也是一个一直想要的功能，因为很有可能有些博客的重要性比其他的更高，但是由于默认按照时间来排序导致翻页之后才能看到这些文章。正好这两天在捣鼓博客，索性将这个功能也做出来。最开始的时候准备将博客的源码文件捋清楚后自己修改代码，但是打开hexo文件夹一看，打了个哆嗦就把文件夹关了：我是不是傻，为啥不先去搜索一番？<br>&nbsp;&nbsp;&nbsp;&nbsp;果然，一搜就发现有很多人多有这个需求: <a href="https://github.com/iissnan/hexo-theme-next/issues/415" target="_blank" rel="external">如何置顶post？</a>。整个帖子看下来的结论是：各种尝试的结果都或多或少有bug，所以此暂时暂时搁置，日后再来开发。不过里面倒是有个链接指出了通用配置方法，这也是目前我所采用的方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">原文写的比较详细</a>，我也就不再多费口舌了，总的来说就是更改排序规则，并将新的变量（top）增加到post的开头部分。经测试，效果不错。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;记录总结学习过程的重要性不言自明。博客正好就是这一过程的体现平台，所以构建并完善这个平台就显得尤为重要了。由于周期性的懒癌发作，所以可惜的是构建此博客的前期并未记录下来，这两天因为开始写年终总结了，所以连续为博客增加了两项功能，至此我认为应该记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://detachment.club/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://detachment.club/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="置顶" scheme="http://detachment.club/tags/%E7%BD%AE%E9%A1%B6/"/>
    
      <category term="订阅" scheme="http://detachment.club/tags/%E8%AE%A2%E9%98%85/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】 写在2016年的尾巴</title>
    <link href="http://detachment.club/2016/12/27/%E5%86%99%E5%9C%A82016%E5%B9%B4%E7%9A%84%E5%B0%BE%E5%B7%B4/"/>
    <id>http://detachment.club/2016/12/27/写在2016年的尾巴/</id>
    <published>2016-12-26T16:00:00.000Z</published>
    <updated>2016-12-29T12:37:04.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一年的时间过得太快，但足以发生很多很多的事情，这也造成了提笔难言的窘境。如果要叙述一个复杂的故事，最简单的办法就是利用时间作为线索，采用顺序的叙述结构。这种结构同样非常适合年终总结。</p>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在前言中，我就简单的以时间为线来简单的流水一遍我这一年：</p>
<ul>
<li>1-3月：设计制作最后三套轮胎自动搬运设备，3月底辞职；</li>
<li>4-5月：在w3school上学习html，css，JavaScript的相关知识；重新使用github；</li>
<li>6-7月：利用视频教程学习JavaScript；搭建博客并将整个学习过程总结到博客上；</li>
<li>8-9月：学习jQuery，BootStrap并利用所学模仿制作了简历；开始投简历、面试、得到offer并放弃；学习《JavaScript编程精解》；初步接触vue.js；</li>
<li>10月：学习vue.js及相关工具（router、vuex、loader）；学习webpack的使用；学习git；投简历被拒；</li>
<li>11月：学习《JavaScript高级程序设计》；尝试利用vue.js制作完整项目遇阻；</li>
<li>12月：重新学习vue.js并准备做完整的项目，遇阻；学习ES6语法；利用xmind总结vue.js；年终总结。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面所提到的虽不全面，但也大体覆盖了这近一年所做的主要努力。下面的正文还将从各个方面来进行总结，从另一个角度来更加全面的回顾这一年所发生的的事情。</p>
<hr>
<script src="https://use.fontawesome.com/e4cb940bf3.js"></script>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;下面将从这两个方面来总结：学习工作与生活娱乐。</p>
<h3 id="学习工作"><a href="#学习工作" class="headerlink" title="学习工作"></a>学习工作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前端学习的内容无外乎语言本身（HTML，CSS 及 JavaScript）的学习及辅助工具应用方面（框架、模块化工具等）的学习，那么就从这两方面来说说目前的情况吧。</p>
<ul>
<li><strong>语言本身</strong><ol>
<li><strong>HTML</strong>：主要从w3s上学习，项目中碰到问题靠搜索解决。对于 HTML5 中新加入的新特征了解但没达到熟悉的程度；   </li>
<li><strong>CSS</strong>：主要从w3s上学习，了解在 CSS3 中新加入的特征但实践不够；</li>
<li><strong>JavaScript</strong>：<ul>
<li><strong>前期</strong>：w3s上学习了一阵子，摸不着头脑。转而到网易云课堂学习了《精通JavaScript开发》，当时自觉已经大概了解了这门语言，现在看来还是 too young，too simple。之后在准备面试的时候看到各种 JavaScript 方面的考题都不会做，然后又开始在网上找资源来学习知识，这时候找到《JavaScript秘密花园》以及汤姆大叔的JS总结博客，如获至宝。又一次 be naive。总结是个升华的过程，而学习基础知识则是升温过程。其实当时也懂得这个道理，只是在希望能尽快找到工作的心态影响下变得浮躁。</li>
<li><strong>中期</strong>：开始看书，第一本看的是 《JavaScript 编程精解》。书如其名，处处体现一个精字，导致看完一遍之后和朋友切磋的时候被暴虐。因为本书中对很多基础性的概念并没有做出详尽的介绍，所以我看了一遍之后对这些都是一知半解。但不可否认的是，这本书里面的编程技巧让我大开眼界。总而言之：新手不推荐这本书。看的第二本书是《JavaScript高级程序设计》，它为我打开了新世界的大门。这本书深入浅出的为初学者介绍了所需要了解的绝大部分关于 JavaScript 的知识点，看完后我受益匪浅，值得反复阅读、总结。在学 vue.js 做项目的时候发现有大量的 ES6 新增的特性在发挥作用，所以后期也学习了 ES6 规范。学习 ES6 的途径是阮一峰老师的博客。总体而言，对于我这种水平的新手来说，教程难度适中，看过一遍之后能够理解大概80%左右的知识点。所以，对于希望能初步掌握 ES6 规范的学习者来说，我还是很推荐这份教程的。</li>
<li><strong>后期</strong>：JS 语言的学习将在很长一段时间处于中期阶段，因为很多知识点都需要通过在实践中慢慢的掌握，而这也是目前我所严重欠缺的方面。虽然此阶段的到来还很遥远，不过总体方针还是有的：关注了解与前端相关的知识如服务器端（node.js）以及网络协议等；关心语言的发展趋势，如果可能的话，甚至去影响趋势。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>框架工具学习</strong></p>
<ol>
<li><strong>jQuery</strong>：主要通过 w3s 来学习，掌握基本用法，未深究；</li>
<li><strong>BootStrap</strong>：通过视频及官方文档来学习。有独立项目，其中个人简历即在此阶段完成的；</li>
<li><p><strong>Vue.js</strong>：仔细看过几遍官方文档并有总结，对基本用法了熟于心。同时也了解关于 Vue.js 的一些辅助插件，如 vuex、vue-router 以及 vue-loader。在很快的一段时间内将会利用这些来完成一个复杂程度较高的完整前端项目。附简单的总结图如下（利用 xMind 制作，如有需要源文件的可以给我发邮件）：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/vuex.png" alt="vue.js"></p>
<p><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/Vue.png" alt="vue.js"></p>
</li>
<li><strong>webpack</strong>：完整的看了一遍文档，并翻译发布了一篇博客，有过少许实践经验。在这个过程中接触到 npm，yarn，gitbook等等；</li>
<li><strong>git</strong>：熟练使用 git 的基本操作，写过一篇相关博客。</li>
<li><strong>其他</strong>：了解（基本能看懂代码） bower、gulp、sass、karma、eslint 等，但都没有实践经验。这也是之后需要加强的方面。</li>
</ol>
</li>
</ul>
<ul>
<li><strong>博客写作</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;自从6月份开通到现在为止，一共发布了10篇博客，除了两篇为翻译文档，其余全为原创。有一篇访问量超过2500pv，对自己来说也是一个鼓励。以此同时，有多位朋友看过博客后通过邮件和我联系并给于肯定，在此对他们表示感谢，也希望大家在前端学习的路上大家都能越走越远。下面附上一些简单的博客流量图：<br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji1.JPG" alt="tongji"><br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji2.JPG" alt="tongji"><br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji3.JPG" alt="tongji"></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;至此，学习工作方面的内容基本上也已经总结的差不多了，接下来继续总结生活娱乐方面。</p>
<h3 id="生活娱乐"><a href="#生活娱乐" class="headerlink" title="生活娱乐"></a>生活娱乐</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;All work and no play makes Jack a dull boy. 从以下两个方面来总结吧：精神建设以及生活质量。</p>
<ul>
<li><p><strong>精神建设</strong></p>
<ol>
<li><p><strong>电影</strong>：看电影是一个终生爱好，可能和小时候的经历有关。按照时间顺序简单的总结下今年看过的影片（包括电影和剧集，数据来自豆瓣记录以及下载记录），根据个人喜好推荐加粗部分的电影：</p>
<ul>
<li>一月份： <strong>《老炮儿》</strong>《黑金》《我的少女时代》《机械姬》<strong>《走到尽头》</strong>《为了N》（剧集）;</li>
<li>二月份：<strong>《守望者》</strong>《美国狙击手》《史蒂夫·乔布斯》<strong>《夜行者》</strong>《暗杀》<strong>《视觉》</strong>；</li>
<li>三月份：《八恶人》《饥饿游戏3：嘲笑鸟》<strong>《聚焦》</strong> <strong>《荒野猎人》</strong>《蝙蝠侠大战超人：正义黎明》<strong>《控方证人》</strong>《功夫熊猫3》；</li>
<li>四月份：<strong>《纸牌屋 第四季》</strong>；</li>
<li>五月份：<strong>《危楼愚夫》《成长系列》《盗梦空间》</strong>，其中<a href="https://movie.douban.com/subject/10748226/" target="_blank" rel="external">《成长系列》</a>极力推荐；</li>
<li>六月份：无记录。（可能在 B 站上有看，但是记录不可查）；</li>
<li>七月份：《危机13小时》《奇幻森林》《人间世》《知无涯者》《行尸走肉》；</li>
<li>八月份：<strong>《一个叫欧维的男人决定去死》</strong>《红眼航班》<strong>《云图》</strong>；</li>
<li>九月份：《惊天盗魔团》《寒战2》<strong>《黑客军团2》《心迷宫》</strong>《你眼中的世界》<strong>《杀死一只知更鸟》《阿凡达》</strong>；</li>
<li>十月份：<strong>《荒野生存》</strong>《黑镜3》《西部世界》《冰血暴2》《毕业生》<strong>《追梦赤子心》</strong></li>
<li>十一月份：<strong>《我们这一天》</strong>《斯诺登》<strong>《头脑特工队》</strong>《逃避虽可耻但有用》<strong>《七武士》《双峰 第一季》</strong>《双峰 第二季》</li>
<li>十二月份：<strong>《行星地球2》</strong>《萨利机长》<strong>《梦之安魂曲》《驴得水》《疯狂的麦克斯4》</strong>《豪勇七蛟龙》<strong>《夜班经理》</strong></li>
</ul>
<blockquote>
<p>由于有部分电影在 B 站上看的，导致没有任何记录，所以可能有 10%-20% 左右的电影没有归纳出来。</p>
</blockquote>
</li>
<li><p><strong>书籍</strong>：除了专业书籍之外，还看了一些其他方面的书，以下大概按照时间来排序：</p>
<ul>
<li><p><strong>《独生告白》</strong>：这是一本关于家庭教育的书，我认为每个身为人父（母）的人都应该看一看这本书。文章中的心理描写非常精彩，比如下面这一段：</p>
<blockquote>
<p>多年来对爱的渴望让她变得敏感，她就像一条饥饿的狗，不停的翕动鼻孔，捕捉着哪怕是最微弱的食物的香气。她不会弄错的。她一看到就认出了它。那是爱，是一厢情愿的深切渴慕，只有付出，得不到回报；是小心翼翼而安静的爱恋，却无所畏惧，无论如何，都会执着的进行下去。  </p>
</blockquote>
</li>
<li><p><strong>《黑客与画家》</strong>：讨论了很多关于计算机以及互联网行业的问题，比如编程语言发展趋势。对我影响不大，看完之后很多内容多忘记了。摘取一段作者对于怎么致富的方法的看法：</p>
<blockquote>
<p>要致富，你需要有两样东西：可测量性和可放大性。你的职位产生的业绩，应该是可测量的，否则你做的再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做的决定能够产生巨大的效应。</p>
</blockquote>
</li>
<li><p><strong>《月亮与六便士》</strong>：什么是信仰？什么又是真正的幸福？</p>
<blockquote>
<p>难道做自己最想做的事，生活在让你感到舒服的环境里，让你的内心得到安宁是糟践自己吗？难道成为年入上万英镑的外科医生、娶得如花美眷就算是成功吗？我想这取决于你如何看待生活的意义，取决于你认为你应该对社会做出什么贡献，应该对自己有什么要求。</p>
</blockquote>
</li>
<li><p><strong>《自控力》</strong>：这本书通过一系列的实验给我们展示了关于自控力种种方面的研究成果。对于有严重拖延症的人来说，值得一看。摘抄部分结论：</p>
<blockquote>
<p>人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学习数学，他就会越来越擅长数学。如果你让他忧虑，他就会越来越忧虑。如果你让他专注，他就会越来越专注。</p>
</blockquote>
</li>
<li><p><strong>《三体全集》</strong>：佩服作者的想象力和知识面，不过不符合个人口味，看了40%左右，弃坑。摘录部分笔记：</p>
<blockquote>
<p>也许，人类和邪恶的关系，就是大洋与漂浮于其上的冰山的关系，它们其实是同一物质组成的巨大水体。冰山之所以被醒目的认出来，只是由于其形态不同而已，而它实质上只不过是这整个巨大水体中较小的一部分……人类真正的道德自觉是不可能的，就像他们不可能自己把着自己的头发离开大陆。</p>
</blockquote>
</li>
<li><p><strong>《一个人的朝圣》</strong>：我只是想安安静静的去拜访个老朋友而已，你们这帮记者除了弄个大新闻还会啥？</p>
<blockquote>
<p>他发现正是这些普通人的渺小与孤独使他诧异，牵动他内心的温柔。在这个世界上有多少人每天做的事就是不断将一只脚放到另一只脚前面，日子久了，生活便显得平淡无奇。哈罗德无法再否认其实一路上见过的每个陌生人虽然是独特的，却又是一样的，这就是人生的两难。</p>
</blockquote>
</li>
<li><p><strong>《阿城精选集》</strong>：阿城先生的《棋王》《树王》以及《孩子王》都写的非常精彩，其中又以《棋王》最为精彩：</p>
<blockquote>
<p>王一生孤身一人坐在大屋子中央，瞪眼看着我们，双手支在膝盖上，铁铸一个细树桩，似无所见，似无所闻。高高的一盏电灯，暗暗地照在他脸上，眼睛深陷进去，黑黑的似俯视大千世界，茫茫宇宙。那生命像聚在一头乱发中，久久不散，又慢慢弥散开来，灼的人脸热。</p>
</blockquote>
</li>
<li><p><strong>《人类简史》</strong>：跳出人类的设定来看人类的发展。不同心态的人看完会有不同的结论，在这个思考的过程会刷新自己的认知。于我而言，这本书让我看问题多了一个角度：上帝视角。摘取《奢侈生活的骗局》中的一段：</p>
<blockquote>
<p>有多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背负着巨额贷款，要支付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且生活里面不能没有高级红酒和国外假期。他们该怎么做？他们会放下一切，回去野外挖树根？当然不可能，而是加倍努力，继续把自己累的半死。</p>
</blockquote>
</li>
<li><p><strong>《杀死一只知更鸟》</strong>：先看的书，再看的电影，足见我很喜欢这部作品。从种族歧视的角度探讨何为正义的作品不少，但这本书有着其独特的味道，比如书中的家庭教育。如果我有一个女儿，那么我希望她能够像斯考特一样纯真、勇敢而又具有独立而思辨的灵魂。</p>
<blockquote>
<p>勇敢是：当你还未开始就已知道自己会输，可你依然要去做，而且无论如何你都要把它坚持到底。你很少能赢，但有时也会。</p>
</blockquote>
</li>
<li><p><strong>《沉默的大多数》</strong>：这是一本王小波的杂文集，讨论的范围非常广，阅读的过程中能感受到一种思辨的快乐。这本书对我最大的影响是它让我相信一个有智慧的实诚人是可爱的。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恕我直言，能够带来思想快乐的东西，只能是人类智慧至高的产物。比这再低一级的东西，只会给人带来痛苦；而这种低档货，就是出于功利的种种想法。  –《思维的乐趣  第二章》<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我现在当然有自己的善恶标准，而且我现在并不比别人表现的坏。我认为低智、偏执、思想贫乏是最大的邪恶。按照这个标准，别人说我最善良，就是我最邪恶时；别人说我最邪恶时，就是我最善良时。当然，我不想把这个标准推荐给别人，但我认为，聪明、达观、多知的人，比之别样的人更堪信任。  –《思维的乐趣 第四章》<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果说贫穷是种生活方式，捡垃圾和挑大粪只是这种方式的契机。生活方式像是一个曲折漫长的故事，或者使人迷失的迷宫。很不幸的是，任何一种负面的生活都能产生很多乱七八糟的细节，使得他变得有趣；人就在这种趣味中沉沦下去，从根本上忘记了这种生活需要改进。用文化人类学的观点来看，这些细节加在一起，就叫做“文化”。  –《有关贫穷》</p>
</blockquote>
</li>
</ul>
<p>上面这些书都是看完了的，现在正在看小波的《黄金时代》、张纯如的《南京大屠杀》，已经购买计划要看的有《情人》《菊与刀》《江村经济》《唐吉坷德》等等。</p>
</li>
</ol>
</li>
<li><p><strong>生活质量</strong></p>
<ul>
<li><strong>做饭水平</strong>：经过一年的锻炼，做饭经验丰富；</li>
<li><strong>健身进展</strong>：对比去年，背阔肌和三头肌有明显进步；最近也加强了对大腿、肩部的锻炼，目前效果不明显；俄式挺身还是没有学会，核心力量太弱；训练的不够系统，整体进步趋于平缓；</li>
<li><strong>摄影水平</strong>：原地踏步；</li>
<li><strong>游戏水平</strong>：效率上涨100点，但是浪费太多时间和精力，已决定afk。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;2016年还有两天就过完了。这一年，我彻底的改变了自己的职业发展方向，一切从头开始。这一年，虽然过得还不够充实，但每一天都是按照自己的意愿来生活。这一年，胜过了很多年。<br>&nbsp;&nbsp;&nbsp;&nbsp;2017年希望自己和周围的人身体都健健康康。除此之外，也希望自己能够找到一份适合自己的工作，实现自己的价值。<br>&nbsp;&nbsp;&nbsp;&nbsp;最后套用一句小波的话来结束整篇文章：虽然人生在世会有种种不如意，但你仍可以在幸福与不幸中做出选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;新年快乐~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一年的时间过得太快，但足以发生很多很多的事情，这也造成了提笔难言的窘境。如果要叙述一个复杂的故事，最简单的办法就是利用时间作为线索，采用顺序的叙述结构。这种结构同样非常适合年终总结。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://detachment.club/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue.js" scheme="http://detachment.club/tags/Vue-js/"/>
    
      <category term="ES6" scheme="http://detachment.club/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://detachment.club/tags/JavaScript/"/>
    
      <category term="2016" scheme="http://detachment.club/tags/2016/"/>
    
  </entry>
  
  <entry>
    <title>怎样利用 git 撤销操作</title>
    <link href="http://detachment.club/2016/10/29/%E6%80%8E%E6%A0%B7%E5%88%A9%E7%94%A8%20git%20%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://detachment.club/2016/10/29/怎样利用 git 撤销操作/</id>
    <published>2016-10-28T16:00:00.000Z</published>
    <updated>2016-10-29T10:48:34.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于版本管理系统而言，最重要的一个特性之一就是能够撤销错误的操作。在 git 中，撤销有很多种可能的意思。<br>&nbsp;&nbsp;&nbsp;&nbsp;每当你做出一个 提交 的时候，git 都会立即在你的 repository 保存一个快照，之后你就可以通过 git 来恢复到这个项目的前一个版本了。<br>&nbsp;&nbsp;&nbsp;&nbsp;这下面这篇文章中，我将会就几种常见的情景来讨论怎样通过 git 来完美的撤销这些操作。</p>
<a id="more"></a>
<h2 id="不同情况"><a href="#不同情况" class="headerlink" title="不同情况"></a>不同情况</h2><h3 id="撤销已发布"><a href="#撤销已发布" class="headerlink" title="撤销已发布"></a>撤销已发布</h3><p><strong>情景</strong>：你刚按下 <code>git push</code> ，将修改推送到了 github ，然后就发现在你的提交中存在一些问题。这时候那就会想撤销操作。</p>
<p><strong>解决</strong>： <code>git revert &lt;SHA&gt;</code></p>
<p><strong>原理</strong>： <code>git revert &lt;SHA&gt;</code> 这个操作会生成一个新的 commit，这个提交和 提供的 SHA 是相反的：如果之前的提交是 “matter”，那么这个提交就是 “anti-matter”，也就是说之前操作中新增的内容将会被删除，之前操作中被删除的内容也将会被增加。</p>
<p>这是 git 中最基础也最安全的撤销操作情景，因为它不会 <em>改动</em> 变更历史——你可以放心的使用 <code>git push</code> “相反的”提交来撤销你错误的操作。</p>
<hr>
<h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><p><strong>情景</strong>：你把提交信息的最后一个字打完：<code>git commit -m &quot;Fxies bug #42</code>，提交之后推送之前，你发现你的提交信息出错了，应该是：<code>Fixes bug #42</code>。这时候你也会想到撤销操作。</p>
<p><strong>解决</strong>：<code>git commit --amend or git commit --amend -m &quot;Fixes bug #42&quot;</code></p>
<p><strong>原理</strong>：<code>git commit --amend</code> 操作会用一个新的提交来更新、替换上一个提交。如果新提交的内容中有已处于可提交状态的修改，那么也会一并提交；如果没有，那么只需要重写上一次的提交信息即可。</p>
<hr>
<h3 id="撤销本地操作"><a href="#撤销本地操作" class="headerlink" title="撤销本地操作"></a>撤销本地操作</h3><p><strong>情景</strong>：一只喵从键盘上走过，不小心保存了修改，然后很巧的是 IDE 此时崩溃退出了。这时候你还没有提交，你希望能够将这个文件中所有的修改都撤销——直到恢复成上一次提交的状态。</p>
<p><strong>解决</strong>：<code>git checkout -- &lt;bad filename&gt;</code></p>
<p><strong>原理</strong>：<code>git checkout</code> 指令会将工作文件夹中的这个文件恢复成在 Git 中上一次保存的状态。你可以提供一个确切的分支名，或者是需要恢复到的 SHA。如果都省略，Git 就默认是恢复到 HEAD ——也就是目前分支的上一次提交状态。</p>
<p><strong>注意</strong>：利用这种方法所做的任何撤销都是真的撤销了。因为没有提交操作，所以 Git 之后也没办法来恢复了。用这种方法的时候一定要确定你所需要撤销的到底是什么！（你可以利用 <code>git diff</code> 来确认提交信息）</p>
<hr>
<h3 id="重置本地操作"><a href="#重置本地操作" class="headerlink" title="重置本地操作"></a>重置本地操作</h3><p><strong>情景</strong>：你在本地提交过几次（但还没有推送），然后你发现这些都是垃圾，然后你想撤销最近三次的提交——就好像它们从来没发生过一样。</p>
<p><strong>解决</strong>：<code>git reset &lt;last good SHA&gt; or git reset --hard &lt;last good SHA&gt;</code></p>
<p><strong>原理</strong>：<code>git reset</code> 操作会让你的项目历史记录回滚到指定的 SHA，就像这些提交从来没有发生过一样。默认状态下，这个操作会将工作目录保存下来，这时候提交虽然没有了，但是这些提交的内容还是存在硬盘上的。这是最安全的做法，但是很多时候，你需要同时撤销提交并同时删除这些文件——这时候就需要加上 <code>--hard</code> 了。</p>
<hr>
<h3 id="重置本地操作后恢复"><a href="#重置本地操作后恢复" class="headerlink" title="重置本地操作后恢复"></a>重置本地操作后恢复</h3><p><strong>情景</strong>：你已经提交了一些修改，然后发现不对，就利用上面的方法撤销了提交。这时候你又发现：我要撤销刚刚的撤销！</p>
<p><strong>解决</strong>：<code>git reflog and git reset or git checkout</code></p>
<p><strong>原理</strong>：<code>git reflog</code> 是一种非常好的用于恢复项目历史记录的办法。通过这个办法，几乎可以恢复任何已经提交过的修改。</p>
<p>你可能对用于显示不同提交的 <code>git log</code> 指令比较熟悉，而 <code>git reflog</code> 也是类似的，区别在于，它显示的是 <code>HEAD</code> 的修改情况列表。</p>
<p>注意点：</p>
<ul>
<li>只有 .HEAD 文件被修改时 HEAD 才会修改，这些情况包括：切换分支、通过 <code>git commit</code> 提交、通过 <code>git-reset</code> 恢复。需要注意的是通过 <code>git checkout --&lt;bad filename&gt;</code> 操作并不会修改 HEAD（上面的方法中提到过这个操作不会被提交），所以 reflog 方法这时候不适用。</li>
<li><code>git reflog</code> 不会被永久保存。Git 内部每隔一段时间就好清理一些无法识别的对象。所以不要指望几个月前的提交记录能够永远在 reflog 中找到。</li>
<li>你的 <code>reflog</code> 仅仅只能你自己使用。你无法通过这个指令来恢复其他开发者尚未推送的提交。</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png" alt=""></p>
<p>那么，回到正题，怎样通过 <code>git reflog</code> 来达到撤销已撤销的目的呢？这还得根据不同的情况讨论：</p>
<ul>
<li>如果你想将项目历史恢复成特定时候的状态，使用 <code>get reset -hard &lt;SHA&gt;</code></li>
<li>如果你想在你的工作目录下重新创造一些和之前一样的文件，同时不更改项目记录，那么就用 <code>git checkout &lt;SHA&gt; --&lt;filename&gt;</code></li>
<li>如果你想重新提交一个确切的操作到你的项目，那就是用 <code>git cherry-pick &lt;SHA&gt;</code></li>
</ul>
<hr>
<h3 id="修改合并分支"><a href="#修改合并分支" class="headerlink" title="修改合并分支"></a>修改合并分支</h3><p><strong>情景</strong>：你提交了一些修改，然后发现提交到了 master 分支，而你本来是想提交到一个叫做 feature 的分支上。</p>
<p><strong>解决</strong>：<code>git branch feature, git reset --hard origin/master, and git checkout feature</code></p>
<p><strong>原理</strong>：你可能比较习惯使用 <code>git checkout -b &lt;name&gt;</code> 来建立并切换到新建立的分支上——然而，有时候你并不希望立刻切换到新建立的分支。通过 <code>git branck feature</code> 创建了一个叫做 feature 的分支，这也是你将要合并提交的分支，而且这样操作，目前所在的分支还在 master 上（并没有切换到 feature）。<br>然后，通过 <code>git reset --hard</code> 将 master 分支回滚到之前 origi/master 未提交的状态。不过不要担心，在 feature 分支上，这些提交还是有的。<br>最后，通过 <code>git checkout</code> 指令将分支切换至 feature，然后你就可以开心的进行提交了。</p>
<hr>
<h3 id="同步更新分支"><a href="#同步更新分支" class="headerlink" title="同步更新分支"></a>同步更新分支</h3><p><strong>情景</strong>：你在本地分支 master 的基础上新建了一个叫做 feature 的分支，但是这时候的本地分支 master 比远程主机上的 origin/master 分支落后几个版本。然后你将本地 master 分支同步至 origin/master，然后你希望这时候提交到 feature 分支上的修改能够在现在这个状态的基础上，而不是之前落后几个版本的状态。</p>
<p><strong>解决</strong>：<code>git checkout feature and git rebase master</code></p>
<p><strong>原理</strong>：你本来可以这样做：首先利用 <code>git reset</code>（后面故意不加 –hard，这样的话 master 虽然回滚到上个版本但是硬盘上这些可提交的修改并没有删除），然后通过 <code>git checkout &lt;branch name&gt;</code> 切换至 feature 分支，最后在这个分支上重新提交（以达到和之前 master 分支一样的状态）。通过这种办法可以达到目的，但是你会失去提交历史。下面有一个更好的方法。</p>
<p><code>get rebase master</code> 操作会执行很多事情：</p>
<ul>
<li>首先在目前所在分支和本地 master 分支之间确定谁是谁的父级；</li>
<li>然后将目前所在分支的状态重置成父级的状态，并把之后的提交都暂时保存在一个区域；</li>
<li>最后更新升级到和 master 分支最新状态一样，然后重新操作暂时保存区域的提交。</li>
</ul>
<hr>
<h3 id="大量的撤销-恢复操作"><a href="#大量的撤销-恢复操作" class="headerlink" title="大量的撤销/恢复操作"></a>大量的撤销/恢复操作</h3><p><strong>情景</strong>：你从某个方向来开始了一项研究，研究到一半，你发现另一种方法会更好。这时候你已经提交了几次了，而你其实并不完全需要它们。所以你希望其中的一些提交完全消失。</p>
<p><strong>解决</strong>：<code>git rebase -i &lt;earlier SHA&gt;</code></p>
<p><strong>原理</strong>：-i 指令将 rebase 指令转入一种可交互模式。rebase 指令的作用前几步和上面都一样，唯一不一样的是在合并提交的时候，它会暂停然后让你选择需要合并的提交。</p>
<p><code>rebase -i</code> 会打开默认文本编辑器，文本中会列出可合并的提交，如下：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953863/f6b1ab88-d891-11e4-97c1-e0630ac74e74.png" alt=""></p>
<p>前面两列是包含着关键信息：第一个是用来提交操作的指令，第二个是提交操作的 SHA 的值。利用 <code>rebase -i</code> 合并操作的默认指令是 <code>pick</code>。</p>
<p>对于不想要的提交，你只需要在文本编辑器中删除对应的内容。如上面这张图，如果你不想要错误的提交，那就删除1、3、4这三行。</p>
<p>如果你想保持提交的内容但是想修改提交的提交信息，那你可以使用 <code>reword</code> 命令。只需要在第一列中替代 <code>pick</code>。虽然立即就改写提交信息听起来很爽，但是实际上并没有用，因为 <code>rebase -i</code> 会将 SHA 后面的信息都无视掉。这个文本只是用来提醒我们这个提交的内容是什么，在执行完 <code>rebase -i</code> 命令之后，就可以改写任意的提交信息了。</p>
<p>如果你想将两个提交合并，你可以使用 <code>squash</code> 或者 <code>fixup</code> 指令，如下：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953865/f6b605ca-d891-11e4-98cf-d567ca9f4edc.png" alt=""></p>
<p>这两个指令都会使得对应的提交和它之前的提交结合成一个提交。在上面的例子中，第一个和第二个会结合成一个提交，然后第三个和第四个也会结合成一个提交。</p>
<p>当使用 <code>squash</code> 时， Git 会让我们给新合并的提交一个新的提交信息；当使用 <code>fixup</code> 的时候，Git 会自动将列表中将合并的提交的最开始的提交信息作为新的提交信息。拿上图为例，前两个合并时需要输入一个新的合并提交的信息，而后两个合并时，会自动将第三个提交信息作为合并后的提交信息。</p>
<p>当你保存然后关闭文本编辑器的时候， Git就会依次执行编辑器中的内容。如果你希望更改合并的顺序，只需要在文本编辑器中改动。拿上图为例，如果你想合并 <code>af67f82</code> 和 <code>0835fe2</code> ，你只需要这样更换顺序：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953864/f6b4a9d2-d891-11e4-9ac9-10039c031d06.png" alt=""></p>
<hr>
<h3 id="更改早先的提交"><a href="#更改早先的提交" class="headerlink" title="更改早先的提交"></a>更改早先的提交</h3><p><strong>情景</strong>：你突然想起来，如果在之前的一次提交中加入某一个文件效果会更好。这时候你还没有推送这个提交，而这个提交并不是最近的一次，所以不能用 <code>commit --amend</code></p>
<p><strong>解决</strong>：<code>git commit --squash &lt;SHA of the earlier commit&gt; and git rebase --autosquash -i &lt;even earlier SHA&gt;</code></p>
<p><strong>原理</strong>：利用 <code>git commit --squash</code> 可以创建一个新的提交并有类似这样的提交信息 <code>squash! Earlier commit</code>(你可以手动输入像这样的提交信息，但是使用 <code>commit --squash</code> 可以让你少打一些字 。)</p>
<p>你也可以使用 <code>git commit --fixup</code> 指令来操作，利用这个指令不需要手动输入提交信息。这上面这个情境中，利用这个指令更好一些，因为不需要更改提交信息。</p>
<p>利用 <code>rebase --autosquash -i</code> 指令，然后会打开默认的文本编辑器，而且里面已经包含了提交信息，如下图：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953862/f6a7a1d8-d891-11e4-8784-c32262ff54da.png" alt=""></p>
<p>当你使用 <code>squash</code> 或者 <code>fixup</code> 指令的时候，你可能不知道你需要合并的提交的 SHA —— 你只记得是一次还是五次之前。这时候操作符 <code>^</code> 和 <code>~</code> 就很方便了。<code>HEAD^</code> 表示 HEAD 之前的一次， <code>HEAD~4</code> 表示的是 HEAD 的前四个提交，也就是倒数第五次提交（因为 HEAD 本身是倒数第一次）。</p>
<hr>
<h3 id="停止对已监测文件的监测"><a href="#停止对已监测文件的监测" class="headerlink" title="停止对已监测文件的监测"></a>停止对已监测文件的监测</h3><p><strong>情景</strong>：你最近将 <code>application.log</code> 加入到了仓库中，然后现在每次运行这个程序， Git 就会提示在这个文件中有未处于提交状态的修改。虽然你将 <code>*.log</code> 写入了 <code>.gitignore</code> 文件，但是情况并没有变化。要怎么才能让 git 放弃监测这个文件的变化呢？</p>
<p><strong>解决</strong>：<code>git rm --cached application.log</code></p>
<p><strong>原理</strong>：<code>.gitignore</code> 会使得 Git不去监测文件的变化，对于之前没有检测过的文件，它甚至会无视文件的存在。只要文件被提交了， Git 就会持续监测它的变化。类似的，如果利用 <code>git add -f</code> 或者覆盖 <code>.gitignore</code> 文件，那么 Git 也会监测这些文件的变化。</p>
<p>如果你想使得那些本不应该被监测的文件脱离监测，那么你可以使用 <code>git rm --cached</code> 指令。利用这个指令会停止 Git 对它的监测，同时这个文件在硬盘上不受影响。由于这个文件现在不被监测了，所以利用 <code>git status</code> 不能看到这个文件了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这是一篇译文，原文地址为： <a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">How to undo (almost) anything with Git</a>。由于自己碰到了这方面的问题，然后搜索过程中发现了这片文章，写的很全面，所以就翻译了一下。翻译的过程中可能会有一些理解上的偏差，欢迎盆友们指正。</p>
<blockquote>
<p><strong>commit：</strong>  在文中被翻译为 提交<br>  <strong>push：</strong> 在文中被译为 推送</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于版本管理系统而言，最重要的一个特性之一就是能够撤销错误的操作。在 git 中，撤销有很多种可能的意思。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;每当你做出一个 提交 的时候，git 都会立即在你的 repository 保存一个快照，之后你就可以通过 git 来恢复到这个项目的前一个版本了。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这下面这篇文章中，我将会就几种常见的情景来讨论怎样通过 git 来完美的撤销这些操作。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="工具" scheme="http://detachment.club/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://detachment.club/tags/git/"/>
    
      <category term="github" scheme="http://detachment.club/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>webpack学习指南</title>
    <link href="http://detachment.club/2016/10/17/webpack%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>http://detachment.club/2016/10/17/webpack学习指南/</id>
    <published>2016-10-16T16:00:00.000Z</published>
    <updated>2016-10-25T14:30:33.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;前端工程化已成为趋势，善于使用各种工具无疑能极大的提高工作效率，所以这段时间将陆续会有几篇关于这些工具的介绍文章，文章的内容大多是关于这些工具的文档的翻译。<br>&nbsp;&nbsp;&nbsp;&nbsp;本文所有资料来源都是 webpack 官网，有意看原文的戳链接： <a href="http://webpack.github.io/docs/.html" target="_blank" rel="external">webpack document</a></p>
<a id="more"></a>
<h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>现在的网页应用有以下特点：</p>
<ul>
<li>有越来越多的JavaScript代码；</li>
<li>现代浏览器能提供越来越多的接口；</li>
<li>虽然有越来越多的代码，但很少会一次加载完。  </li>
</ul>
<p>这些代码需要得到有序管理，模块系统随之产生。</p>
<p>在JavaScript中，有许多不同的方式用来引入数据以及定义依赖关系，常见的有以下几种：</p>
<ul>
<li>通过<code>&lt;script&gt;</code>标签引入（没有模块系统）</li>
<li>CommonJS</li>
<li>AMD及其相关</li>
<li>ES6模块</li>
<li>其他……</li>
</ul>
<p><strong> <code>&lt;script&gt;</code> 标签</strong></p>
<p>如果不利用模块系统的话，通过<code>&lt;script&gt;</code>标签引入如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"libraryA.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module3.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这些数据的接口将连接到全局对象中。常见的问题如下：</p>
<ul>
<li>在全局对象中产生冲突；</li>
<li>数据引入顺序非常重要；</li>
<li>开发者需要手动管理引入模块的依赖关系；</li>
<li>在数据较多的情况下会导致引入列表过长，难以管理。</li>
</ul>
<p><strong>CommonJS：同步请求</strong>  </p>
<p>通过利用<code>require</code>方法来加载依赖，同时返回一个接口，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"module"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"../file.js"</span>);</span><br><span class="line">exports.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = someValue;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>服务器端的模块可以重用</li>
<li>有很多已写好的模块（npm）</li>
<li>简单易用</li>
</ul>
<p>缺点：</p>
<ul>
<li>网络的阻塞调用效果不太好，而且网络请求是异步的</li>
<li>复合模块不能并行请求</li>
</ul>
<p>应用：</p>
<ul>
<li>node.js</li>
<li>browerify</li>
<li>modules-webmake</li>
<li>wreq</li>
</ul>
<p><strong>AMD：异步请求</strong>  </p>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">异步的模块的定义</a><br>有一些浏览器在处理同步引入模块时会有一些问题，为此引入了异步加载模块，具体方式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">define(<span class="string">"mymodule"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ul>
<li>符合异步加载网络请求的模式</li>
<li>并行加载符合模块</li>
</ul>
<p>缺点：  </p>
<ul>
<li>读写难度较大</li>
<li>类似于一种变通方式  </li>
</ul>
<p>应用：  </p>
<ul>
<li>require.js</li>
<li>curl</li>
</ul>
<p>更多关于<a href="http://webpack.github.io/docs/commonjs.html" target="_blank" rel="external">CommonJS</a>以及<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>的内容。</p>
<p><strong>ES6模块</strong></p>
<p>ES6加入了一些JavaScript构造器，这就组成了一种模块系统，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"jquery"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">module</span> <span class="string">"localModule"</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ul>
<li>静态分析变得简单</li>
<li>指明了ES标准的方向</li>
</ul>
<p>缺点：</p>
<ul>
<li>本地浏览器支持还需要时间</li>
<li>已有的模块较少</li>
</ul>
<p><strong>转移</strong></p>
<p>因为模块需要在客户端执行，那么就必须将它们从服务器端转移到浏览器端。<br>有两种极端的转移情况：</p>
<ul>
<li>每个模块一个请求</li>
<li>所有的模块在一个请求</li>
</ul>
<p>这两种情况都是存在的，但都不是最优的：</p>
<ul>
<li>每个模块一个请求：<ul>
<li>优点：按需加载模块</li>
<li>缺点：更多的请求以为着更多的工作量</li>
<li>缺点：应用启动速度慢</li>
</ul>
</li>
<li>所有模块在一个请求：<ul>
<li>优点：请求工作量较少，延迟较低</li>
<li>缺点：不需要（或暂不需要）的模块也会被一并加载</li>
</ul>
</li>
</ul>
<p><strong>Chunked 转移方式</strong></p>
<p>面对上面两种方式所带来的问题，在大多数的案例中，采用折中的方案会取得比较好的效果。</p>
<p>→ 编译所有模块:将模块组合分成较小一些的组（chunks）。<br>这样做能够使得初始化是没有被请求的数据在被请求时再加载，能起到加快启动速度的同时加载比需要更多的代码。</p>
<p>“代码分割点”可以由开发者自己决定。</p>
<p>→  大代码库成为可能！</p>
<p>注：这个构思来自于 <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting" target="_blank" rel="external">Google’s GWT.</a></p>
<p>更多关于 <a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">代码分割。</a></p>
<p><strong>为什么只应用在JavaScript？</strong></p>
<p>为什么模块系统仅仅用于管理JavaScript？还有许多其他资源需要管理：</p>
<ul>
<li>样式</li>
<li>图片</li>
<li>字体</li>
<li>html文件</li>
<li>等等  </li>
</ul>
<p>以及转化过或者处理过的：</p>
<ul>
<li>coffeescript → JavaScript</li>
<li>elm → JavaScript</li>
<li>less stylesheets → css stylesheets</li>
<li>等等</li>
</ul>
<p>这些处理起来非常简单，如：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</span><br></pre></td></tr></table></figure></p>
<p>想达到这种效果，需要用到loader，更多阅读 <a href="http://webpack.github.io/docs/using-loaders.html" target="_blank" rel="external">loader。</a></p>
<hr>
<h3 id="Webpack及安装"><a href="#Webpack及安装" class="headerlink" title="Webpack及安装"></a>Webpack及安装</h3><p><strong>Webpack介绍</strong></p>
<p><strong>Webpack是一种模块打包机。</strong><br>Webpack用于处理有依赖关系的模块，它会生成一些静态文件来表示这些模块。简单而言，如下图所示：<br><img src="http://webpack.github.io/assets/what-is-webpack.png" alt="Webpack"></p>
<p><strong>为什么还需要模块打包机？</strong><br>简单而言，是因为现在的打包机无法满足大型的单页应用。而真正促使开发新型打包机的原因是代码分割和静态文件在模块化的过程中需要无缝连接。我尝试过拓展现存的打包机，但是都不能达到这些要求（注：Webpack作者）。</p>
<p><strong>目标</strong>  </p>
<ul>
<li>将依赖分割成不同的chunk，按需加载</li>
<li>让初始加载时间较少</li>
<li>每个静态文件都应该是一个模块</li>
<li>能将第三方的库整合成模块</li>
<li>打包机本身可高度定制</li>
<li>适合大型项目</li>
</ul>
<p><strong>Webpack有什么不同？</strong>  </p>
<p><a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">代码分割</a><br>Webpack的依赖关系有两种类型：同步和异步。<br>异步依赖相当于分割点，会形成一个新的chunk。当chunk之间的关系最优化之后，每个chunk都会有一个相关文件。   </p>
<p><a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="external">Loaders</a><br> Webpack只能在本地处理JavaScript，而利用loaders能够将其他资源转化成JavaScript，通过这种手段，所有的资源都能形成模块。  </p>
<p><strong>智能解析</strong><br>Webpack的智能解析功能使得它基本上能够处理所有第三方库，甚至允许模块以下面这种方式来表示依赖关系：<code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;).</code>它能兼容常见的模块模式，如 <a href="http://webpack.github.io/docs/commonjs.html" target="_blank" rel="external">CommonJS</a> 以及 <a href="http://webpack.github.io/docs/amd.html" target="_blank" rel="external">AMD</a>。</p>
<p><a href="http://webpack.github.io/docs/plugins.html" target="_blank" rel="external">插件系统</a><br>Webpack的强大离不开其强大的插件系统的支持。这也使得Webpack具有高度定制性，也吸引人们创造更多的开源插件</p>
<p><strong>安装</strong><br><strong>node.js</strong><br>首先安装 <a href="http://nodejs.org/" target="_blank" rel="external">node.js</a>，里面包含了一种包管理工具，叫做npm。  </p>
<p><strong>Webpack</strong><br>用npm来全局安装Webpack，全局安装的话就可以在全局环境中直接用 <code>Webpack</code> 命令了，命令行如下：<br><code>$ npm install webpack -g</code>  </p>
<p><strong>在项目中引入</strong><br>做项目的时候最好以项目依赖的方式引入Webpack，那样的话就不会去依赖全局的Webpack了。<br>首先利用npm新建一个package.json配置文件，命令行如下：<br><code>$ npm init</code><br>上面提到的项目依赖的方式安装Webpack可以通过以下命令行实现：<br><code>$ npm install webpack --save-dev</code></p>
<p><strong>版本</strong><br>有两个版本的Webpack可供下载，一个是稳定版本，另一个是测试版本。测试版本有<code>-beta</code>的后缀，这个版本会包含一些带有实验性质的性能，而且也没有经过大量的测试。所以建议对稳定性能要求较高的同志们选择稳定版本，命令行如下：<br><code>$ npm install webpack@1.2.x --save-dev</code></p>
<p><strong>开发者工具</strong><br>如果需要使用开发者工具，就需要安装了，命令行如下：<br><code>$ npm install webpack-dev-server --save-dev</code></p>
<hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>安装</strong><br>上面已经提到可全局安装或者以项目依赖的方式安装。在实际项目中，建议都以项目依赖的方式安装，本文为了方便展示，都是以全局安装为例的。  </p>
<p><strong>开始使用</strong>  </p>
<ul>
<li><p>首先用CommonJS语法创建一个模块化的JavaScript项目，名字为<code>cat.js</code>，代码如下：  </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cats.js</span></span><br><span class="line"><span class="keyword">var</span> cats = [<span class="string">'dave'</span>, <span class="string">'henry'</span>, <span class="string">'martha'</span>];</span><br><span class="line">module.<span class="keyword">exports</span> = cats;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js(Entry Point)</span></span><br><span class="line">cats = <span class="built_in">require</span>(<span class="string">'./cats.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cats);</span><br></pre></td></tr></table></figure>
<p><code>Entry Point</code>是项目接入模块的入口，Webpack也是从这个接口开始检查各个模块之间的依赖关系的。</p>
</li>
<li><p>打包文件：Webpack需要指定入口文件（app.js），同时也需要明确的指定输出文件的名字（app.bundle.js），指令如下：<br><code>webpack ./app.js app.bundle.js</code><br>然后Webpack会解读入口文件同时分析其依赖（以及依赖的依赖），分析完以后，会将所有的依赖绑定输出到输出文件中（本例为app.bundle.js）。<br><img src="https://dtinth.github.io/webpack-docs-images/usage/how-it-works.png" alt="webpack"></p>
</li>
<li><p>然后就可以运行了，在node中运行及结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">app</span>.bundle.js</span><br><span class="line">[<span class="string">"dave"</span>, <span class="string">"henry"</span>, <span class="string">"martha"</span>]</span><br></pre></td></tr></table></figure>
<p>当然了，也可以在浏览器的环境下运行。  </p>
</li>
</ul>
<p><strong>使用进阶</strong><br>webpack具有很多高级功能，很多功能通过命令行工具很难体现出来，这时候我们就需要去创建配置文件了。</p>
<ul>
<li><p>项目结构：在实际的生产环境中，我们会将源文件和输出文件放在不同的文件夹中以便于管理，典型的例子如下图所示：<br><img src="https://raw.githubusercontent.com/dtinth/webpack-docs-images/2459637650502958669ea6b11bf49dc0b3b083ae/usage/project-structure.png" alt="folders"></p>
<blockquote>
<p><em>在实际的生产环境中会有很多类似但并不完全相同的项目结构，比如有些项目会将 src 文件夹命名为 APP ，会将 bin 文件夹命名为 dist 或者是 build ，等等诸如此类，其实都是一样的。</em></p>
</blockquote>
</li>
<li><p>配置文件：当项目变得越来越庞大复杂的时候，手动设置这些就显得不是那么明智了，这时候可以创建一个配置文件，名字叫做<code>webpack.config.js</code>:</p>
<ol>
<li><p>创建一个<code>webpack.config.js</code>的配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    entry: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'./bin'</span>,</span><br><span class="line">        filename: <span class="string">'app.bundle.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置文件放在合适的位置，现在运行webpack只需要以下代码：<br><code>webpack</code><br>然后webpack就会去解析配置文件，并按照配置文件中的配置来解读接入文件以及输出文件到指定位置。</p>
</li>
</ol>
</li>
<li><p>引入loaders：webpack本身只支持JavaScript模块，为了支持其他模块，就需要引入各种loader了。loader能够将其他资源加载成webpack能够识别的JavaScript。典型的例子如 babel-loader，json-loader等，如下图：<br><img src="https://dtinth.github.io/webpack-docs-images/usage/babel-loader.png" alt="babel-loader"><br><img src="https://dtinth.github.io/webpack-docs-images/usage/json-loader.png" alt="json-loader"><br><img src="https://dtinth.github.io/webpack-docs-images/usage/yaml-loader.png" alt="yaml-loader"></p>
</li>
<li><p>以babel-loader为例说明如下：</p>
<ol>
<li>安装Babel：<br><code>npm install --save-dev babel-core babel-preset-es2015</code></li>
<li>安装babel-loader：<br><code>npm install --save-dev babel-loader</code></li>
<li>新建一个.babelrc文件，这个文件用来配置Babel，使其利用预先设置的语法（es2015）来解析。.babelrc的内容如下：<br><code>{ &quot;presets&quot;: [ &quot;es2015&quot; ] }</code></li>
<li><p>更改 webpack.config.js 文件，使的所有的 .js 文件都用 babel-loader 来处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/app.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">      path: <span class="string">'./bin'</span>,</span><br><span class="line">      filename: <span class="string">'app.bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">module</span>: &#123;</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          loader: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注意：这里讲node_modules文件排除在外了，因为不排除的话，这些外部的插件库也会被Babel处理，从而减缓编译速度</em>  </p>
</blockquote>
</li>
<li><p>安装所需要的其他库（以jQuery为例）：<br><code>npm install --save jquery babel-polyfill</code></p>
<blockquote>
<p><em>注意：这里没有用 –save-dev，因为这些库只有在项目运行时才会使用，同时为了能在低版本的浏览器中使用ES6的特性，这里安装了babel-ployfill。</em></p>
</blockquote>
</li>
<li><p>编辑 <code>src/app.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;</span><br><span class="line"><span class="keyword">import</span> cats <span class="keyword">from</span> <span class="string">'./cats'</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'&lt;h1&gt;Cats&lt;/h1&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">const</span> ul = $(<span class="string">'&lt;ul&gt;&lt;/ul&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> cat <span class="keyword">of</span> cats) &#123;</span><br><span class="line">    $(<span class="string">'&lt;li&gt;&lt;/li&gt;'</span>).text(cat).appendTo(ul);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用webpack来打包模块：<br><code>webpack</code></p>
</li>
<li><p>创建一个index.html文件，并将打包好的文件引入，以便于在浏览器中展示出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bin/app.bundle.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>当打开index.html时，不出意外的话会看到下图：<br><img src="https://dtinth.github.io/webpack-docs-images/usage/cats.png" alt="cats"></p>
</li>
</ol>
</li>
<li><p>引入插件：在实际生产环境中，我们可能会需要使用一些插件来处理打包好的文件，比如说我们可能会想压缩文件以便于更快的加载速度，这时候就需要使用插件了，以 <code>uglify</code> 插件为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'./bin'</span>,</span><br><span class="line">        filename: <span class="string">'app.bundle.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">            compress: &#123;</span><br><span class="line">                warnings: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            output: &#123;</span><br><span class="line">                comments: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于webpack本身自带 Uglify 这个插件，所以使用时不需引入，但是如果需要使用其他没有内置的插件的时候，还是需要手动引入的，而且自己也可以写插件。</p>
<hr>
<h3 id="使用-Loaders"><a href="#使用-Loaders" class="headerlink" title="使用 Loaders"></a>使用 Loaders</h3><p><strong>什么是 loaders ？</strong><br>loaders是一些对你的项目中的资源进行转化的工具，它们是一些把源文件的路径作为参数的函数，然后通过函数返回新的路径。<br>例如，webpack中可以通过使用loader来加载CoffeeScript或者是JSX。</p>
<p>loader的特征：</p>
<ul>
<li>loaders 可以链式应用（如上一节提到的.yml文件的解析）。链式应用的中间文件的格式可以是任意的，只要最后输出的格式是JavaScript格式即可</li>
<li>loaders 可以是同步的或者是异步的；</li>
<li>loaders 可以在nodejs环境下运行，也可以实现所有可能实现的功能；</li>
<li>loaders 可接受查询参数，可以利用这个功能来配置loader；</li>
<li>loaders 可以在配置文件中被绑定到正则表达式或者扩展中；</li>
<li>loaders 可以通过npm来发布或者是安装；</li>
<li>一般的模块都可以通过 <code>package.json loader</code> 在输出<code>main</code>之外还输出一个 loader ；</li>
<li>loaders 可以读取配置文件；</li>
<li>插件可以使 loaders 的功能更强大；</li>
<li>loaders 可以生成任意的附加文件；</li>
<li><a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="external">等等</a></li>
</ul>
<p><strong>解析loaders</strong><br>loaders 的解析方式和模块类似，loader 模块一般会输出一个 nodejs 能够识别的函数。通常情况下我们会用 npm 来管理 loaders ，但是我们也可以以文件的形式直接放在应用文件夹中。</p>
<ul>
<li><p>引用 loaders<br>按照惯例，我们通常将 loaders 命名为<code>xxx-loader</code>其中 xxx 表示的就是具体的名称，比如 <code>json-loader</code>。在引用的时候，既可以用全名，也可以用简写（不包括loader部分）。<br>loader 的命名规则以及搜索优先顺序被定义在 webpack 配置 API 文件 <code>resolveLoader.moduleTemplates</code> 中。<br>loader 的命名规则有时候会派上用场，尤其是利用 <code>require()</code> 来引用它们的时候。</p>
</li>
<li><p>安装 loaders<br>只要 npm 中有你需要的 loaders， 那么那就可以通过以下任意一种方式来安装它们：<br><code>$ npm install xxx-loader --save</code> 或者是 <code>$ npm install xxx-loader --save-dev</code><br>(其中后者是以生产依赖的方式安装，前者为普通安装。以生产依赖的方式安装会自动改变 webpack 的配置文件中的依赖部分)</p>
</li>
</ul>
<p><strong>用法</strong><br>有很多途径都能在项目中应用 loaders：</p>
<ul>
<li>直接通过 <code>require</code> 声明来引用</li>
<li>通过配置文件来配置</li>
<li>通过 CLI 来配置</li>
</ul>
<p>以下将分别就这三种方式进行说明：  </p>
<ul>
<li><p>通过 <code>require</code> 方式  </p>
<blockquote>
<p><em>注意：如果你不能确定你的脚本的运行环境，那么就尽可能不要使用这种方式，而是利用配置规则来使用 loaders。</em></p>
</blockquote>
<p>利用 <code>require</code>声明（或者 <code>define</code>, <code>require.ensure</code> 声明 ）是可以规范化使用 loader 的，只要通过使用 <code>!</code> 符号将需处理文件和 loader 隔开。如果有多个 loader， 那么将遵循从右到左的顺序依次解析。 具体例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./loader!./dir/file.txt"</span>);</span><br><span class="line"><span class="comment">// uses the file "loader.js" in the current directory to transform</span></span><br><span class="line"><span class="comment">// "file.txt" in the folder "dir".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jade!./template.jade"</span>);</span><br><span class="line"><span class="comment">// uses the "jade-loader" (that is installed from npm to "node_modules")</span></span><br><span class="line"><span class="comment">// to transform the file "template.jade"</span></span><br><span class="line"><span class="comment">// If configuration has some transforms bound to the file,</span></span><br><span class="line"><span class="comment">// they will still be applied.</span></span><br><span class="line"><span class="comment">// 如果此时配置文件中规定了需要处理这个文件，那么这时候会处理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"!style!css!less!bootstrap/less/bootstrap.less"</span>);</span><br><span class="line"><span class="comment">// the file "bootstrap.less" in the folder "less" in the "bootstrap"</span></span><br><span class="line"><span class="comment">// module (that is installed from github to "node_modules") is</span></span><br><span class="line"><span class="comment">// transformed by the "less-loader". The result is transformed by the</span></span><br><span class="line"><span class="comment">// "css-loader" and then by the "style-loader".</span></span><br><span class="line"><span class="comment">// If configuration has some transforms bound to the file,</span></span><br><span class="line"><span class="comment">// they will not be applied.</span></span><br><span class="line"><span class="comment">// 由于此处在规则的最前面加了前缀 “！”， 如果配置文件中规定了需要处理这个文件，</span></span><br><span class="line"><span class="comment">// 那么这时候仍然不会处理。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="external">配置文件方式</a><br>在配置文件中可以通过用正则表达式的方式来绑定 loaders ，如下所示：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; test: <span class="regexp">/\.jade$/</span>, loader: <span class="string">"jade"</span> &#125;,</span><br><span class="line">            <span class="comment">// =&gt; "jade" loader is used for ".jade" files</span></span><br><span class="line"></span><br><span class="line">            &#123; test: <span class="regexp">/\.css$/</span>, loader: <span class="string">"style!css"</span> &#125;,</span><br><span class="line">            <span class="comment">// =&gt; "style" and "css" loader is used for ".css" files</span></span><br><span class="line">            <span class="comment">// Alternative syntax:</span></span><br><span class="line">            &#123; test: <span class="regexp">/\.css$/</span>, loaders: [<span class="string">"style"</span>, <span class="string">"css"</span>] &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://webpack.github.io/docs/cli.html" target="_blank" rel="external">CLI 方式</a><br>可以通过命令行工具来绑定 loaders， 如下所示：<br><code>$ webpack --module-bind jade --module-bind &#39;css=style!css&#39;</code><br>上面的例子会使得利用 <code>jade-loader</code> 来处理 <code>.jade</code> 文件， 用<code>css-loader &amp; style-loader</code> 来处理 <code>.css</code> 文件。</p>
</li>
</ul>
<p><strong>查询参数</strong><br>  可以通过使用 <code>?</code> 的方式来决定是否使用 loader，比如 <code>url-loader?mimetype=image/png</code> 表示就是，如果媒体文件都是图片格式， <code>mimetype=image/png</code>，那么就使用 <code>url-loader</code>来进行处理。<br>  注意：查询语法根据不同的 loader 可能会不一样，具体情况需要查询相应的文档。但是一般而言，都支持常见的查询语法，如 <code>(?key=value&amp;key2=value2)</code>，或者JSON对象如 <code>(?{&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></p>
<p>与上面提到的三种方式相对应的，利用查询的写法如下：</p>
<ul>
<li>通过 <code>require()</code> 方式：<br><code>require(&quot;url-loader?mimetype=image/png!./file.png&quot;);</code></li>
<li><p>通过配置文件：<br><code>{ test: /\.png$/, loader: &quot;url-loader?mimetype=image/png&quot; }</code><br>或者写的好看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.png$/</span>,</span><br><span class="line">loader: <span class="string">"url-loader"</span>,</span><br><span class="line">query: &#123; mimetype: <span class="string">"image/png"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLI方式：<br><code>webpack --module-bind &quot;png=url-loader?mimetype=image/png&quot;</code></p>
</li>
</ul>
<hr>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>使用插件能够增强 webpack 的功能，比如，利用 <a href="https://github.com/senotrusov/bell-on-bundler-error-plugin" target="_blank" rel="external"> BellOnBundlerErrorPlugin</a> 插件就能提示在打包过程中出现的错误。</p>
<p><strong>内置插件</strong><br>对于内置插件，如果在 webpack 的配置文件中有用到它们的功能，那么就会将这些插件包含在模块中。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack should be in the node_modules directory, install if not.</span></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.ResolverPlugin([</span><br><span class="line">            <span class="keyword">new</span> webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(<span class="string">"bower.json"</span>, [<span class="string">"main"</span>])</span><br><span class="line">        ], [<span class="string">"normal"</span>, <span class="string">"loader"</span>])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>外部插件</strong><br>外部的插件可以通过 <code>npm</code> 来安装，例如：<br><code>npm install component-webpack-plugin</code><br>安装完之后就可以使用了，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentPlugin = <span class="built_in">require</span>(<span class="string">"component-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ComponentPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用 <code>npm</code> 来安装第三方插件的时候，建议使用这个工具: <a href="https://www.npmjs.com/package/webpack-load-plugins" target="_blank" rel="external">https://www.npmjs.com/package/webpack-load-plugins</a> ，它会自动检测依赖中的所有插件，然后在需要的时候懒加载它们。</p>
<p><strong>更多阅读</strong><br><a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="external">了解更多，可查看插件列表</a></p>
<hr>
<h3 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h3><p><strong>解析过程</strong></p>
<ul>
<li>常见故障：<ul>
<li>利用 <code>--display-error-details</code> 可以得到详细信息</li>
<li>阅读配置文件，关于故障分析的部分都在 <code>resolve</code></li>
<li>loaders 的配置文件中有对应的故障分析 <code>resolveLoader</code></li>
</ul>
</li>
</ul>
<ul>
<li>npm 链接模块找不到所需依赖<br>&nbsp;&nbsp;&nbsp;&nbsp;node.js 的模块解析算法非常简单：系统寻找模块依赖时，会在所需模块的父文件夹的 <code>node_modules</code> 文件夹中寻找。如果你 npm 链接的带有同级依赖的模块没有放在根目录下，那么系统就无法找到这些模块（你可能会认为带有 <code>npm link</code> 的 <code>peerDependencies</code> 是 node.js 的设计缺陷）。需要注意的是应用的依赖也是一种 <code>peerDependencies</code>， 即使这种依赖并没有在模块的 <code>package.json</code> 文件中列出来。<br>&nbsp;&nbsp;&nbsp;&nbsp;要在 webpack 中分析这个问题其实很简单：只需要将应用的 <code>node_modules</code> 文件夹放在解析路径中，具体的设置例子如下：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123; fallback: path.join(__dirname, <span class="string">"node_modules"</span>) &#125;,</span><br><span class="line">  resolveLoader: &#123; fallback: path.join(__dirname, <span class="string">"node_modules"</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>监测过程</strong></p>
<ul>
<li><p>监测过程中， webpack 不会在资源有变动时重编译</p>
</li>
<li><p>监测到文件变化，但是文件并没有更新<br>&nbsp;&nbsp;&nbsp;&nbsp;可以确定的是，在 webpack 中，如果运行时加上了 <code>-progress</code> 标签，那么资源的变动将不会被监测。如果保存时能看到进展但却没有文件输出，那么就可能是配置上的问题，而不是文件监测问题了。<br><code>webpack --watch --progress</code></p>
</li>
<li><p>监测器不够<br>&nbsp;&nbsp;&nbsp;&nbsp;首先需要确认你的系统中是否有足够可用的检测器，如果可用数量太少，那么 webpack 中的检测器可能就检测不到变化了：<br><code>cat /proc/sys/fs/inotify/max_user_watches</code><br>对于 Arch 用户，将 <code>fs.inotify.max_user_watches=524288</code> 加到 <code>/etc/sysctl.d/99-sysctl.conf</code> 文件中，然后执行 <code>sysctl --system</code>。对于 Ubutu 用户：<code>echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p.</code></p>
</li>
<li><p>OS-X FSevents bug<br>在 OS-X 系统中，文件夹可能会崩溃，具体可参考下面的文章：<br><a href="http://feedback.livereload.com/knowledgebase/articles/86239-os-x-fsevents-bug-may-prevent-monitoring-of-certai" target="_blank" rel="external">OS X FSEvents bug may prevent monitoring of certain folders</a></p>
</li>
<li><p>Windows 路径<br>&nbsp;&nbsp;&nbsp;&nbsp;在 webpack 中的很多配置选项默认都是绝对路径。 <code>__dirname + &quot;/app/folder&quot;</code> 这种写法是错误的，因为在 Windows 系统中路径的分隔符是 <code>\</code>。这有时候会产生一些问题。建议使用正确的分隔符，比如 <code>path.resolve(__dirname, &quot;app/folder&quot;)</code> 或者 <code>path.join(__dirname, &quot;app&quot;, &quot;folder&quot;).</code></p>
</li>
<li><p>Vim<br>&nbsp;&nbsp;&nbsp;&nbsp;有些型号的机器上，Vim 的 <code>backupcopy option</code> 会被默认设置成 <code>auto</code>。这有可能会影响到系统的文件监测机制。所以建议将这个选项设置为 <code>yes</code>，这样的话就会在保存的时候覆盖原文件并保存一份副本。Vim 中的设置如下：<br><code>:set backupcopy=yes</code></p>
</li>
<li><p>WebStorm<br>&nbsp;&nbsp;&nbsp;&nbsp;当使用 JetBrains 的 WebStorm 的 IDE 的时候，你可能会发现在保存更改过的文件时并没有触发预想中的检测器。这时候就需要设置 <code>safe write</code> 选项了，这个选项决定了是否在保存更改过的文件前保存一份原文件在临时路径中： 取消下列设置<br><code>File &gt; Settings... &gt; System Settings &gt; Use &quot;safe write&quot; (save changes to a temporary file first).</code></p>
</li>
</ul>
<hr>
<h2 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h2><blockquote>
<p>文档比较混乱，所以先放一放，后面的部分写好再来。</p>
</blockquote>
<hr>
<h2 id="指导文件"><a href="#指导文件" class="headerlink" title="指导文件"></a>指导文件</h2><h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p>为了解决JS中作用域的问题， CommonJS 小组定义了一种模块格式，这可以确保所有的模块都在自己的命名空间执行。<br>怎样能到达到这个目的呢？其一需要在模块中明确的输出那些适用于全局作用域的变量，其二需要定义其他模块需要的变量。<br>为了达到这个效果， CommonJS 给我们提供了两个工具：</p>
<ul>
<li>利用 <code>require()</code> 函数可以将一个指定的模块引入到现在的作用域；</li>
<li>利用 <code>module</code> 对象可以将现在作用域中内容输出；</li>
</ul>
<p><strong>简单的例子</strong><br>下面是一个不用 CommonJS 的例子：<br>首先在一个js文件中定义一个变量，这个文件在之后其他的文件中将会被用到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在另一个文件中应用这个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">" world!"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>定义模块</strong><br>上面的例子中将会因为 <code>MySalute</code> 没有被定义而报错，我们应该将这些文件定义为模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = MySalute;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = Result;</span><br></pre></td></tr></table></figure>
<p>在这两个例子中，我们将变量传入到了一个特殊的变量 <code>module</code> 中，这样一来 CommonJS 的模块系统就知道模块中需要被输出的对象了： <code>salute.js</code> 中输出 <code>MySalute</code> 对象，  <code>world.js</code> 中输出  <code>Result</code> 对象。</p>
<p><strong>模块依赖</strong><br>上面已经很接近了，但是还差一步：定义依赖。虽然都分别定义了自个为独立的模块，但是 <code>world.js</code> 还是不知道在哪里找到 <code>MySalute</code> 的定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = MySalute;</span><br></pre></td></tr></table></figure></p>
<p>我们需要做的最后一步就是在 <code>world.js</code> 中引入模块的依赖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="built_in">require</span>(<span class="string">"./salute"</span>);  <span class="comment">// This is it!</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">"world!"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = Result;</span><br></pre></td></tr></table></figure></p>
<p>需要注意，在我们利用 <code>require</code> 引用的时候，并没有使用 <code>salute.js</code> 的全名，意思就是我们可以省略后缀。 <code>./</code> 符号表示的是相对路径：引用文件和被引用文件在同一个文件夹目录下。</p>
<p><strong>最后的例子</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> multiplyBy2 = <span class="built_in">require</span>(<span class="string">'./moduleA'</span>);</span><br><span class="line"><span class="keyword">var</span> result = multiplyBy2( <span class="number">4</span> );</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD (Asynchronous Module Definition) 的产生是因为有些人认为 CommonJS 的模块系统暂时还不适合浏览器环境，因为从本质上来说 CommonJS 的模块是同步加载的。<br>AMD 指出了一种模块化 JavaScript 的规范， 按照这个规范模块能够异步加载它们的依赖，这就解决了同步加载带来的问题。</p>
<p><strong>规范说明</strong><br>在 AMD 中，模块是利用<code>define</code> 来定义的。<br><em>define</em><br>在 AMD 规范中利用 <code>define</code> 函数定义模块的形式如下：<br><code>define(id?: String, dependencies?: String[], factory: Function|Object);</code><br><em>id</em><br>模块的名字，为可选项<br><em>dependencies</em><br>这个参数是用来指出正在被定义的这个模块所需要依赖的其他模块，这个参数是个数组，里面包含了依赖模块的标识符。这也是一个可选参数，如果省略不写，默认值则是：<code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code><br><em>factory</em><br>这个参数是用来定义模块的。它可以是个函数（这个函数应该会被调用），或者是个对象。如果这个参数是个函数，那么函数的返回值将会是这个模块的输出值。</p>
<p><strong>例子</strong><br>简单的来看一些例子。</p>
<ul>
<li><p>具名模块<br>定义一个依赖 <code>jquery</code> 的名字为 <code>myModule</code> 的模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'myModule'</span>, [<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ is the export of the jquery module.</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// and use it</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：在 webpack 中一个具名模块只在本地有效，而在 Require.js 中则是全局有效的。</p>
</li>
<li><p>匿名模块<br>定义一个匿名模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂模块<br>定义一个具有多重依赖的模块，需要注意的是每个模块的输出都会传到 <code>factory</code> 函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>, <span class="string">'./math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ and math are the exports of the jquery module.</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出值<br>定义一个输出自身的模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> HelloWorldize = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</span><br><span class="line">        $(selector).text(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HelloWorldize;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个利用 <code>require</code> 来加载依赖的模块：</p>
<blockquote>
<p>因为没有定义依赖， webpack 将将上面提到的默认值传入后面的函数 ，然后就可以利用这些参数做文章了。</p>
</blockquote>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于大型的网页应用而言，把所有的代码放在一个文件中往往会效率低下，特别是当其中有些代码块只需要在特定环境下加载的时候。 webpack 中有一个特性，这个特性能够将代码分割成许多的 <code>chunks</code> ，这些代码块只会在被需要的时候才加载。有些其他的打包机将被分割的代码块称作为 <code>layers</code>, <code>rollups</code> 或者 <code>fragments</code>。这个特性就叫做“代码分割”。<br>&nbsp;&nbsp;&nbsp;&nbsp;这是一个可选的特性。我们可以在代码中定义代码分割点，然后 webpack 内部来处理依赖关系，输出文件和执行环境等事物。<br>&nbsp;&nbsp;&nbsp;&nbsp;在这里需要澄清一个概念：代码分割的功能不仅仅是将普通的代码提取分割成共享的代码块（chunk），它最重要的功能其实是将代码分割成能够 <strong>按需加载</strong> 的代码块。这样就会减少网页应用的初始加载量，并使得其他代码能够按需加载。</p>
<p><strong>定义分割点</strong><br>AMD 和 CommonJS 通过不同的方式使得代码按需加载。这些方法都是有效的，分别如下所示：</p>
<ul>
<li><p>CommonJS： <code>require.ensure</code></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies, callback)</span><br></pre></td></tr></table></figure>
<p>  <code>require.ensure</code> 方法可以确保当调用回调函数的时候，所有在 <code>dependencies</code> 中的依赖都能够被同步调用。<code>callback</code> 函数再被调用的时候会将 <code>require</code> 函数当做参数传入。<br>  例子如下：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">"module-a"</span>, <span class="string">"module-b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"module-a"</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  注意：<code>require.ensure</code> 函数仅仅是加载模块，并不会执行它们。</p>
</li>
<li><p>AMD： <code>require</code><br>AMD 规范中定义了一种异步的 <code>require</code> 方法，如下所示：<br><code>require(dependencies, callback)</code><br>当被调用时，所有的依赖都会被加载，而且加载的依赖的输出将会被传入到回调函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module-a"</span>, <span class="string">"module-b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  注意： AMD 中 <code>require</code> 方法是会加载并执行模块的。在 webpack 中模块式从左到右执行的。<br>  注意：回调函数是可以省略的。</p>
</li>
<li><p>ES6 模块<br>webpack 不支持 ES6 模块，需要根据编译器支持哪种格式的模块格式来选择是使用 <code>require</code> 还是 <code>require.ensure</code>.<br>webpack 1.xx（即将到来的2.0.0）版本本身并不支持 ES6 模块。但是可以利用编译器，比如 <code>Babel</code> 来将 ES6 中的 <code>import</code> 语法转换成 CommonJS 或者 AMD 模块，从而达到目的。这种方法很有效，但是动态加载的时候会产生一个警告。<br>模块的语法（<code>import x from &quot;foo&quot;</code>）被故意设计成只能静态分析，所以不能够动态引入模块：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// INVALID!!!!!!!!!</span><br><span class="line">[“lodash”, “backbone”].forEach(name =&gt; import name )</span><br></pre></td></tr></table></figure>
<p>不过幸运的是，在规范中提到可以利用一个 JavaScript API 中的 <code>loader</code> 来处理动态引入的情况：<code>System.load(or Sytem.import)</code>。这个 API 能起到和上面提到的 <code>require</code> 一样的作用。然而，大部分的编译器并不支持将 <code>System.load</code> 转化成 <code>require.ensure</code>，所以这时候如果想要动态的代码分割的话只能是直接去做了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//static imports</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dynamic imports</span></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contacts = <span class="built_in">require</span>(<span class="string">'./contacts'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Chunk 内容<br>在一个分割点内的所有依赖都会被包括在一个 Chunk 中，它们会被递归的加到这个 chunk 中。<br>如果你将一个函数表达式作为回调函数传入（或者绑定）到一个分割点， Webpack 会自动的将这个函数表达式中所需要的依赖同时打包到这个 chunk 中。</p>
</li>
<li><p>Chunk 优化</p>
<ul>
<li>如果两个 chunks 包含了同样的模块，那么这两个 chunk 将会合并成一个。这会造成 chunks 会有多重父级；</li>
<li>如果一个模块在一个 chunk 的所有父级中都出现了，那么这个模块将会从这个 chunk 中移除；</li>
<li>如果一个 chunk 包含了另一个 chunk 中的所有模块，那么将会形成多重 chunks。</li>
</ul>
</li>
<li><p>Chunk 加载<br>基于一个叫做 <code>target</code> 的配置选项，关于 chunk 加载的运行环境会被加入到 <code>bundle</code> 文件中，例如：当 <code>target</code> 是 web 时， chunks 将会通过 jsonp 来加载。一个 chunk 只会加载一次， 并行的请求也会合并成一个请求。运行环境会检查已经加载的 chunk 是否形成复合 chunks。</p>
</li>
<li><p>Chunk 类型</p>
<ul>
<li>入口 chunk<br>入口代码块包含了运行环境以及一些模块。如果 chunk 中包含了模块 <code>Θ</code>， 那么将在运行环境中执行它。如果不包含这个模块，就会等到包含这个模块的 chunk 然后再执行（每一次遇到包含模块 <code>Θ</code> 的时候都会执行一次）。</li>
<li>普通 chunk<br>普通的 chunk 不包含运行环境，只包含一些模块。里面的结构由 chunk 加载算法来决定。例如，对于 jsonp 而言，模块将会被包含在 jsonp 的回调函数中。 chunk 里面也包含了一个由它来完成的 chunk id 的列表。</li>
<li>初始 chunk（非入口）<br>初始 chunk 是普通 chunk 的一种。它们之间唯一的区别是在优化的时候，初始 chunk 会更加被重视，因为它会影响到初始加载时间（就像入口 chunk 一样）。这种类型的 chunk 会在结合 <code>CommonChunkPlugin</code> 使用的时候产生。</li>
</ul>
</li>
<li><p>拆解 app 以及分离代码<br>为了将 app 拆解成两个文件，比如app.js 以及 vendor.js， 我们可以在 vendor.js 中利用 <code>require</code> 来引入 vendor 参数中的文件。然后将这个名字传入到 <code>CommonsChunkPlugin</code>中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">"./app.js"</span>,</span><br><span class="line">    vendor: [<span class="string">"jquery"</span>, <span class="string">"underscore"</span>, ...],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="comment">/* chunkName= */</span><span class="string">"vendor"</span>, <span class="comment">/* filename= */</span><span class="string">"vendor.bundle.js"</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这会将 vendor chunk 中所包含的所有模块从 app chunk 中移除。 <code>bundle.js</code> 中将只会包含所有的 app 代码，不带有任何的依赖，所有的依赖代码都在 <code>vendor.bundle.js</code> 中。<br>在 HTML 文件中，需要先加载 <code>vendor.bundle.js</code> 然后再加载 <code>bundle.js</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"vendor.bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多个入口 chunks<br>通过<a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="external">配置</a>可以实现多个入口点，这同时会形成多个入口 chunks。入口 chunk 中包含了运行环境，而一个页面中只能包含一个运行环境（当然也会有例外）。</p>
</li>
<li><p>运行多个入口点<br>通过插件 <code>CommonsChunkPlugin</code> 可以将运行环境转移到 commons chunk 中。入口点这时候在初始 chunk 中。虽然只有一个初始 chunk 可以被加载，但是多个入口 chunk 可以被加载。这就说明了在同一个页面中运行多个入口点是可能的。例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">       entry: &#123; a: <span class="string">"./a"</span>, b: <span class="string">"./b"</span> &#125;,</span><br><span class="line">       output: &#123; filename: <span class="string">"[name].js"</span> &#125;,</span><br><span class="line">       plugins: [ <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">"init.js"</span>) ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入的时候，按如下顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"init.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"a.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"b.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Commons Chunk<br>插件 <code>CommonsChunkPlugin</code> 可以将多个入口 chunks 的模块转移到一个新的入口文件（也就是 commons chunk）中。运行环境也被转移到了 commons chunk 中。这意味着原来的入口 chunk 现在变成了初始 chunk。了解更多<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="external">插件选项。</a></p>
</li>
<li><p>优化<br>有一些用于优化的插件能够根据特别的标准将 chunk 合并起来，参考<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="external">插件列表</a></p>
</li>
<li><p>具名 chunks<br><code>require.ensure</code> 函数可以接收额外的第三个参数，这个参数必须是字符串类型。如果两个分割点传入了同样的字符串，那么它们将利用同样的 chunk。</p>
</li>
<li><p><code>require.include</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.include(request)</span><br></pre></td></tr></table></figure>
<p><code>require.include</code> 是 Webpack 中一个特殊的函数，它可以将模块加入到现在的 chunk 中，但是不会去执行它（打包的时候会将声明移除）。例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">"./file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./file2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// is equal to</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.include(<span class="string">"./file"</span>);</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./file2"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果模块是在复合子代码块中，那么这个函数将非常有用。在父级代码块中运用这个函数引入模块将会使得这个子代码块中的模块实例都消失。</p>
</li>
</ul>
<hr>
<h3 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h3><p><strong>内嵌样式表</strong><br>通过利用 <code>style-loader</code> 以及 <code>css-loader</code> 使得将样式表内嵌在 JavaScript 打包文件中变得可能。这种方式下你可以将你的样式表和其他模块一起模块化。引用方式非常简单： <code>require(&quot;./stylesheet.css&quot;)</code>。使用步骤如下：</p>
<ul>
<li><p>安装<br>首先从 <code>npm</code> 上下载 <code>loaders</code><br><code>npm install style-loader css-loader --save-dev</code></p>
</li>
<li><p>配置<br>下面是一个配置参考：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123; test: <span class="regexp">/\.css$/</span>, loader: <span class="string">"style-loader!css-loader"</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对于一些需要编译的 css 样式，可以参考相对应的 loader 的配置例子，然后链式调用它们。</p>
</blockquote>
<p>需要记住的是我们很难管理模块的执行顺序，所以最好设计好样式表使得顺序无关紧要。（在一个 css 文件中，顺序还是可靠的。）</p>
</li>
<li><p>使用<br>使用非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your modules just require the stylesheet</span></span><br><span class="line"><span class="comment">// This has the side effect that a &lt;style&gt;-tag is added to the DOM.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./stylesheet.css"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>独立的样式打包</strong><br>结合使用 <a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="external">extract-text-webpack-plugin</a> 这个插件，可以产生一个本地的 css 输出文件。<br>结合代码分割，我们可以使用两种不同的模式：</p>
<ul>
<li>针对每一个初始 chunk 都创建一个 css 文件， 将样式表内嵌至附加的 chunk 中。（推荐做法）</li>
<li>针对每一个初始 chunk 都创建一个 css 文件，并且这个文件中包含了附加 chunk 的样式。  </li>
</ul>
<p>从初始加载速度优化的角度考虑，推荐使用第一种模式。因为缓存和 http 请求头的原因，在一些具有多个入口点的小型应用中，第二种模式可能会更好一些。</p>
<p>步骤如下：</p>
<ul>
<li><p>安装插件<br><code>npm install extract-text-webpack-plugin --save</code></p>
</li>
<li><p>处理初始 chunk 中的样式生成分离的 css 文件输出<br>下面展示的虽然是多个入口点的例子，但是这种方式也适合单个入口点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// The standard entry point and output config</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        posts: <span class="string">"./posts"</span>,</span><br><span class="line">        post: <span class="string">"./post"</span>,</span><br><span class="line">        about: <span class="string">"./about"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].js"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            <span class="comment">// Extract css files</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// Optionally extract less files</span></span><br><span class="line">            <span class="comment">// or any other compile-to-css language</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(<span class="string">"style-loader"</span>, <span class="string">"css-loader!less-loader"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// You could also use other loaders the same way. I. e. the autoprefixer-loader</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Use the plugin to specify the resulting filename (and add needed behavior to the compiler)</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你会得到如下文件：</p>
<ul>
<li><code>posts.js  posts.css</code></li>
<li><code>post.js  post.css</code></li>
<li><code>about.js  about.css</code></li>
<li><code>1.js  2.js</code>（包含内嵌样式）</li>
</ul>
</li>
<li><p>所有样式都具有各自的 css 输出文件<br>利用第二种模式，只需要将 <code>allChunks</code> 选项设置成 <code>true</code> 即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"style.css"</span>, &#123;</span><br><span class="line">            allChunks: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将得到如下文件：</p>
<ul>
<li><code>posts.js  posts.css</code></li>
<li><code>post.js  post.css</code></li>
<li><code>about.js  about.css</code></li>
<li><code>1.js  2.js</code>（不包含内嵌样式）</li>
</ul>
</li>
<li><p>在 commons chunk 中的样式<br>可以结合利用 <code>CommonsChunkPlugin</code> 及分离的样式文件来为 commons chunk 生成样式文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">"commons"</span>, <span class="string">"commons.js"</span>),</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后将得到如下输出文件：</p>
<ul>
<li><code>commons.js  commons.css</code></li>
<li><code>posts.js  posts.css</code></li>
<li><code>post.js  post.css</code></li>
<li><code>about.js  about.css</code></li>
<li><code>1.js  2.js</code>（包含内嵌样式）<br>或者设置 <code>allChunks: true</code>，得到</li>
<li><code>1.js 2.js</code>（不包含内嵌样式）</li>
</ul>
<hr>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>压缩</strong><br>为了压缩文件中的 JavaScript（如果用了 css-loader，css 文件也可以），webpack 提供了一个简单的选项：<br><code>--optimize-minimize</code> 对应于：<code>new webpack.optimize.UglifyJsPlugin()</code><br>这是一个简单而有效的优化网页应用的方法。<br>你应该知道（如果你看过之前的文档）在 webpack 中是通过给 chunk 和模块赋予 id 的方式来辨别它们的。通过一个选项， webpack 可以分辨 id 的分布，并将具有较小长度的 id 分配给这些模块或者 chunk：<br><code>--optimize-occurrence-order</code> 对应于：<code>new webpack.optimize.OccurrenceOrderPlugin()</code><br>在对文件体积的影响程度上，入口 chunk 具有更高的优先级。</p>
<p><strong>去重</strong><br>如果你使用了一些拥有不错的依赖关系的库，那么在打包的过程中就可能会产生一些完全相同的文件。webpack 可以识别这些文件，然后删除重复的。在运行环境下通过利用函数替代重复代码的方式，从而避免打包文件中包含重复代码文件。这对语义化不会有什么影响。可以通过下面的方式来实现这个功能：<br><code>--optimize-dedupe</code> 对应于：<code>new webpack.optimize.DedupePlugin()</code><br>利用这种特性的时候会在入口 chunk 中引入一些额外的代码。</p>
<p><strong>Chunks</strong><br>在编写代码的时候，为了达到按需加载的目的，你可能已经设定好了一些代码分割点。但是在编译之后，你可能会发现产生了非常多的很小的 chunk，这会导致 HTTP 请求头数据量非常大。不过不用担心，通过以下两项设置，我们可以在 webpack 中利用合并的方式来处理这些 chunks：</p>
<ul>
<li>限制允许存在的 chunk 的数量（比如15个）： <code>--optimize-max-chunks 15  new webpack.optimize.LimitChunkPlugin({maxChunks: 15})</code></li>
<li>限制允许存在的 chunk 的最小体积（比如 10000）：<code>--optimize-min-chunk-size 10000 new webpack.optimize.MinChunkSizePlugin({minChunkSize: 10000})</code><br>webpack 会通过合并的方式来处理这些 chunk（会优先处理具有重复模块的 chunk）。任何 chunk 都不会被合并到入口 chunk 中，这主要是为了避免影响到初始页面加载的时间。</li>
</ul>
<p><strong>单页应用</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;单页应用是一种网页应用，webpack 的设计和优化就是为了这种应用。<br>&nbsp;&nbsp;&nbsp;&nbsp;你可能会将应用分解成很多 chunks， 这些 chunks 会在路由中加载。入口 chunk 中包含了路由和一些库，但是没有其他内容。当用户只通过导航来使用应用的时候，这种方式非常好，但是对于初始页面的加载，你需要两个完整的数据来回：一个是路由数据，一个是当前的页面数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你利用 HTML5 History API 来识别 URL 中的当前页面信息，那么服务器可以根据客户端的代码来判断被请求的页面。为了将往返数据保存起来在服务器中，你可以将内容代码包含在响应中：这可以通过增加 <code>script</code> 标签来达到。浏览器将并行加载所有的 chunks。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"entry-chunk.js"</span> type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"3.chunk.js"</span> type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可以从数据中提取 chunk 的文件名（利用 <a href="https://www.npmjs.com/package/stats-webpack-plugin" target="_blank" rel="external">stats-webpack-plugin </a>插件可以输出创建的数据）</p>
<p><strong>多页应用</strong><br>当你在编译一个（真正的）多页应用时，你会希望不能的页面能共享公用代码。实际上利用 webpack 是非常容易实现的：只需要在编译的时候提供多个入口点：<br><code>webpack p1=./page1 p2=./page2 p3=./page3 [name].entry-chunk.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].entry.chunk.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会产生多个入口 chunk：<code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> 以及 <code>p3.entry.chunk.js</code>。额外的 chunk 将会被共享。<br>如果你的入口 chunks 中有一些模块是一样的，那么可以使用一个很好的插件：<code>CommonsChunkPlugin</code>，它可以识别这些模块然后将它们生成一个 commons chunk。这时候就需要引用两个 <code>script</code> 标签了，一个用于引入 commons chunk，一个用于引入入口 chunk。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].entry.chunk.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.chunk.js"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会产生多个入口文件：<code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> 以及 <code>p3.entry.chunk.js</code>，同时还有 <code>commons.chunk.js</code>。加载的时候先加载 <code>commons.chunk.js</code> 然后再加载任一入口 chunk。<br>你可以通过选择不同的入口 chunk 来生成多个 commons chunk，而且也可以将这些 commons chunk 嵌套。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span>,</span><br><span class="line">        ap1: <span class="string">"./admin/page1"</span>,</span><br><span class="line">        ap2: <span class="string">"./admin/page2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"admin-commons.js"</span>, [<span class="string">"ap1"</span>, <span class="string">"ap2"</span>]),</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.js"</span>, [<span class="string">"p1"</span>, <span class="string">"p2"</span>, <span class="string">"admin-commons.js"</span>])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// &lt;script&gt;s required:</span></span><br><span class="line"><span class="comment">// page1.html: commons.js, p1.js</span></span><br><span class="line"><span class="comment">// page2.html: commons.js, p2.js</span></span><br><span class="line"><span class="comment">// page3.html: p3.js</span></span><br><span class="line"><span class="comment">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span></span><br><span class="line"><span class="comment">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span></span><br></pre></td></tr></table></figure></p>
<p>高级用法：可以在 commons chunk 内部运行代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        commons: <span class="string">"./entry-for-the-commons-chunk"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons"</span>, <span class="string">"commons.js"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更多阅读： <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-entry-points" target="_blank" rel="external">multiple-entry-points example</a> 以及 <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks" target="_blank" rel="external">advanced multiple-commons-chunks example</a>。</p>
<hr>
<h3 id="长期缓存"><a href="#长期缓存" class="headerlink" title="长期缓存"></a>长期缓存</h3><p>为了有效的缓存你的文件，它们应该在 URL 上有一个哈希值或者版本号。当然了，你可以手动的创建或者移动这些输出文件到一个版本号为 <code>v1.3</code> 的文件夹中。但是这么做有一些缺点：给开发者来带额外的工作，而且未更改的文件不会从缓存加载。<br>webpack 可以为文件的文件名加上哈希值。 那些能够产生输出文件的 Loaders（比如 worker-loader， file-loader）已经在这么做了。对于 chunk 而言，我们必须使它具有这种功能。有两种选择：</p>
<ul>
<li>为所有的 chunks 计算出一个哈希值并标记上</li>
<li>为每一个 chunk 计算一个哈希值并标记上</li>
</ul>
<p>下面针对这两种情况说明：</p>
<ul>
<li><p>选择一：一次打包一个哈希值<br>只需要将 <code>[hash]</code> 增加到文件名配置选项：<br><code>webpack ./entry output.[hash].bundle.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join( __dirname, <span class="string">"assets"</span>, <span class="string">"[hash]"</span>),</span><br><span class="line">        publicPath: <span class="string">"assets/[hash]"</span>,</span><br><span class="line">        filename: <span class="string">"output.[hash].bundle.js"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].[hash].bundle.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择二：每个 chunk 一个哈希值<br>只需要将 <code>[chunkhash]</code> 增加到 chunk 文件名配置选项中：<br><code>--output-chunk-file [chunkhash].js</code><br><code>output: { chunkFilename: &quot;[chunkhash].bundle.js&quot; }</code><br>需要注意的是，在 HTML 文件中引用入口 chunk 的时候也需要带有哈希值。你应该会希望从数据中直接提取哈希值或者是文件名。如果你结合使用 <code>Hot Code Replacement</code>，你就只能使用第一种方式，并且不包括 <code>publicPath</code> 配置选项。</p>
</li>
<li><p>从数据中获取文件名<br>你可能会想获取文件的最终文件名用于插入到 HTML 文件中。通过 webpack 这是可以做到的。如果你在使用 <code>CLI</code>，你可以在运行它的时候加上 <code>--json</code>，从而会输出标准的 JSON 文件。<br>你也可以通过在配置表中增加一个插件，比如 <a href="https://www.npmjs.com/package/assets-webpack-plugin" target="_blank" rel="external"> assets-webpack-plugin</a> 来访问数据对象。下面是将具体的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.plugin(<span class="string">"done"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">stats</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">"fs"</span>).writeFileSync(</span><br><span class="line">        path.join(__dirname, <span class="string">".."</span>, <span class="string">"stats.json"</span>),</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(stats.toJson()));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这个 JSON 数据包含了一个非常有用的特性：<code>assetsByChunkName</code>， 这是一个对象，这个对像里面的键为 chunk 的名字，键值为文件的名字。</p>
<blockquote>
<p>注意：如果每个 chunk 生成的是多个文件，比如一个 JavaScript 文件 一个 SourceMap， 那么这个特性就是个数组。数组中的第一个对应于 JavaScript。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="编写-loader"><a href="#编写-loader" class="headerlink" title="编写 loader"></a>编写 loader</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Loader 就是输出一个函数的 node 模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;当有资源需要被这个 loader 转化的时候，这个函数就会被调用了。<br>&nbsp;&nbsp;&nbsp;&nbsp;在简单的例子中，当只有一个 loader 作用在待处理资源上的时候，调用 loader 时就只有一个参数：字符串形式的资源文件的内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;loader 可以通过在函数中的 this 格式来访问 <a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="external">loader API</a>。<br>&nbsp;&nbsp;&nbsp;&nbsp;一个同步的 loader 如果只想得到一个数值，那么直接用 return 返回就行了。除此之外，loader 可以通过 <code>this.callback(err. values...)</code> 函数来返回任意多的数值。错误会被传入到 <code>this.callback</code> 函数中或者被传入到同步的 loader 中。<br>&nbsp;&nbsp;&nbsp;&nbsp;一般来说我们都希望 loader 能够返回一到两个数据。第一个是缓存或者字符串形式的 JavaScript 代码，第二个数据是 JavaScript 对象格式的 SourceMap。<br>&nbsp;&nbsp;&nbsp;&nbsp;在比较附在的情况下，会组合使用到多个 loader，这时候只有最后的 loader 能够接触到源文件，同时也只有最开始的 loader 能够返回一到两个数据（JavaScript 代码及 SourceMap）（注：因为链式调用的时候是从右到左调用的）。其他的 loader 返回的数据都是传入到前一个 loader 中。</p>
<p><strong>例子</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Identity loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Identity loader with SourceMap support</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, source, map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong><br>    loaders 应该（按照优先级排序，第一个应该享有最高的优先级）</p>
<ul>
<li>只完成单一任务<br>  loaders 是可以链式调用的，应该每一步都使用一个 loader 而不是让一个 loader 完成所有的事情。<br>  这也意味着如果不是必须的话就不应该转化成 JavaScript。<br>  例如：通过应用查询参数的方式从模板中渲染出 HTML：<br>  我们可以写一个 loader， 它可以从原文件中编译模板，然后执行它并返回一个能够输出带有 HTML 代码的字符串的模块。但这种做法不推荐。<br>  我们应该为每一个任务写一个 loader，然后链式调用它们：<ul>
<li>jade-loader：将模板转化成一个能返回函数的模块</li>
<li>apply-loader：接收一个函数并通过应用查询参数返回原生结果</li>
<li>html-loader： 接收 HTML 并且输出字符串</li>
</ul>
</li>
</ul>
<ul>
<li><p>生成的模块应该是模块化的<br>  通过 loader 生产的模块应该遵循和普通模块一样的设计原则。<br>  例如：这是一个不好的设计：（没有模块化，全局声明……）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"any-template-language-loader!./xyz.atl"</span>);</span><br><span class="line"><span class="keyword">var</span> html = anyTemplateLanguage.render(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量标明是可缓存的<br>  大部分的 loader 都是可缓存的，所以它们应该也标明是可缓存的。<br>  只需要在 loader 中调用 <code>cacheable</code>：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cacheable identity loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注明依赖<br>  如果 loader 需要利用外部资源（比如需要读取文档系统），那么就 <strong>必须</strong> 要注明。这个信息可以用来使可缓存的 loader 无效，也会使得在监控模式下重编译。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loader adding a header</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    <span class="keyword">var</span> headerPath = path.resolve(<span class="string">"header.js"</span>);</span><br><span class="line">    <span class="keyword">this</span>.addDependency(headerPath);</span><br><span class="line">    fs.readFile(headerPath, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, header</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> callback(err);</span><br><span class="line">        callback(<span class="literal">null</span>, header + <span class="string">"\n"</span> + source);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分解依赖<br>  在很多语言中都有规范依赖的方法，比如在 css 中有 <code>@import</code> 以及 <code>url(...)</code> 的方式。模块系统应该能够分解这些依赖。<br>  有两种选择可达到这种目的：</p>
<ul>
<li>将它们转化成 <code>require</code></li>
<li>利用 <code>this.resolve()</code> 函数来分解路径<br>举例一：css-loader。 css-loader 将依赖转化成 <code>require</code>，具体方式是利用 <code>require</code> 样式（也会被 css-loader 处理）来替代 <code>@import</code>，同时也利用 <code>require</code> 相关文件来替代 <code>url(...)</code> 引用。<br>如果这个语言只接受相对路径（比如在 css 中： <code>url(file)</code> 一般表示 <code>./file</code>），那么就可以通过 <code>~</code> 符号来将特定的引用传送给模块，如下所示：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(file) -&gt; <span class="built_in">require</span>(<span class="string">"./file"</span>)</span><br><span class="line">url(~<span class="built_in">module</span>) -&gt; <span class="built_in">require</span>(<span class="string">"module"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>提取公用代码<br>  不要在利用同一个 loader 处理的每个模块中提取太多公用代码。在 loader 中创建一个（运行环境下的）文件，并利用一个 <code>require</code> 来引用公用代码。</p>
</li>
<li><p>不要内嵌绝对路径<br>  不要将绝对路径写入到模块代码中，因为如果项目移动位置的话会破坏路径的哈希值。在<a href="https://github.com/webpack/loader-utils#stringifyrequest" target="_blank" rel="external">loader-utils</a> 中有一个 <code>stringifyRequest</code> 方法，可以将绝对路径转化为相对路径。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">"loader-utils"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"var runtime = require("</span> +</span><br><span class="line">loaderUtils.stringifyRequest(<span class="keyword">this</span>, <span class="string">"!"</span> + <span class="built_in">require</span>.resolve(<span class="string">"module/runtime"</span>)) +</span><br><span class="line"><span class="string">");"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用库作为 <code>peerDependencies</code><br>  当使用库作为同级依赖的时候，如果需要，应用的开发者可以在配置文件 <code>package.json</code> 中明确的指出所依赖库的版本。这种依赖应该在不需要重新发布新版本号的 loader 的情况下能升级。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"peerDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"libraay"</span>: <span class="string">"^1.3.5"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多关于 <a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="external">loaders</a>.</p>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;webpack 文档也看了好几天了，上面翻译的也只是其中一部分内容，看到后面有点不知所云，翻译起来很吃力，有种以其昏昏使人昭昭的感觉。为了不误人子弟，所以决定暂时不再翻译，日后有了更多的理解了再来继续。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果在阅读的过程中发现翻译不妥，欢迎在下方留言或者给我发邮件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前端工程化已成为趋势，善于使用各种工具无疑能极大的提高工作效率，所以这段时间将陆续会有几篇关于这些工具的介绍文章，文章的内容大多是关于这些工具的文档的翻译。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文所有资料来源都是 webpack 官网，有意看原文的戳链接： &lt;a href=&quot;http://webpack.github.io/docs/.html&quot;&gt;webpack document&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Webpack" scheme="http://detachment.club/tags/Webpack/"/>
    
      <category term="工具" scheme="http://detachment.club/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>前端面试常见问题整理</title>
    <link href="http://detachment.club/2016/08/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://detachment.club/2016/08/31/前端面试常见问题整理/</id>
    <published>2016-08-30T16:00:00.000Z</published>
    <updated>2016-09-06T10:11:52.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从开始学习前端到现在已经五个月了，在时间上已经到了该找工作的阶段了，但从目前对前端技能的掌握的层面来说，还离社招的水平有较大一段距离。现实和计划之间永远存在在差距。现在也已经开始投简历了，为了有更好的面试状态同时也检验一下前阶段对知识的掌握程度，特地在网上收集了一些面试资料来借鉴参考。</p>
<a id="more"></a>
<p>注明：</p>
<blockquote>
<p>本文里面的绝大部分问题来自github上<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="external">markyun同学的项目</a>，感谢所有为此付出努力的同学们~<br>对于原文中收集的有些问题我看了答案还是不能很理解，或者是有些没有答案的问题，我都做了一些收集并将链接附在了文中，也对这些热爱分享的同学表示感谢~</p>
</blockquote>
<h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h3 id="DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？"><a href="#DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？" class="headerlink" title="DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？"></a>DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？</h3><blockquote>
<p> &lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 <html> 标签之前；它不是 HTML 标签；而是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。其中DTD指的是：document type definition; SGML指的是 Standard Generalized Markup Language;</html></p>
<p><a href="https://www.zhihu.com/question/20249139" target="_blank" rel="external">然后，为什么HTML5不再基于SGML？</a></p>
<p>标准模式及兼容模式：标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p>
</blockquote>
<h3 id="行内元素有哪些？块级元素有哪些？空元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？空元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？空元素有哪些？"></a>行内元素有哪些？块级元素有哪些？空元素有哪些？</h3><blockquote>
<p>行内元素：a b span img input select strong；<br>块级元素有：div ul ol li dl dt dd h1 p;<br>常见的空元素：br hr img input link meta;</p>
</blockquote>
<h3 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h3><blockquote>
<p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;<br>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p>
<p><a href="http://www.daqianduan.com/2417.html" target="_blank" rel="external">更详细的区别戳我~</a></p>
</blockquote>
<h3 id="常见的浏览器内核有几种？"><a href="#常见的浏览器内核有几种？" class="headerlink" title="常见的浏览器内核有几种？"></a>常见的浏览器内核有几种？</h3><blockquote>
<p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p>
<p>补充：浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<p><a href="http://web.jobbole.com/84826/" target="_blank" rel="external">想了解浏览器内核历史的，戳我~</a></p>
</blockquote>
<h3 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><blockquote>
<p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>      绘画 canvas;<br>      用于媒介回放的 video 和 audio 元素;<br>      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;<br>      sessionStorage 的数据在浏览器关闭后自动删除;<br>      语意化更好的内容元素，比如 article、footer、header、nav、section;<br>      表单控件，calendar、date、time、email、url、search;<br>      新的技术webworker, websocket, Geolocation;</p>
<p> 移除的元素：<br>      纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>      对可用性产生负面影响的元素：frame，frameset，noframes；</p>
<p>支持HTML5新标签：<br>     IE8/IE7/IE6支持通过document.createElement方法产生的标签，<br>     可以利用这一特性让这些浏览器支持HTML5新标签，<br>     浏览器支持新标签后，还需要添加标签默认的样式。</p>
<p> 当然也可以直接使用成熟的框架、比如html5shim;<br>   <code>&lt;script&gt;src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</code></p>
<p>如何区分HTML5： DOCTYPE声明或新增的结构元素或功能元素；</p>
</blockquote>
<h3 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h3><blockquote>
<p>总结起来为：用正确的标签做正确的事情。</p>
<ol>
<li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li>
<li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li>
<li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
</ol>
</blockquote>
<h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><blockquote>
<p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<ul>
<li>存储大小：<br>  cookie数据大小不能超过4k。<br>  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
<li>有期时间：<br>  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>  sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
<p><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="external">更多关于Cooikes信息，戳我~</a></p>
</blockquote>
<h3 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h3><blockquote>
<ul>
<li>iframe会阻塞主页面的Onload事件；</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO;</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
<li>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</li>
</ul>
<p><a href="https://www.zhihu.com/question/20653055" target="_blank" rel="external">想看使用iframe的好处的，戳我~</a></p>
</blockquote>
<h3 id="Label的作用是什么？是怎么用的？"><a href="#Label的作用是什么？是怎么用的？" class="headerlink" title="Label的作用是什么？是怎么用的？"></a>Label的作用是什么？是怎么用的？</h3><blockquote>
<p>label 元素不会向用户呈现任何特殊的样式。不过，它为鼠标用户改善了可用性，因为如果用户点击 label 元素内的文本，则会切换到控件本身。label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。<br><strong>本题考察的是HTML5新标签的用法，可推广到所有其他标签的常规使用，应举一反三。</strong></p>
</blockquote>
<h3 id="页面可见性（Page-Visibility-API）可以有什么用途？"><a href="#页面可见性（Page-Visibility-API）可以有什么用途？" class="headerlink" title="页面可见性（Page Visibility API）可以有什么用途？"></a>页面可见性（Page Visibility API）可以有什么用途？</h3><blockquote>
<p>可通过检测visibilityState的值检测页面是否可见，以及打开网页的时间等；<br>在页面被切换到后台进程的时候，自动暂停音乐或者视频的播放；</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="external">想了解更多信息，戳我~</a></p>
</blockquote>
<h3 id="如何在页面实现一个圆形的可点击区域？"><a href="#如何在页面实现一个圆形的可点击区域？" class="headerlink" title="如何在页面实现一个圆形的可点击区域？"></a>如何在页面实现一个圆形的可点击区域？</h3><blockquote>
<ol>
<li>map+area或者svg <a href="http://www.w3school.com.cn/tags/att_area_coords.asp" target="_blank" rel="external">具体实现方式，戳我~</a></li>
<li>border-radius</li>
<li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等；</li>
</ol>
</blockquote>
<h3 id="网页验证码是干嘛的？是为了解决什么安全问题？"><a href="#网页验证码是干嘛的？是为了解决什么安全问题？" class="headerlink" title="网页验证码是干嘛的？是为了解决什么安全问题？"></a>网页验证码是干嘛的？是为了解决什么安全问题？</h3><blockquote>
<p>是为了区分用户是计算机还是人类的公共自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>也可以有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p>
<p><a href="https://www.zhihu.com/question/19563610" target="_blank" rel="external">据说谷歌还利用验证码来完成古籍文字的识别，戳我~</a></p>
</blockquote>
<h3 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h3><blockquote>
<ul>
<li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li>
<li>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时strong会重读，而B是展示强调内容。</li>
<li>i内容展示为斜体，em表示强调的文本；</li>
<li>Physical Style Elements – 自然样式标签<br>  b, i, u, s, pre</li>
<li>Semantic Style Elements – 语义样式标签<br> strong, em, ins, del, code<br>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</li>
</ul>
</blockquote>
<hr>
<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><blockquote>
<p>（1）有两种， IE 盒子模型、W3C 盒子模型；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的content部分把 border 和 padding计算了进去;<br>(其实更准确的说法应该是本来width值指的是内容区域，而在IE5，6版本中，width值包括padding和border。content部分一直都是content部分。)</p>
<p><a href="http://www.w3school.com.cn/css/css_boxmodel.asp" target="_blank" rel="external">想知道详细内容？戳我~</a></p>
</blockquote>
<h3 id="CSS选择符有哪些？哪些属性可以继承？"><a href="#CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择符有哪些？哪些属性可以继承？"></a>CSS选择符有哪些？哪些属性可以继承？</h3><blockquote>
<ol>
<li>id选择器（ # myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div, h1, p）</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（ * ）</li>
<li>属性选择器（a[rel = “external”]）</li>
<li>伪类（a:hover, li:nth-child）</li>
<li>伪元素(:before, :after, :first-line, first-letter)</li>
</ol>
<ul>
<li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li>
<li>不可继承的样式：border padding margin width height ;</li>
</ul>
<p><a href="http://www.cnblogs.com/rubylouvre/archive/2009/09/04/1559557.html" target="_blank" rel="external">想知道更全面的可继承与不可继承属性？戳我~</a></p>
</blockquote>
<h3 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h3><blockquote>
<p>优先级就近原则，同权重情况下样式定义最近者为准;<br>载入样式以最后载入的定位为准;<br>优先级为：!important &gt;  id &gt; class &gt; tag  其中important比内联样式优先级高。</p>
</blockquote>
<h3 id="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h3><blockquote>
<p>由于本问题涉及较多代码，希望知道详细解释的，<a href="http://www.w3cplus.com/css/elements-horizontally-center-with-css.html" target="_blank" rel="external">直接戳我就好了~</a></p>
</blockquote>
<h3 id="display有哪些值？他们的作用分别是？"><a href="#display有哪些值？他们的作用分别是？" class="headerlink" title="display有哪些值？他们的作用分别是？"></a>display有哪些值？他们的作用分别是？</h3><blockquote>
<p>block         象块类型元素一样显示。<br>  none          缺省值。象行内元素类型一样显示。<br>  inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。<br>  list-item     象块类型元素一样显示，并添加样式列表标记。<br>  table         此元素会作为块级表格来显示<br>  inherit       规定应该从父元素继承 display 属性的值</p>
<p><a href="http://www.w3school.com.cn/cssref/pr_class_display.asp" target="_blank" rel="external">更多详细内容，戳我~</a></p>
</blockquote>
<h3 id="CSS3中有哪些新特征？"><a href="#CSS3中有哪些新特征？" class="headerlink" title="CSS3中有哪些新特征？"></a>CSS3中有哪些新特征？</h3><blockquote>
<p>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）<br>  圆角           （border-radius:8px）<br>  多列布局        （multi-column layout）<br>  阴影和反射        （Shadow, Reflect）<br>  文字特效      （text-shadow、）<br>  文字渲染      （Text-decoration）<br>  线性渐变      （gradient）<br>  旋转          （transform）<br>  增加了旋转,缩放,定位,倾斜,动画，多背景<br>  transform:scale(0.85,0.90), translate(0px,-30px), skew(-9deg,0deg), Animation:</p>
<p><a href="http://www.w3school.com.cn/css3/css3_border.asp" target="_blank" rel="external">个人认为上面的分类不够系统，戳我了解更多~</a></p>
</blockquote>
<h3 id="用纯CSS创建一个三角形的原理是什么？"><a href="#用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="用纯CSS创建一个三角形的原理是什么？"></a>用纯CSS创建一个三角形的原理是什么？</h3><blockquote>
<p>原理很简单，就是将一个div的宽高设置成0，然后根据不同的需求设置div的border属性，从而能够得到各种三角形。</p>
<p><a href="http://www.zhangxinxu.com/wordpress/2010/05/css-border%E4%B8%89%E8%A7%92%E3%80%81%E5%9C%86%E8%A7%92%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">更详细的说明，戳我~</a></p>
</blockquote>
<h3 id="解释一下CSS3中Flex-box以及使用场景？"><a href="#解释一下CSS3中Flex-box以及使用场景？" class="headerlink" title="解释一下CSS3中Flex-box以及使用场景？"></a>解释一下CSS3中Flex-box以及使用场景？</h3><blockquote>
<p>box-flex 属性规定框的子元素是否可伸缩其尺寸。可伸缩元素能够随着框的缩小或扩大而缩写或放大。只要框中有多余的空间，可伸缩元素就会扩展来填充这些空间。目前浏览器使用这个属性时都需要加前缀，比如Firefox 支持替代的 -moz-box-flex 属性，Safari、Opera 以及 Chrome 支持替代的 -webkit-box-flex 属性。</p>
<p><a href="http://www.w3school.com.cn/cssref/pr_box-flex.asp" target="_blank" rel="external">更多详细内容，戳我~</a></p>
</blockquote>
<h3 id="常见的浏览器兼容性问题有哪些？原因及解决方法是什么？"><a href="#常见的浏览器兼容性问题有哪些？原因及解决方法是什么？" class="headerlink" title="常见的浏览器兼容性问题有哪些？原因及解决方法是什么？"></a>常见的浏览器兼容性问题有哪些？原因及解决方法是什么？</h3><blockquote>
<p><a href="http://www.cnblogs.com/jscode/archive/2012/07/10/2583856.html" target="_blank" rel="external">问题范围太大了，想详细了解的戳我~</a><br><br><a href="https://www.zhihu.com/question/28954391" target="_blank" rel="external">然后，戳我了解更多~</a></p>
</blockquote>
<h3 id="为什么要初始化CSS样式？"><a href="#为什么要初始化CSS样式？" class="headerlink" title="为什么要初始化CSS样式？"></a>为什么要初始化CSS样式？</h3><blockquote>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
<p><a href="http://www.cnblogs.com/xiangzi888/archive/2011/09/21/2184442.html" target="_blank" rel="external">各大厂详细的初始化方案，戳我~</a></p>
</blockquote>
<h3 id="在CSS中position，display和float有什么关系？"><a href="#在CSS中position，display和float有什么关系？" class="headerlink" title="在CSS中position，display和float有什么关系？"></a>在CSS中position，display和float有什么关系？</h3><blockquote>
<p><a href="http://www.w3cfuns.com/notes/16548/6c7c4a0e6fe54320bfeb26fdc1e08ca1.html" target="_blank" rel="external">由于这个问题比较复杂，他们之间的详细的关系可以戳我~</a><br><a href="https://www.zhihu.com/question/19588854" target="_blank" rel="external">或者戳我~</a><br><a href="http://detachment.club/2016/06/27/Float,%20position%20and%20display%20in%20CSS/">还有我~</a></p>
</blockquote>
<h3 id="CSS声明的权重是怎样的？"><a href="#CSS声明的权重是怎样的？" class="headerlink" title="CSS声明的权重是怎样的？"></a>CSS声明的权重是怎样的？</h3><blockquote>
<p>CSS声明的权重指的是优先级，由选择器中的每一种选择器类型的数值决定，当数值相等时，css中最后的那个声明将作用到元素上。权重数值如下：<br>0 . 元素(类型)选择器（type selectors）（例如：h1）和 伪元素选择器（pseudo-elements）（例如：:before）<br>1 . 类选择器（class selectors） (例如：.example)，属性选择器（attributes selectors）（例如：[type=”radio”]），伪类选择器（pseudo-classes）（例如：:hover）<br>2 . ID选择器（例如：#example）<br>通用选择器（universal selector）(*),组合符合（combinators） (+, &gt;, ~, ‘ ‘)  和 否定伪类（negation pseudo-class）(:not()) 不会影响优先级（但是，在 :not() 内部声明的选择器是会影响优先级的）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="external">详细信息戳我~</a></p>
</blockquote>
<h3 id="清除浮动有几种方式？优缺点有哪些？"><a href="#清除浮动有几种方式？优缺点有哪些？" class="headerlink" title="清除浮动有几种方式？优缺点有哪些？"></a>清除浮动有几种方式？优缺点有哪些？</h3><blockquote>
<ol>
<li>最后增加一个清除浮动的子元素,缺点是会增加一个DOM节点;</li>
<li>同样可以在最后增加一个清除浮动的br,语义上比空的div标签稍微好一点，但同样会增加一个DOM节点;</li>
<li>父元素设置 overflow:hidden（如果你还要兼顾IE6的话，加上*zoom:1;来触发hasLayout）;</li>
<li>将父元素设置 的overflow:hidden改成auto;</li>
<li>父元素也设成float;</li>
<li>父元素设置display:table;</li>
<li>用:after伪元素，思路是用:after元素在div后面插入一个隐藏文本”.”，隐藏文本用clear来实现闭合浮动：</li>
</ol>
<p><a href="http://www.jianshu.com/p/07eb19957991#" target="_blank" rel="external">原文链接，戳我~</a></p>
</blockquote>
<h3 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h3><blockquote>
<p>总的来说，浏览器是遵循从右到左的顺序来解析CSS选择器的，这样解析的效率最高。<br><br><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="external">想知道详细解释的，戳我</a><br><br><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="external">然后也可以戳我~</a></p>
</blockquote>
<h3 id="CSS优化、提高性能的方法有哪些？"><a href="#CSS优化、提高性能的方法有哪些？" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h3><blockquote>
<p><a href="http://www.zhihu.com/question/19886806" target="_blank" rel="external">问题比较笼统，较详细的解释可戳我~</a></p>
</blockquote>
<h3 id="在网页中较多的使用奇数号字体还是偶数号字体？为什么？"><a href="#在网页中较多的使用奇数号字体还是偶数号字体？为什么？" class="headerlink" title="在网页中较多的使用奇数号字体还是偶数号字体？为什么？"></a>在网页中较多的使用奇数号字体还是偶数号字体？为什么？</h3><blockquote>
<p>首先答案是较多的使用偶数号字体，具体原因点下面的链接。</p>
<p><a href="https://www.zhihu.com/question/20440679" target="_blank" rel="external">为什么网页多使用偶数号字体？</a></p>
</blockquote>
<h3 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h3><blockquote>
<p>如果是定位元素，则相对的是容器的高度；而如果是内外边距，那么相对的则是容器的宽度。</p>
</blockquote>
<h3 id="从输入URL到页面加载完成的过程中都发生了什么事情？"><a href="#从输入URL到页面加载完成的过程中都发生了什么事情？" class="headerlink" title="从输入URL到页面加载完成的过程中都发生了什么事情？"></a>从输入URL到页面加载完成的过程中都发生了什么事情？</h3><blockquote>
<p><a href="http://yuehu.io/padding-me/406" target="_blank" rel="external">这篇文章写得非常详细，戳我阅读~</a></p>
</blockquote>
<h3 id="如何修改chrome记住密码后自动填充表单的黄色背景-？"><a href="#如何修改chrome记住密码后自动填充表单的黄色背景-？" class="headerlink" title="如何修改chrome记住密码后自动填充表单的黄色背景 ？"></a>如何修改chrome记住密码后自动填充表单的黄色背景 ？</h3><blockquote>
<p><em>我觉着这种问题不是太适合面试，没有尝试过的同学估计很难知道具体的修改方式</em></p>
<p><a href="http://zcoder.cn/2015/01/14/front-end/chrome-autofill/" target="_blank" rel="external">想了解具体的修改方式，戳我~</a></p>
</blockquote>
<h3 id="什么是CSS-预处理器-后处理器？"><a href="#什么是CSS-预处理器-后处理器？" class="headerlink" title="什么是CSS 预处理器/后处理器？"></a>什么是CSS 预处理器/后处理器？</h3><blockquote>
<p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，<br>  还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。<br>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
</blockquote>
<hr>
<h2 id="JavaScript-部分"><a href="#JavaScript-部分" class="headerlink" title="JavaScript 部分"></a>JavaScript 部分</h2><h3 id="介绍JS中的基本数据类型。"><a href="#介绍JS中的基本数据类型。" class="headerlink" title="介绍JS中的基本数据类型。"></a>介绍JS中的基本数据类型。</h3><blockquote>
<p>一般来说分为两种，分别为基本类型和对象类型，其中基本类型包括undefined, null, Boolean, Number, String, Symbol，对象类型即为Object。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">MDN中关于JS基本数据类型的介绍~</a><br><a href="http://www.cnblogs.com/snandy/archive/2013/01/02/2841899.html" target="_blank" rel="external">JS中基本类型之争</a></p>
</blockquote>
<h3 id="JS中有哪些内置对象？"><a href="#JS中有哪些内置对象？" class="headerlink" title="JS中有哪些内置对象？"></a>JS中有哪些内置对象？</h3><blockquote>
<p>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：Object、Array、Boolean、Number 和 String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="external">JS中的标准全局对象</a></p>
</blockquote>
<h3 id="说几条JS的基本规范"><a href="#说几条JS的基本规范" class="headerlink" title="说几条JS的基本规范"></a>说几条JS的基本规范</h3><blockquote>
<p>1.不要在同一行声明多个变量。<br>2.请使用 ===/!==来比较true/false或者数值<br>3.使用对象字面量替代new Array这种形式<br>4.不要使用全局函数。<br>5.Switch语句必须带有default分支<br>6.函数不应该有时候有返回值，有时候没有返回值。<br>7.For循环必须使用大括号<br>8.If语句必须使用大括号<br>9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>
<p><a href="https://github.com/lxj/javascript.patterns/blob/master/chapter2.markdown" target="_blank" rel="external">需要知道更多的要点？ 戳我~</a></p>
</blockquote>
<h3 id="简单解释下JS中的原型及原型链，有什么特点？"><a href="#简单解释下JS中的原型及原型链，有什么特点？" class="headerlink" title="简单解释下JS中的原型及原型链，有什么特点？"></a>简单解释下JS中的原型及原型链，有什么特点？</h3><blockquote>
<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">MDN上关于JS中继承及原型链的解释</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html" target="_blank" rel="external">强大的原型及原型链</a></p>
</blockquote>
<h3 id="JS中有几种类型的值？它们之间的区别时是什么？"><a href="#JS中有几种类型的值？它们之间的区别时是什么？" class="headerlink" title="JS中有几种类型的值？它们之间的区别时是什么？"></a>JS中有几种类型的值？它们之间的区别时是什么？</h3><blockquote>
<p>主要有两种，分别为栈和堆；<br>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（对象、数组和函数）</p>
<p>两种类型的区别是：存储位置不同；<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
</blockquote>
<h3 id="常见的内存泄露的方式有？如何避免？"><a href="#常见的内存泄露的方式有？如何避免？" class="headerlink" title="常见的内存泄露的方式有？如何避免？"></a>常见的内存泄露的方式有？如何避免？</h3><blockquote>
<p>主要有以下几种方式：</p>
<ol>
<li>意外的全局变量</li>
<li>被遗忘的计时器或回调函数</li>
<li>脱离 DOM 的引用</li>
<li>闭包</li>
</ol>
<p><a href="http://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="external">关于这个问题的答案，具体解释戳我~</a><br><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="external">英文原文链接</a></p>
</blockquote>
<h3 id="JS中怎么实现继承？"><a href="#JS中怎么实现继承？" class="headerlink" title="JS中怎么实现继承？"></a>JS中怎么实现继承？</h3><blockquote>
<p>主要有以下几种：<br>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">详细内容戳我~</a></p>
</blockquote>
<h3 id="JS中创建对象有几种方式？"><a href="#JS中创建对象有几种方式？" class="headerlink" title="JS中创建对象有几种方式？"></a>JS中创建对象有几种方式？</h3><blockquote>
<p>常见的创建对象的方式有：</p>
<ol>
<li>直接创建对象；</li>
<li>用构造函数；</li>
<li>用工厂方式；</li>
<li>用原型方式；</li>
<li>用混合方式；</li>
</ol>
<p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="external">原文链接，戳我直达~</a><br><a href="http://www.yuanlairc.com/program/jsobject.html" target="_blank" rel="external">javascript创建对象的几种模式</a></p>
</blockquote>
<h3 id="谈谈对在JS中This的理解"><a href="#谈谈对在JS中This的理解" class="headerlink" title="谈谈对在JS中This的理解"></a>谈谈对在JS中This的理解</h3><blockquote>
<ul>
<li>this总是指向函数的直接调用者（而非间接调用者）；</li>
<li>如果有new关键字，this指向new出来的那个对象；</li>
<li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">Javascript中this的用法 by 阮一峰</a></p>
</blockquote>
<h3 id="null和undefined有什么区别？"><a href="#null和undefined有什么区别？" class="headerlink" title="null和undefined有什么区别？"></a>null和undefined有什么区别？</h3><blockquote>
<p>null最常见的用法表示一个对象被定义了，但值为空值；<br>undefined最常用的用法表示一个对象未被定义或者需要访问的对象的属性不存在；</p>
<p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#core.undefined" target="_blank" rel="external">undefined和null——《秘密花园》</a><br><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">undefined和null的区别，阮一峰</a></p>
</blockquote>
<h3 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><blockquote>
<p>答案是[1, NaN, NaN]。<br>map方法中的回调函数可以有三个参数来声明，第一个为数组元素的值，第二个为数组元素的数字索引，但三个为包含该元素的数组对象。<br>在这个例子中，回调函数为parseInt，传入参数为待解析字符串及进制数，其中进制数为可选参数。<br>然后在这个，parseInt函数正好将数组元素的数字索引当做进制数来进行运算，所以最终的结果如上所说。</p>
<p><a href="https://segmentfault.com/a/1190000005956935" target="_blank" rel="external">想知道更详细的解释？戳我~</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从开始学习前端到现在已经五个月了，在时间上已经到了该找工作的阶段了，但从目前对前端技能的掌握的层面来说，还离社招的水平有较大一段距离。现实和计划之间永远存在在差距。现在也已经开始投简历了，为了有更好的面试状态同时也检验一下前阶段对知识的掌握程度，特地在网上收集了一些面试资料来借鉴参考。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="http://detachment.club/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《Bootstrap 初体验》</title>
    <link href="http://detachment.club/2016/08/09/Bootstrap%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://detachment.club/2016/08/09/Bootstrap初体验/</id>
    <published>2016-08-08T16:00:00.000Z</published>
    <updated>2016-08-10T07:00:05.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;了解了jQuery的基本语法之后，就开始准备学习Bootstrap框架了。在慕课网上看过姜维老师讲述的<a href="http://www.imooc.com/learn/182" target="_blank" rel="external">《基于bootstrap的网页开发》</a>后，真正被Bootstrap的强大功能惊艳到。随后又在网易云课堂接触到李炎恢老师是<a href="http://study.163.com/course/courseMain.htm?courseId=1017002" target="_blank" rel="external">《Bootstrap视频教程》</a>，再一次被惊艳。在用一通宵的时间看完李老师的基础教程后，跃跃欲试，然后决定跟着老师的步骤做一个自己的网页。</p>
<a id="more"></a>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;虽说是准备跟着老师做，但也不想完全照搬老师的内容，这时候一转头，正好看到电脑屏幕上电影《Detachment》的截图，瞬间就决定了以此为主题制作网页。<br>&nbsp;&nbsp;&nbsp;&nbsp;由于整体框架和老师是完全一样的，所以制作的过程还算是比较顺利。整个网页大概花费了两天时间，其中有很大一部分时间花在找材料上，而且为了使网页实际体验效果比较好，在需要加链接的地方都尽量贴上了链接。做完以后面临的一个问题就是怎么展示这些网页，自己看的话在本地当然没有问题，但是如果要和别人分享的话，最好还是放在网上。为了达到这个目的，尝试了三个方法：</p>
<ol>
<li>购买域名，部署网站；工作量较大，涉及到前后端的知识，稍微尝试了一下后放弃此方案；</li>
<li>结合博客展示；在博客中新建了一个页面展示，但是文件格式是<code>.md</code>的，而且展示的时候博客的固定框架仍在，影响美观，随放弃；</li>
<li>利用在线编辑器Codepen；只需将其中一个页面布置到codepen中，另外的几个页面通过外链（七牛云）的方式链接到主页面即可，方法可行且十分方便，以后都可以类似处理；</li>
</ol>
<p>最终的效果如下图： <img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut1.JPG" alt=""><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut2.JPG" alt=""><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut3.JPG" alt=""><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut4.JPG" alt=""><br>（想看完整版的可从博客左侧的“关于”栏获取链接）。</p>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这个页面是第一次完整的制作页面，当看到整体呈现在面前的时候，还是有点小激动的。感觉特别冲击的是，居然可以几乎不手写js代码就能做出这样的效果！和对照网站的功能及视觉效果来说，比较突出的两点不足是：</p>
<ol>
<li>首页轮播图和背景并没有十分契合；</li>
<li>首页的整体色调不是很完美；</li>
<li>最后一个页面的滚动监听功能没有实现，虽然重新看了几遍教程也看过了中文文档，但还是没有找出问题出在哪里，暂时搁置，待对bootsrap的功能了解更全面后再来找出问题所在。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;虽然这个页面已经做完了，但自知整体布局都是老师已经选好的，并没有什么难度。这只是一个开始而已，路还很长，加油。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解了jQuery的基本语法之后，就开始准备学习Bootstrap框架了。在慕课网上看过姜维老师讲述的&lt;a href=&quot;http://www.imooc.com/learn/182&quot;&gt;《基于bootstrap的网页开发》&lt;/a&gt;后，真正被Bootstrap的强大功能惊艳到。随后又在网易云课堂接触到李炎恢老师是&lt;a href=&quot;http://study.163.com/course/courseMain.htm?courseId=1017002&quot;&gt;《Bootstrap视频教程》&lt;/a&gt;，再一次被惊艳。在用一通宵的时间看完李老师的基础教程后，跃跃欲试，然后决定跟着老师的步骤做一个自己的网页。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Bootstrap" scheme="http://detachment.club/tags/Bootstrap/"/>
    
      <category term="框架" scheme="http://detachment.club/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>《jQuery学习教程》</title>
    <link href="http://detachment.club/2016/07/31/jQuery%20%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"/>
    <id>http://detachment.club/2016/07/31/jQuery 学习教程/</id>
    <published>2016-07-30T16:00:00.000Z</published>
    <updated>2016-08-07T15:14:05.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;网上学习JS的过程告一段落，然后就马不停蹄的开始找JS框架和库的教程（感觉知乎上很多学习课程都是不负责任推荐，有点怀疑他们本身有没有看过那些推荐的教程。当然了，也可能是那些课程仅仅是不适合我。），找了一圈下来（网易云课堂、慕课网、极客学院、codecademy、free code camp等）没有发现适合的，要么讲的太简单了，要么信息量太大了。这时候，终于想起了w3school。以下的学习内容大部分都是基于这上面的，需要更详细的内容可以上<a href="http://www.w3school.com.cn/jquery" target="_blank" rel="external">w3school</a>查看。</p>
<a id="more"></a>
<h2 id="课程章节"><a href="#课程章节" class="headerlink" title="课程章节"></a>课程章节</h2><h3 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h3><h4 id="关键词：简介、安装、语法、选择器、事件、名称冲突"><a href="#关键词：简介、安装、语法、选择器、事件、名称冲突" class="headerlink" title="关键词：简介、安装、语法、选择器、事件、名称冲突"></a>关键词：简介、安装、语法、选择器、事件、名称冲突</h4><ul>
<li><strong>简介</strong>：jQuery是一个轻量级的JavaScript库，能极大的简化JavaScript编程，宗旨是“write less, do more”；包含的功能非常多（1. HTML元素选取；2. HTML元素操作；3. CSS操作；4. HTML事件函数；5. JavaScript特效和动画；6. HTML DOM遍历和修改；7. AJAX；8. Utilities；）；</li>
<li><strong>安装</strong>：可以将jQuery库下载到本地引用，也可以直接引用Microsoft或者google的CDN；使用引用CDN的方式有一个很大的优势就是许多用户在访问其他站点的时候已经加载过jQuery，结果就是当这些人访问站点时，会直接从缓存中加载jQuery，从而减少加载时间。而且，大多数CDN都可以确保用户在请求文件时，从最近的服务器上返回响应，从而提高加载速度；</li>
<li><strong>语法</strong>：语法形式为<code>$(selector).action()</code>，其中美元符号定义了jQuery，选择符（seclector）查询出符合条件的html元素，action函数对筛选出来的元素进行操作；举个最常见的例子：<code>$(document).ready(function(){});</code>这段代码表示在整个页面加载完成后再执行其中的操作；</li>
<li><strong>选择器</strong>：常见的选择器有以下几种：<ol>
<li>元素选择器：例如<code>$(&#39;p&#39;)</code>表示选取<code>&lt;p&gt;</code>元素；<code>$(&#39;p.intro&#39;)</code>表示选择类别为intro的<code>&lt;p&gt;</code>元素；</li>
<li>属性选择器：例如<code>$(&quot;[href]&quot;)</code>表示选取所有带有href属性的元素；<code>$(&quot;[href=&#39;#&#39;]&quot;)</code>表示选择所有带有href值等于#的元素；<code>$(&quot;[href$=&#39;.jpg&#39;]&quot;)</code>表示选择所有href值以.jpg结尾的元素；</li>
<li>更多是选择器参考<a href="http://www.w3school.com.cn/jquery/jquery_ref_selectors.asp" target="_blank" rel="external">jQuery选择器手册</a>。</li>
</ol>
</li>
<li><strong>事件</strong>：jQuery事件处理方法是jQuery的核心函数，事件处理程序指的是当HTML中发生某些事件所调用的方法，也叫作“触发”；（通常把jQuery代码放在<code>&lt;head&gt;</code>部分的事件处理方法中；详细的事件参考<a href="http://www.w3school.com.cn/jquery/jquery_ref_events.asp" target="_blank" rel="external">jQuery事件手册</a></li>
<li><strong>名称冲突</strong>：由于其他库也可能使用<code>$</code>符号，那么就会引起冲突，jQuery中使用<code>noConflict()</code>方法来解决这个问题；</li>
<li><strong>注意</strong>：为了使代码更容易维护，以下事项需要注意：<ol>
<li>把所有的jQuery代码置于事件处理函数中；</li>
<li>把所有事件处理函数置于文档就绪事件处理器中；</li>
<li>把jQuery代码置于单独的<code>.js</code>文件中;</li>
<li>如果存在名称冲突，则重命名jQuery库；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码"><a href="#实例及代码" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/akawvG/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/akawvG/" target="_blank" rel="external">jQuery01</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>注意：由于CodePen后台提供了jQuery的链接，所以在面板上看不到引入库的这一段代码。</p>
</blockquote>
<h4 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h4><p>本节主要是关于jQuery的简单介绍，其中选择器及事件为重点内容，可以查看手册后挑几个练习，使得具有最基本的功能：</p>
<blockquote>
<ol>
<li>下载jQuery库后本地引用或者直接引用链接；</li>
<li>具有基本的选择器及事件函数；</li>
</ol>
</blockquote>
<hr>
<h3 id="jQuery效果"><a href="#jQuery效果" class="headerlink" title="jQuery效果"></a>jQuery效果</h3><h4 id="关键词：隐藏显示，淡入淡出，滑动，动画，stop-，Callback-Chaining"><a href="#关键词：隐藏显示，淡入淡出，滑动，动画，stop-，Callback-Chaining" class="headerlink" title="关键词：隐藏显示，淡入淡出，滑动，动画，stop()，Callback, Chaining"></a>关键词：隐藏显示，淡入淡出，滑动，动画，stop()，Callback, Chaining</h4><ul>
<li><strong>隐藏显示</strong>：方法为<code>hide(), show()</code>，使用语法为<code>$(selector).hide(speed, callback)</code>，其中speed可以是slow，fast或者毫秒；而callback表示的是完成这个动作之后执行的函数；除了这两个方法之外，可以用<code>toggle()</code>的方法来切换显示隐藏，效果不错；</li>
<li><strong>淡入淡出</strong>：方法为<code>fadeIn(), fadeOut(), fadeToggle(), fadeTo()</code>，使用语法为<code>$(selector).fadeIn(speed, callback)</code>，其中speed和callback的理解和上面的一样；其中<code>fadeTo()</code>方法略有不同，语法为<code>$(selector).fadeTo(speed,opacity,callback)</code>，表示的是将选择出的元素的透明度变成目标值；</li>
<li><strong>滑动</strong>：方法为<code>slideDown(), slideUp(), slideToggle()</code>使用语法为<code>$(selector).slideDown(speed, callback)</code>，其中speed和callback的解释同上；</li>
<li><strong>动画</strong>：方法为<code>animate()</code>，使用语法为<code>$(selector).animate({params}, speed, callback)</code>，其中params参数定义形成动画的css属性，speed和callback的含义解释同上；其中属性的动画值可以设置成<code>&quot;show&quot;,&quot;hide&quot;,&quot;toggle&quot;</code>，具体见实例；如果需要实现步骤有先后的动画，那么可以通过编写多个animate()方法，jQuery就会逐一运行这些代码，这种功能叫做队列功能；animate方法几乎能操作所有的CSS属性，但是需要注意的是需要使用Camel标记法来书写属性名，比如paddingLeft,marginRight等；</li>
<li><strong>stop()</strong>: 此方法用于停止动画或者效果，适用于所有jQuery效果函数，语法为<code>$(selector).stop(stopAll,goToEnd)</code>，其中可选参数stopAll规定是否应该清除动画队列，默认是false，即仅停止活动的动画，但允许队列中的其他动画执行；可选参数goToEnd表示是否立即完成当前动画，默认为false；</li>
<li><strong>Callback</strong>：此函数在当前动画100%完成之后执行；因为JS语句是逐一执行的，为了避免因为动画还没执行完成而造成动画与之后的语句之间可能产生的错误或者页面冲突，建议以参数的形式添加Callback函数；</li>
<li><strong>Chaining</strong>：Chaining允许我们在一条语句中添加多个方法，例如<code>$(&#39;p&#39;).css(&#39;color&#39;, &#39;red&#39;).slideUp(2000).slideDown(2000);</code>，这是p元素就会先改变css样式，然后收缩，最后张开；为了易读性及格式的美观，可以通过换行及空格来美化；</li>
</ul>
<h4 id="实例及代码-1"><a href="#实例及代码-1" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EyZZQY/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EyZZQY/" target="_blank" rel="external">jQuery02</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="小测试-1"><a href="#小测试-1" class="headerlink" title="小测试"></a>小测试</h4><p>利用这节课所学的知识点，重现具有以上功能的div。</p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>  既然很多方法中已经都有callback函数的可选参数来达到链式运动的目的，那么为什么jQuery还需要有链式运动的功能？</p>
<ol>
<li>callback函数可以是任意函数，函数改变的对象可以是任意对象；</li>
<li>链式运动改变的对象是同一元素，链式运动的写法更简单；</li>
<li>还有类似功能的是动画的队列功能，不过动画改变的是具体的css属性；</li>
</ol>
<hr>
<h3 id="jQuery-HTML"><a href="#jQuery-HTML" class="headerlink" title="jQuery HTML"></a>jQuery HTML</h3><h4 id="关键词：获取、设置、添加、删除、css类、css-、尺寸"><a href="#关键词：获取、设置、添加、删除、css类、css-、尺寸" class="headerlink" title="关键词：获取、设置、添加、删除、css类、css()、尺寸"></a>关键词：获取、设置、添加、删除、css类、css()、尺寸</h4><ul>
<li>获取:用于获取内容的DOM操作方法主要有三个，获取属性值的方法主要有一个，分别是：<ol>
<li>text(): 设置或返回所选元素的文本内容；</li>
<li>html(): 设置或者返回所选元素的内容（包括html标签）；</li>
<li>val(): 设置或返回表单字段的值；</li>
<li>attr(): 用于获取属性值；</li>
</ol>
</li>
<li>设置：设置内容也是用上一节提到的三个函数，不过需要在括号中加入需要设置的内容，具体方法可见例子；同时需要知道，这三个jQuery方法都拥有回调函数，函数有两个参数，分别为被选元素列表中当前元素的下标以及原始值，<a href="http://www.w3school.com.cn/jquery/jquery_dom_set.asp" target="_blank" rel="external">text()、html() 以及 val() 的回调函数</a>；利用attr()来设置属性时可以同时设置多个属性，属性之间利用逗号隔开，此方法同样具有回调函数；</li>
<li>添加：利用jQuery可以很容易的添加新元素或者新内容，方法如下：<ol>
<li>append()：在被选元素的结尾插入内容或元素；</li>
<li>prepend()：在被选元素的开头插入内容或元素；</li>
<li>after()：在被选元素之后插入内容或元素；</li>
<li>before()：在被选元素之前插入内容或元素；</li>
</ol>
</li>
<li>删除：删除元素或内容主要通过以下两个jQuery方法：<ol>
<li>remove()：删除被选元素及其子元素，括号中可添加选择器，用于删除符合选择器条件的元素及其子元素；</li>
<li>empty(): 从被选元素中删除子元素；</li>
</ol>
</li>
<li>css类：通过jQuery可以很容易对css元素进行操作，主要方法有：<ol>
<li>addClass()：向被选元素添加一个或多个类（添加多个类的时候类名称之间用空格隔开）；</li>
<li>removeClass()：从被选元素删除一个或多个类；</li>
<li>toggle()：对被选元素添加/删除类的切换操作；</li>
<li>css()：设置或返回被选元素的一个或多个样式属性，语法为<code>css(&#39;propertyName&#39;)</code>如果有多个满足被选条件，则只返回第一个元素的属性；如需设置CSS属性，则需使用语法为<code>css(&#39;propertyName&#39;, &#39;value&#39;)</code>，此时将所有满足条件的元素的样式都设置成目标样式；</li>
</ol>
</li>
<li>尺寸：通过jQuery很容易处理元素和浏览器窗口的尺寸，主要的方法如下：<ol>
<li>width()：设置或返回元素的宽度（不包括内边距、边框和外边距），如果对象为document或者window，则表示返回HTML文档或者浏览器窗口的宽度和高度；如果在括号中加入数字，则表示将对应的尺寸设置为对应的值；</li>
<li>height()：设置或返回元素的高度（不包括内边距、边框和外边距）；</li>
<li>innerWidth()：返回元素的宽度（包括内边距）；</li>
<li>innerHeight()：返回元素的高度（包括内边距）；</li>
<li>outerWidth()：返回元素的宽度（包括内边距和边框），如果括号中增加参数‘true’则表示返回包括内外边距及边框的宽度；</li>
<li>outerHeight()：返回元素的高度（包括内边距和边框），如果括号中增加参数‘true’则表示返回包括内外边距及边框的高度；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码-2"><a href="#实例及代码-2" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/OXBzLX/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/OXBzLX/" target="_blank" rel="external">jQuery03</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>本小程序具有的功能：</p>
<ol>
<li>点击第一个按钮，能在方框中添加一个list，list的内容为输入框中的内容，且添加都是从头开始添加；</li>
<li>点击第二个按钮，移除方框中的一个list，且每次移除都是移除第一个；</li>
<li>点击第三个按钮能够改变方框中list的样式，具体为改变字体、字体颜色及list的样式；</li>
<li>点击第四个按钮能够改变方框的尺寸；</li>
</ol>
</blockquote>
<h4 id="小问题-1"><a href="#小问题-1" class="headerlink" title="小问题"></a>小问题</h4><p>利用append()及after()来添加内容的话，有何不同？</p>
<blockquote>
<p>前者是在所选元素的结尾处添加内容，也就是说，并没有新增加一个节点；而后者则在所选元素的后面增加内容，很显然这时候增加了一个节点。可以通过一个很小的例子来证明，局部代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;p&gt;This is a paragraph!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">hello!                           <span class="comment">//利用after()来添加 "Hello!"</span></span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">This is a paragraph!</span><br><span class="line">Hello!                          <span class="comment">//利用append()来添加 "Hello!"</span></span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="小测试-2"><a href="#小测试-2" class="headerlink" title="小测试"></a>小测试</h4><p>通过本节的学习，应该已经知道了利用jQuery来控制html元素的添加与删除以及css样式的设置，那么可以从添加、删除及设置样式的方法中任选几个来制作一个和上面所示类似功能的程序。</p>
<hr>
<h3 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h3><h4 id="关键词：遍历、祖先、后代、同胞、过滤"><a href="#关键词：遍历、祖先、后代、同胞、过滤" class="headerlink" title="关键词：遍历、祖先、后代、同胞、过滤"></a>关键词：遍历、祖先、后代、同胞、过滤</h4><ul>
<li>遍历：用于根据其相对于其他元素的关系来查找或者选取HTML元素；</li>
<li>祖先：祖先元素包括父元素、祖父元素等等，常用的方法为：<ol>
<li>parent()：返回被选元素的直接父元素；</li>
<li>parents()：返回被选元素的所有祖先元素，其中甚至包括文档的根元素（即<html>)；</html></li>
<li>parentsUntil()：返回介于两个给定元素之间的祖先元素；</li>
</ol>
</li>
<li>后代：与祖先相对的，后代指的是子、孙、曾孙等，常用的方法为：<ol>
<li>children()：返回被选元素的直接子元素；</li>
<li>find()：返回被选元素的被find的元素，包括所有后代；</li>
</ol>
</li>
<li>同胞：同胞拥有相同的父元素，常用的方法为：<ol>
<li>siblings()：返回所有被选元素的同胞元素；</li>
<li>next()：返回被选元素的下一个同胞元素；</li>
<li>nextAll()：返回被选元素的所有跟随的同胞元素；</li>
<li>nextUntil()：返回介于两个给定参数之间的所有跟随的同胞元素；</li>
<li>prev()：返回被选元素的上一个同胞元素；</li>
<li>prevAll():返回被选元素的所有前面的同胞元素；</li>
<li>prevUntil()：返回介于两个给定参数之间的所有的同胞元素；</li>
</ol>
</li>
<li>过滤：缩小搜索元素的范围，常用的方位有以下几种：<ol>
<li>first()：返回被选元素的首个子元素；</li>
<li>last()：返回被选元素的最后一个元素；</li>
<li>eq()：返回被选元素中带有指定索引号的元素；</li>
<li>filter()：返回符合匹配标准的元素集合；</li>
<li>not()：返回不匹配标准的所有元素集合；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例"><a href="#代码及实例" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/BzqvZJ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/BzqvZJ/" target="_blank" rel="external">jQuery04</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>注意：<br>在使用filter()进行筛选的时候，<code>$(selector).filter(some)</code>其中seclector和some是同一等级的，也就是说是在很多selector中找出符合‘some’这个筛选要求的selector。</p>
</blockquote>
<h4 id="小测试-3"><a href="#小测试-3" class="headerlink" title="小测试"></a>小测试</h4><p>本节的内容比较简单，只需要注意方法之间的细微差异就好。通过本节的学习，应该已经能够快速的找出所需要的元素或元素合集了。为了加深印象，可从上面那么多的遍历方法中挑出几个来进行练习。</p>
<hr>
<h3 id="jQuery-AJAX"><a href="#jQuery-AJAX" class="headerlink" title="jQuery AJAX"></a>jQuery AJAX</h3><h4 id="关键词：AJAX简介、加载、Get-Post"><a href="#关键词：AJAX简介、加载、Get-Post" class="headerlink" title="关键词：AJAX简介、加载、Get/Post"></a>关键词：AJAX简介、加载、Get/Post</h4><ul>
<li>简介：全称为Asynchronous JavaScript and XML，异步的JavaScript和XML，此功能能够在不重载整个页面的情况下通过后台加载数据，并在页面上显示出来；</li>
<li>加载：在jQuery中的AJAX方式为：load()，此方法能够从服务器中加载数据，并把返回的数据放入到被选元素中；语法为：<code>$(selector).load(URL, data, callback)</code>其中URL参数表示希望加载的地址；可选参数data规定了与请求一同发送的查询字符串键/值对集合；可选参数callback是load方法完成后所执行的函数名称，可设置参数为responsTxt（包含调用成功时的结果内容）,statusTxt（包含调用的状态）,xhr（包含XMLHttpRequest对象）；</li>
<li>Get/Post：两种常见的从服务器请求数据的方法，<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="external">点击这个链接可了解这两者的详细区别</a>；</li>
</ul>
<h4 id="代码及实例-1"><a href="#代码及实例-1" class="headerlink" title="代码及实例"></a>代码及实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><br><span class="line"></span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'https://code.jquery.com/jquery-2.2.4.min.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span><br><span class="line">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $.get(<span class="string">'a.txt?t='</span>+ <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(), <span class="function"><span class="keyword">function</span> (<span class="params">data, status</span>) </span>&#123;</span><br><span class="line">                    alert(<span class="string">'Date:'</span>+data+<span class="string">"\nStatus:"</span>+status);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>Get<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：由于ajax部分的内容需要在服务器环境下进行测试，所以本节只给出了代码的例子。</p>
</blockquote>
<h4 id="小测试-4"><a href="#小测试-4" class="headerlink" title="小测试"></a>小测试</h4><p>利用jquery我们不再需要自己去手写ajax文件了，确实是非常的方便。通过本节课程的学习，可自己动手在服务器环境下测试一下获取信息。（需要注意的是最好将html文件和待查询文件放在同一个服务器的文件夹中）</p>
<hr>
<h3 id="jQuery杂项"><a href="#jQuery杂项" class="headerlink" title="jQuery杂项"></a>jQuery杂项</h3><h4 id="关键词：命名冲突"><a href="#关键词：命名冲突" class="headerlink" title="关键词：命名冲突"></a>关键词：命名冲突</h4><ul>
<li>命名冲突：noConflict()，由于有可能其他框架也使用$符号作为简写，那么如果同时使用这两种框架的话就可能导致脚本停止运行，为了解决这个问题，在jQuery中使用noConflict()方法。语法为<code>$.noConflict()</code>这样写完以后，就需要用全名jQuery来代替$符号了。如果希望直接用$符号且不引起冲突，那么可以将$符号作为变量传给ready函数，但是需要注意的是在函数外还是需要用全名。</li>
</ul>
<h4 id="实例及代码-3"><a href="#实例及代码-3" class="headerlink" title="实例及代码"></a>实例及代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.noConflict();</span><br><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"p"</span>).text(<span class="string">"jQuery 仍在运行！"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; 接触jquery其实有一段时间了，但是真正开始学习的时间并不长。初步学完JS之后，又接触到bootstrap，然后了解到其中也包含了jquery的内容，所以决定先全面了解jquery然后再来学习bootstrap。<br>&nbsp; &nbsp; &nbsp; &nbsp; jQuery作为JS的轻量级的库存在，自然而然的在应用层面上比原生JS有着很大的优势，在利用jQuery写效果的时候就能明显的感觉到这一点。在jQuery中各种选择器应有尽有，各种事件也非常多，还有很好用的链式写法，这一切都与jQuery的宗旨“Write less, do more”不谋而合。<br>&nbsp; &nbsp; &nbsp; &nbsp; 由于时间关系，并没有去了解jQuery的内部写法的精妙，在之后的学习生涯中一定会找出时间来认真了解下。同样的由于时间关系，并没有将每种事件，每个选择器，每个效果都去实现一遍，但私以为在应用层面上效果只不过是外表，其内核都是一样的，所以这并不影响在需要这种效果的时候来调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;网上学习JS的过程告一段落，然后就马不停蹄的开始找JS框架和库的教程（感觉知乎上很多学习课程都是不负责任推荐，有点怀疑他们本身有没有看过那些推荐的教程。当然了，也可能是那些课程仅仅是不适合我。），找了一圈下来（网易云课堂、慕课网、极客学院、codecademy、free code camp等）没有发现适合的，要么讲的太简单了，要么信息量太大了。这时候，终于想起了w3school。以下的学习内容大部分都是基于这上面的，需要更详细的内容可以上&lt;a href=&quot;http://www.w3school.com.cn/jquery&quot;&gt;w3school&lt;/a&gt;查看。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="jQuery" scheme="http://detachment.club/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】 《精通JavaScript开发》</title>
    <link href="http://detachment.club/2016/07/02/%E5%9F%BA%E4%BA%8E%E3%80%8A%E7%B2%BE%E9%80%9AJavaScript%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://detachment.club/2016/07/02/基于《精通JavaScript开发》课程的复习与总结/</id>
    <published>2016-07-01T16:00:00.000Z</published>
    <updated>2016-12-28T06:13:34.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从5月25日开始开始学习，用了将近一个月的时间将<a href="http://study.163.com/course/courseMain.htm?courseId=224014" target="_blank" rel="external">视频课程</a>过了一遍，对比W3school及另外一套课程，这个课程给我的体验是整体进度设置很合理，Blue老师循循善诱，讲课风格非常适合新手学习。为了更好的掌握JavaScript的内容，下文将对每一章节做对应的总结与复习，并有相应的小测试来巩固复习。本文内容适合所有正在学习此课程的同学。<b>对于本课程或者本博客有任何问题，非常欢迎给我发邮件，我会尽我所能回答你的问题。</b></p>
<a id="more"></a>
<h2 id="课程章节"><a href="#课程章节" class="headerlink" title="课程章节"></a>课程章节</h2><h3 id="《初探JavaScript魅力01》"><a href="#《初探JavaScript魅力01》" class="headerlink" title="《初探JavaScript魅力01》"></a>《初探JavaScript魅力01》</h3><h4 id="关键词：JS、事件、属性、函数、重用、变量"><a href="#关键词：JS、事件、属性、函数、重用、变量" class="headerlink" title="关键词：JS、事件、属性、函数、重用、变量"></a>关键词：JS、事件、属性、函数、重用、变量</h4><ul>
<li>JavaScript：交互、功能；</li>
<li>事件：用户操作或者其他改变；</li>
<li>属性：属性是与对象相关的值；</li>
<li>函数：函数是指由事件驱动的或者当它被调用时执行的可重复使用的代码块；</li>
<li>重用：使开发效率更高，布局更简洁；</li>
<li>变量：存储信息的容器；</li>
</ul>
<h4 id="实例及代码"><a href="#实例及代码" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="277" scrolling="no" src="//codepen.io/Leon-Zhao/embed/kXwLYb/?height=277&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/kXwLYb/" target="_blank" rel="external">JavaScript-01</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h4><p>请利用这节课的知识，完成具有下面功能的区块：</p>
<blockquote>
<ol>
<li>区块大小200px*200px；背景颜色为红色；</li>
<li>鼠标移入区块大小变成300px*300px，背景颜色变成蓝色；</li>
<li>鼠标移出区块大小及颜色变成初始状态。</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力02》"><a href="#《初探JavaScript魅力02》" class="headerlink" title="《初探JavaScript魅力02》"></a>《初探JavaScript魅力02》</h3><h4 id="关键词：变量、函数的定义及调用、ID、if判断、双等号、className"><a href="#关键词：变量、函数的定义及调用、ID、if判断、双等号、className" class="headerlink" title="关键词：变量、函数的定义及调用、ID、if判断、双等号、className"></a>关键词：变量、函数的定义及调用、ID、if判断、双等号、className</h4><ul>
<li>函数定义及调用：定义时只是告诉系统有这个函数，但不会执行；调用的时候函数执行；</li>
<li>ID：任何标签都可以加ID，包括link。任何标签的任何属性都可以改，而且html上怎么写，js里就怎么写（除了className）；</li>
<li>if：条件判断；</li>
<li>双等号：用于判断双等号两边是否相等；</li>
<li>className： 列别名，为js中的保留字，唯一一个在html及js中写法不同的属性；</li>
</ul>
<h4 id="实例及代码-1"><a href="#实例及代码-1" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/zBzpjv/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBzpjv/" target="_blank" rel="external">JavaScript-02-01</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/XKgVoX/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/XKgVoX/" target="_blank" rel="external">JavaScript-02-02</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>


<h4 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>新建一个按钮及div；</li>
<li>点击按钮更改div的样式（可以是背景颜色、大小或者其他）；</li>
<li>必须通过更改div的类来达到上面的效果；</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力03》"><a href="#《初探JavaScript魅力03》" class="headerlink" title="《初探JavaScript魅力03》"></a>《初探JavaScript魅力03》</h3><h4 id="关键词：函数传参、操作属性方法、字符串及参数"><a href="#关键词：函数传参、操作属性方法、字符串及参数" class="headerlink" title="关键词：函数传参、操作属性方法、字符串及参数"></a>关键词：函数传参、操作属性方法、字符串及参数</h4><ul>
<li>函数传参：当函数中有参数有多个值时使用传参，参数就是占位符；</li>
<li>操作属性方法：最常用的为通过“.”，但是当属性作为参数的时候，需要用”[]”的形式来改变参数，否则无法被识别；所有用.的地方都能用[]替换，但反过来不成立；</li>
<li>字符串为常量，设定后即为定值；参数则为变量，传入时才确定；传入字符串时需要加双引号，而后者不需要；</li>
</ul>
<h4 id="实例及代码-2"><a href="#实例及代码-2" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/grRZBL/?height=265&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/grRZBL/" target="_blank" rel="external">JavaScript-03</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>新建三个按钮及一个有字体内容的div；</li>
<li>分别点击按钮改变div中字体的大小、颜色及样式；</li>
<li>通过函数传参的方式达到上面所要求的效果。</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力04》"><a href="#《初探JavaScript魅力04》" class="headerlink" title="《初探JavaScript魅力04》"></a>《初探JavaScript魅力04》</h3><h4 id="关键词：样式优先级、提取行间事件、匿名函数、window-onload、获取元素组、循环"><a href="#关键词：样式优先级、提取行间事件、匿名函数、window-onload、获取元素组、循环" class="headerlink" title="关键词：样式优先级、提取行间事件、匿名函数、window.onload、获取元素组、循环"></a>关键词：样式优先级、提取行间事件、匿名函数、window.onload、获取元素组、循环</h4><ul>
<li>样式优先级：表示样式优先执行的顺序，如右： 通配符&lt;标签&lt;class&lt;ID&lt;行间；（对于同一个元素，修改样式的时候建议在同一优先级进行修改。）</li>
<li>提取行间事件：行间事件也是一种特殊的属性；</li>
<li>匿名函数：不进行命名的函数；</li>
<li>获取元素组：利用getElementsByTagName获取;</li>
<li>循环：while（包括初始化、条件、语句和自增）；for 循环。</li>
</ul>
<h4 id="实例及代码-3"><a href="#实例及代码-3" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/zBzJAV/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBzJAV/" target="_blank" rel="external">JavaScript-04</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面的一个小程序：</p>
<blockquote>
<ol>
<li>新建两个按钮及若干个div，大小及背景颜色随意；</li>
<li>点击按钮分别能改变所有div的大小或者颜色。</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力05》"><a href="#《初探JavaScript魅力05》" class="headerlink" title="《初探JavaScript魅力05》"></a>《初探JavaScript魅力05》</h3><h4 id="关键词：This、innerHTML、字符串连接、数组"><a href="#关键词：This、innerHTML、字符串连接、数组" class="headerlink" title="关键词：This、innerHTML、字符串连接、数组"></a>关键词：This、innerHTML、字符串连接、数组</h4><ul>
<li>This：当前发生事件的元素（目前这么理解就行了，更多的用法后面会涉及到）；</li>
<li>innerHTML：写入到html页面中，写入的内容本身可以包含html标签；</li>
<li>字符串连接：通过了解符 <code>+</code> 来实现，注意有优先级的问题；</li>
<li>数组：一系列值的组合；</li>
</ul>
<h4 id="实例及代码-4"><a href="#实例及代码-4" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="559" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/ZOydkq/?height=559&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/ZOydkq/" target="_blank" rel="external">JavaScript-05</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个选项卡；</li>
<li>有四个选项，且每一项都对应不同的内容；</li>
<li>鼠标移动到不同选项卡的时候，显示不同的内容；</li>
<li>鼠标移入选项卡的时候，选项卡本身的样式也会发生一些变化。</li>
</ol>
</blockquote>
<hr>
<h3 id="《JavaScript基础01》"><a href="#《JavaScript基础01》" class="headerlink" title="《JavaScript基础01》"></a>《JavaScript基础01》</h3><h4 id="关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范"><a href="#关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范" class="headerlink" title="关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范"></a>关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范</h4><ul>
<li>JS组成：JS由ECMAScript（解释器、翻译）、DOM（操纵html）、BOM（操作浏览器，兼容性）；ECMA几乎没有兼容问题，DOM有一些操作不兼容，BOM没有兼容问题（完全不兼容）；</li>
<li>变量类型：数字、字符、对象、函数、布尔值、未定义；（一个变量最好只存一种类型的变量）；</li>
<li>parseInt：将字符转换成数字，从左到右扫描字符，一旦遇到不是数字的就直接返回，因此也可提取字符串中的数字；字符串不为数字，则返回NAN；只用于转换整数，如要转换成小数，则为parseFloat；</li>
<li>NaN：唯一一个不等于本身，isNaN用于判断是否为NaN；</li>
<li>类型转换：显示类型转换（如上面提到的）及隐式类型转换（系统自动转换），然后就涉及到<code>==</code>和<code>===</code>后者不进行隐式类型转换就开始比较；<code>+</code>运算时不会进行隐形类型转换而<code>-</code>符号则会先进行类型转换再运算；</li>
<li>作用域：变量作用范围，局部变量及全局变量；</li>
<li>闭包：子函数可使用父函数的局部变量；</li>
<li>命名规范：可读性及规范性（匈牙利命名法）；</li>
</ul>
<h4 id="实例及代码-5"><a href="#实例及代码-5" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="124" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/bZAbVk/?height=124&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/bZAbVk/" target="_blank" rel="external">JavaScript-06</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个加法计算器；</li>
<li>计算器形式为<code>a + b = c</code>，其中a和b为输入框中的数字，c为输出的数字；</li>
<li>计算前先判断是否为数字类型，如果不是则弹出提示；</li>
<li>能计算整数及小数；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JavaScript基础02》"><a href="#《JavaScript基础02》" class="headerlink" title="《JavaScript基础02》"></a>《JavaScript基础02》</h3><h4 id="关键词：运算符、程序流程控制、True和False、Json、Json和数组"><a href="#关键词：运算符、程序流程控制、True和False、Json、Json和数组" class="headerlink" title="关键词：运算符、程序流程控制、True和False、Json、Json和数组"></a>关键词：运算符、程序流程控制、True和False、Json、Json和数组</h4><ul>
<li>运算符：用于算数、赋值、关系、逻辑、优先级等；</li>
<li>程序流程控制：判断（if、switch、？：），循环（while、for），跳出（continue、break）</li>
<li>True和False： 表示的是计算机用于计算的真与假，true包括：true、非零数字、非空字符串、非空对象；false包括：false、0、空字符串、空对象、undefined；</li>
<li>Json：一种轻量级的数据交换格式，是基于JavaScript的一个子集；（注意Json没有length属性，使用循环的话需要for（var i in json）这种形式）；</li>
<li>Json与数组的区别：1.Json的下标为字符串，而数组为数字；2.前者无length属性而后者有；3.前者循环只能用for（var i in json）的形式，而后者两种形式都可以；</li>
</ul>
<h4 id="实例及代码-6"><a href="#实例及代码-6" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/NAvGjb/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/NAvGjb/" target="_blank" rel="external">JavaScript-07</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-6"><a href="#测试题-6" class="headerlink" title="测试题"></a>测试题</h4><p>由于本节内容多为介绍性，基本上每个程序都非常简单，可用练习下列小程序：</p>
<blockquote>
<ol>
<li>制作一个隔行变色的表格；</li>
<li>利用switch制作一个小程序；</li>
<li>利用三运算符<code>?:</code>制作一个小程序；</li>
<li>利用break或者continue制作一个小程序；</li>
<li>利用Json制作一个小程序。</li>
</ol>
</blockquote>
<hr>
<h3 id="《深入JavaScript》"><a href="#《深入JavaScript》" class="headerlink" title="《深入JavaScript》"></a>《深入JavaScript》</h3><h4 id="关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort"><a href="#关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort" class="headerlink" title="关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort"></a>关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort</h4><ul>
<li>函数返回值：即为函数的执行结果；</li>
<li>传不定参：arguments，参数的个数可变；（例子：求和、css函数）</li>
<li>取非行间样式：如果样式没有写在行间，那么应该利用currentStyle(IE)或者getComputedStyle(obj，false).name。利用if，else来进行兼容性处理；获取复合样式的属性时需要注明所取的明确样式（如获取背景颜色，需要写backgroundColor，直接写background是没有作用的）。</li>
<li>数组：使用单一变量的值存储一系列的值；数组的length属性既可读亦可写，因此可利用可写功能快速清空数组；添加：push及unshift（分别表示在尾部及头部添加）；删除：pop及shift（分别表示从尾部及头部删除）；</li>
<li>splice：splice(n1,n2)表示从数组的n1位置开始删n2个元素；splice(n1,n2,”a”,”b”,”c”…)表示在n1位置删除n2个元素，并添加后面的”a”,”b”,”c”,等等；</li>
<li>concat：数组的连接，语法:<code>a.concat(b)</code>,则数组a和b连接，a是元素在b的元素前面；</li>
<li>join：表示用给定的参数连接数组里面的值，语法为<code>arr.join(&quot;value&quot;)</code>,那么arr中的值就将会被value连接起来；</li>
<li>sort：数组的排序，语法为<code>arr.sort()</code>,其中sort()括号中可传入函数，表示排序的依据；在对数字排序的时候，因为sort属性只认字符串，所以必须传入比较函数；</li>
</ul>
<h4 id="实例及代码-7"><a href="#实例及代码-7" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EyvXLd/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EyvXLd/" target="_blank" rel="external">JavaScript-08</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-7"><a href="#测试题-7" class="headerlink" title="测试题"></a>测试题</h4><p>同样的，本节也主要是在讲一些非常基础的知识，没有涉及到复杂程序的练习，所以大家可选择性练习下方小程序：</p>
<blockquote>
<ol>
<li>利用不定参argument制作一个程序，如果传入的是两个参数则获取参数值；如传入三个值，则设置参数；</li>
<li>练习数组的相关属性：pop、unshift、push、shift、concat、join、sort、splice、length；</li>
</ol>
</blockquote>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><blockquote>
<p>有没有什么方法能够直接修改css样式中的参数值？（由本节讲到的可直接获取样式中的参数值想到的）</p>
</blockquote>
<hr>
<h3 id="《定时器的使用01》"><a href="#《定时器的使用01》" class="headerlink" title="《定时器的使用01》"></a>《定时器的使用01》</h3><h4 id="关键词：定时器、清除定时器、Date对象、charAt"><a href="#关键词：定时器、清除定时器、Date对象、charAt" class="headerlink" title="关键词：定时器、清除定时器、Date对象、charAt()"></a>关键词：定时器、清除定时器、Date对象、charAt()</h4><ul>
<li>定时器：间隔性(setInterval)、延时性(setTimeout);</li>
<li>清除定时器：clearInterval(name),name为需要关闭的定时器的名称；对应的还有clearTimeout;</li>
<li>Date(): 包括<code>getHours(),getMinutes(),getSeconds(),getFullYear(),getMonth(),getDate(),getDay()</code>，其中getMonth()获取的月份是从0开始的；</li>
<li>charAt: 兼容低版本的获取元素的方法，比如获取str中第i位元素：<code>str[i]=str.charAt(i)</code>;</li>
</ul>
<h4 id="实例及代码-8"><a href="#实例及代码-8" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="355" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/akyxYo/?height=355&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/akyxYo/" target="_blank" rel="external">JavaScript09</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-8"><a href="#测试题-8" class="headerlink" title="测试题"></a>测试题</h4><p>本节讲到了两个例子，一个就是上面的数码时钟，另一个就是下面的延时提示框，需要满足的功能如下：</p>
<blockquote>
<ol>
<li>有一大一小两个div，左右分布；</li>
<li>当鼠标放入小div区域时，大的div显示；</li>
<li>当鼠标移出小div到别处，大div经过500ms后消失；</li>
<li>如果在这500ms内，鼠标移入大div区域，则大div不消失；</li>
<li>从大div移出时，500ms后大div消失；</li>
<li>在500ms内如果鼠标移入小div，则大div不消失；<br>（简单来说：当鼠标在可见的div范围内，div常显；当鼠标在空白处500ms后，大div消失）</li>
</ol>
</blockquote>
<hr>
<h3 id="《定时器的使用02》"><a href="#《定时器的使用02》" class="headerlink" title="《定时器的使用02》"></a>《定时器的使用02》</h3><h4 id="关键词：offsetLeft、无缝滚动、innerHTML"><a href="#关键词：offsetLeft、无缝滚动、innerHTML" class="headerlink" title="关键词：offsetLeft、无缝滚动、innerHTML"></a>关键词：offsetLeft、无缝滚动、innerHTML</h4><ul>
<li>offsetLeft：元素的水平偏移位置（包括margin）；</li>
<li>无缝滚动：结合offsetLeft及定时器的综合应用；应该包括的功能：左右都能滚动、鼠标移入暂停，移出重新滚动；</li>
<li>innerHTML: 可以用innerHTML+=innerHTML来使得某元素内的内容为两份的之前的内容；</li>
<li>在编写本节课程的时候一定不要不要忘记了加上<code>px</code>.</li>
</ul>
<h4 id="实例及代码-9"><a href="#实例及代码-9" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/NAvkQj/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/NAvkQj/" target="_blank" rel="external">JavaScript10</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-9"><a href="#测试题-9" class="headerlink" title="测试题"></a>测试题</h4><p>根据所学的知识，拓展本节课的实例功能：</p>
<blockquote>
<ol>
<li>增加滚动速度选项：可分为快、一般、慢，三种滚动速度。</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM基础》"><a href="#《DOM基础》" class="headerlink" title="《DOM基础》"></a>《DOM基础》</h3><h4 id="关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className"><a href="#关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className" class="headerlink" title="关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className"></a>关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className</h4><ul>
<li>节点：和css中的标签、js中的元素是一个意思；</li>
<li>childNodes：子节点集合，包括文本节点及元素节点（在IE8下不包括空白的文本节点）</li>
<li>文本节点及元素节点：前者不包括在标签中，后者包含在标签中；</li>
<li>nodeType：节点类型；nodeType为3时为文本节点，nodeType为1时为元素节点；</li>
<li>children：子节点集合，不包括文本节点，只包含元素节点；</li>
<li>parentNode：元素父节点；</li>
<li>offsetParent：表示用于定位的父级；</li>
<li>firstChild： 第一个子节点（包括文本子节点）。firstElementChild则不包括文本子节点，只包括元素子节点，但是低版本IE不兼容，因此要用if语气来兼容；</li>
<li>setAttribute：用DOM方式操纵元素，语法为<code>setAttribute(name, value)</code>，与此类似的还有getAttribute，语法为<code>getAttribute(name)</code>，以及removeAttribute，语法为<code>removeAttribute(name)</code>；</li>
<li>className：类别名，结合判断能批量修改特定类别的元素，也可以将if函数及类别封装成固定的函数，方便调用；</li>
</ul>
<h4 id="实例及代码-10"><a href="#实例及代码-10" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EywNVV/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EywNVV/" target="_blank" rel="external">JavaScript11</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-10"><a href="#测试题-10" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>将有特定class属性的div的第一个子节点的所有内容的字体改为times；</li>
<li>提示：需要使用firstChild及className的使用，注意兼容性；</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM操作应用》"><a href="#《DOM操作应用》" class="headerlink" title="《DOM操作应用》"></a>《DOM操作应用》</h3><h4 id="关键词：createElement、appendChild、insertBefore、removeChild、文档碎片"><a href="#关键词：createElement、appendChild、insertBefore、removeChild、文档碎片" class="headerlink" title="关键词：createElement、appendChild、insertBefore、removeChild、文档碎片"></a>关键词：createElement、appendChild、insertBefore、removeChild、文档碎片</h4><ul>
<li>creatElement： 创建元素，语法<code>createElement(element)</code>，创建完成后还需要添加到父节点才有效；</li>
<li>appendChild：将创建的元素添加到父节点，语法：<code>obj.appendChild(element)</code>，其中obj为父节点，element为创建出来的元素；如果appendChild的元素为现有的元素，那么使用这个属性的时候会先从现有的父级上删除，然后添加到新的父级里；</li>
<li>注意：不管是html中原有的，还是通过DOM创建出来的，性质都是一样的，没有区别；</li>
<li>insertBefore：在父节点内插入子节点，语法：<code>obj.insertBefore(element, obj[i])</code>表示在父节点obj中的第i个元素前面插入元素；但是如果obj中本来没有元素，那么就没法obj[i]就不存在，这时候还得用appendChild，所以这两个经常结合使用，解决兼容性问题；</li>
<li>removeChild：移除子节点，语法<code>obj.removeChild(element)</code>，其中obj为父节点，element为需要移除的元素；</li>
<li>文档碎片：文档碎片可以提高DOM操作性能（理论上），语法：<code>createDocumentFragment()</code>；（实际上在高级浏览器上，文档碎片几乎不会提高效率）</li>
</ul>
<h4 id="实例及代码-11"><a href="#实例及代码-11" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="219" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/zBEPKE/?height=219&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBEPKE/" target="_blank" rel="external">JavaScript12</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-11"><a href="#测试题-11" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个表格。两个按钮：一个增加表格行数，一个删除表格行数；</li>
<li>每次增加的行数都在第一行，删除则从最后一行开始；</li>
<li>顺便加上各行变色的小功能；</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM操作应用高级-01》"><a href="#《DOM操作应用高级-01》" class="headerlink" title="《DOM操作应用高级-01》"></a>《DOM操作应用高级-01》</h3><h4 id="关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase-、search-、"><a href="#关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase-、search-、" class="headerlink" title="关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase()、search()、"></a>关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase()、search()、</h4><ul>
<li>tBodies:选出tbody元素，相当于<code>getElementsByTagName(&#39;tbody&#39;)</code>，同样的还有tHead、tFoot、rows及cells；</li>
<li>搜索：需要的功能有——忽略大小写、模糊搜索、多关键词搜索；</li>
<li>toLowerCase:转化成小写；</li>
<li>search：搜索文本，如果搜索到则返回所在位置，未找到则返回-1；</li>
<li>split：切分字符串，语法为<code>str.split(&#39;aa&#39;)</code>，表示用aa来切分str，aa可以为空格或者任何字符；</li>
</ul>
<h4 id="实例及代码-12"><a href="#实例及代码-12" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/jAGxaz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/jAGxaz/" target="_blank" rel="external">JavaScript13</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>本程序具有的功能：</p>
<ol>
<li>表格隔行变色；</li>
<li>鼠标移入移除高亮；</li>
<li>手动输入添加内容，并同时保证功能1和2有效，而且自动标号不重复；</li>
<li>具有删除所添加行的功能，同时保证1和2的功能有效；</li>
<li>只能搜索，可忽略大小写及模糊搜索；</li>
</ol>
</blockquote>
<h4 id="测试题-12"><a href="#测试题-12" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学内容，完善上面的小程序：</p>
<blockquote>
<ol>
<li>加入多关键词搜索功能（结合split功能及search）；</li>
<li>搜索功能与上述功能1，2兼容；（目前我还没想到更好的办法去解决）</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM操作应用高级-02》"><a href="#《DOM操作应用高级-02》" class="headerlink" title="《DOM操作应用高级-02》"></a>《DOM操作应用高级-02》</h3><h4 id="关键词：排序、aLi、表单、onsubmit、onreset、表单验证"><a href="#关键词：排序、aLi、表单、onsubmit、onreset、表单验证" class="headerlink" title="关键词：排序、aLi、表单、onsubmit、onreset、表单验证"></a>关键词：排序、aLi、表单、onsubmit、onreset、表单验证</h4><ul>
<li>排序：中心思想是结合利用appendChild的移动功能及sort的排序功能；</li>
<li>aLi：aLi=document.getElementById(‘li’),虽然看起来像是数组，但却又不是正真的数组，它不具备sort、join等功能，确切来说这只是一个元素集合；</li>
<li>表单：用于向服务器提交数据，action为链接地址；</li>
<li>onsubmit：提交数据是发生的事件；</li>
<li>onreset：重置表单时发生的事件；</li>
<li>表单验证：阻止用户输入非法字符等；</li>
</ul>
<h4 id="实例及代码-13"><a href="#实例及代码-13" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/YWABXk/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/YWABXk/" target="_blank" rel="external">JavaScript14</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>本小程序就有的功能：</p>
<ol>
<li>所有上节课程序所具有的功能；</li>
<li>在上节课的基础上具有排序功能；</li>
<li>与课程相比，本排序功能具有选择性，即可根据所需要的排序依据进行排序；</li>
</ol>
</blockquote>
<h4 id="测试题-13"><a href="#测试题-13" class="headerlink" title="测试题"></a>测试题</h4><p>表单内容比较简单，可利用表单完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个表单，包括用户名、密码和提交；</li>
<li>提交时会弹出一个确认页面；</li>
<li>具有重置内容；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动基础-01》"><a href="#《JS运动基础-01》" class="headerlink" title="《JS运动基础-01》"></a>《JS运动基础-01》</h3><h4 id="关键词：运动框架、分享侧边栏、图片淡入淡出"><a href="#关键词：运动框架、分享侧边栏、图片淡入淡出" class="headerlink" title="关键词：运动框架、分享侧边栏、图片淡入淡出"></a>关键词：运动框架、分享侧边栏、图片淡入淡出</h4><ul>
<li>运动：利用定时器及offsetLeft来实现；</li>
<li>框架完善过程：<ol>
<li>到指定地点停止；</li>
<li>点击后，运动前先清除定时器，保证每次只有一个定时器处于工作状态；</li>
</ol>
</li>
<li>分享侧边栏：鼠标移入移出，运动方向相反；</li>
<li>图片淡入淡出：鼠标移入移出改变图片的透明度；</li>
</ul>
<h4 id="实例及代码-14"><a href="#实例及代码-14" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="353" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/XKZwyK/?height=353&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/XKZwyK/" target="_blank" rel="external">JavaScript15</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p><strong>注意：变量申明的位置非常重要，变量申明的位置能够直接影响到变量的值是否收到函数的影响</strong></p>
<h4 id="测试题-14"><a href="#测试题-14" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的运动框架的学习，完成下面的小程序：</p>
<blockquote>
<ol>
<li>新建一个分享侧边栏，侧边栏上有个小标签；</li>
<li>将整个div布局在视窗的左下角；</li>
<li>正常情况下侧边栏只有标签能看到，鼠标移入时，整个div出现，移出div后0.5s后侧边栏又隐藏到视窗外；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动基础-02》"><a href="#《JS运动基础-02》" class="headerlink" title="《JS运动基础-02》"></a>《JS运动基础-02》</h3><h4 id="关键词：缓冲运动、Math、右侧悬浮框"><a href="#关键词：缓冲运动、Math、右侧悬浮框" class="headerlink" title="关键词：缓冲运动、Math、右侧悬浮框"></a>关键词：缓冲运动、Math、右侧悬浮框</h4><ul>
<li>缓冲运动：运动速度与到目标位置相关；</li>
<li>Math：数学函数，常用的有Math.ceil()，表示向上取整；Math.floor()，表示向下取整；由于目标值可能大于也可能小于现在的值，所以需要根据速度来判断是向上还是向下取整，这时候就可以利用三元运算符简单的判断一下了，具体的操作可以在下面的实例中看到；Math.abs()，表示的是取绝对值，在匀速运动的停止条件的时候能用到；</li>
<li>匀速运动时，由于速度可能不能被运动量整除，那么为了正好达到目标，可以定义在距离目标近到一定程度（绝对值小于速度值）的时候，直接让程序到达目标点；在缓冲运动中由于运动在最后，速度值可能会是小数，而浏览器默认会将小数部分舍去，所以达不到目标，为了达到目标，只要直接对速度进行取整（整数时向上取整，负数时向下取整），保证在速度为小数时也能继续运动；</li>
</ul>
<h4 id="实例及代码-15"><a href="#实例及代码-15" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/zBPaLv/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBPaLv/" target="_blank" rel="external">JavaScript16</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>本程序具有的功能：</p>
<ol>
<li>这个小程序就综合了匀速运动与缓冲运动，水平方向上为匀速运动，竖直方向为缓冲运动；</li>
<li>注意：特别需要小心的是在写尺寸的时候别忘了加上“px”，否则代码无效而且不会报错！</li>
</ol>
</blockquote>
<h4 id="测试题-15"><a href="#测试题-15" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节缩写的内容，完成制作一个缓冲样式的滚动条，具体如下：</p>
<blockquote>
<ol>
<li>缓冲条位于视窗的右侧中间位置；</li>
<li>不管是向上滚动还是向下滚动，缓冲后滚动条都会停止在视窗右侧中间；</li>
<li>停止运动时不能抖动（用到parseInt属性）；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动应用-01》"><a href="#《JS运动应用-01》" class="headerlink" title="《JS运动应用-01》"></a>《JS运动应用-01》</h3><h4 id="关键词：多物体同时运动、offsetWidth、任意值运动框架"><a href="#关键词：多物体同时运动、offsetWidth、任意值运动框架" class="headerlink" title="关键词：多物体同时运动、offsetWidth、任意值运动框架"></a>关键词：多物体同时运动、offsetWidth、任意值运动框架</h4><ul>
<li>多物体运动框架：将定时器变成元素的属性，那么调用时则不会相互干扰；（例子：改变div的长度，互不影响；或者改变透明度；）</li>
<li>补充：在多物体运动的情况下，所有的属性都不能共用，例如上面提到的透明度，需要先把透明度赋值给一个变量，那么就需要将这个变量变成所有需要调用的对象的属性；</li>
<li>offsetWidth：本节讨论到了与offset相关的属性，<strong>提到这是包含padding及border的属性</strong>，那么在有border的情况下，前面的例子就会有一定的变化；为了避免因为border及padding带来的影响，建议使用本身的属性来带入程序（因为一般样式属性写在样式表中，那么就会用到之前学到的currentStyle活getComputeStyle属性了）；</li>
<li>任意值运动框架：一套运动框架能控制几乎所有的属性变化，其包含三个属性：作用对象、作用属性、变化值；</li>
</ul>
<h4 id="代码及实例"><a href="#代码及实例" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/mEqNoE/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/mEqNoE/" target="_blank" rel="external">JavaScript17</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-16"><a href="#测试题-16" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的知识，制作如下一个小程序：</p>
<blockquote>
<ol>
<li>自己重写一个完美运动框架；</li>
<li>利用这个框架来改变不同的样式，但是别包括上面已经写过的长度、宽度或者透明度；</li>
<li>给对象加上border属性后检查效果是否仍然相符。</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动应用-02》"><a href="#《JS运动应用-02》" class="headerlink" title="《JS运动应用-02》"></a>《JS运动应用-02》</h3><h4 id="关键词：仿flash运动"><a href="#关键词：仿flash运动" class="headerlink" title="关键词：仿flash运动"></a>关键词：仿flash运动</h4><ul>
<li>仿flash运动：这个小程序结合了近几节课所学的知识点，非常值得联系，具体的实现过程如下：<ol>
<li>左右按钮移入移出显示隐藏；（包括在左右键上）；</li>
<li>点击小图能起到切换大图的功能（更改大图的Zindex–写在行间为Zindex，写在样式表中为Z-index，缓冲运动改高度）；切换之前需要判断切换到的是否为当前，如果为当前则不发生变化；</li>
<li>点击时，小图除切换功能外还会变成不透明；所有的小图移入移出透明度都有变化，但是当前图片移出时不变化；</li>
<li>增加左右按钮点击时大图切换的功能；（第一张图及最后一张图的时候则开始自循环）</li>
<li>点击左右按钮时除了大图要切换，小图也需要滚动，而且也要注意第一张及最后一张的特殊情况；</li>
<li>增加自动播放的功能，也加入鼠标移入移出时的消除启动播放；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码-16"><a href="#实例及代码-16" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="769" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/grorbK/?height=769&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/grorbK/" target="_blank" rel="external">JavaScript18</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>注：</p>
<ol>
<li>本程序实现的过程中没有利用课程中所讲到的利用Z-index属性的叠加，而是利用了之前课程中学到的轮播，效果算是各有特色；</li>
<li>实现的过程中发现布局对JS的影响非常大，第一次跟着课程实现效果的时候因为CSS还学习的很糟糕，所以就知识重写了JS部分，这次再重写的时候，写到CSS才发现为什么用到Z-index，以及不用也行的道理；</li>
<li>实践出真知。</li>
</ol>
</blockquote>
<h4 id="测试题-17"><a href="#测试题-17" class="headerlink" title="测试题"></a>测试题</h4><p>根据这节课所学到的知识点，完成下面的小程序：</p>
<blockquote>
<ol>
<li>利用Z-index或者我上面使用的轮播的形式重写一次这个程序，巩固学习效果；</li>
<li>所重写的程序应该具有上面提到的所有功能；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动中级》"><a href="#《JS运动中级》" class="headerlink" title="《JS运动中级》"></a>《JS运动中级》</h3><h4 id="关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）"><a href="#关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）" class="headerlink" title="关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）"></a>关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）</h4><ul>
<li>链式运动：完成一个运动之后，开始另一个运动。原理即为在原来的运动框架中加入一个函数参数，即在动作完成的部分加入一条新的语句；</li>
<li>完美运动：结合json及运动框架，构建一个完美运动框架，能同时改变多个属性值；（注意：在同时改变多个属性值的时候，需要所有值都达到目标值后才能关闭定时器）；</li>
</ul>
<h4 id="实例及代码-17"><a href="#实例及代码-17" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/groGqv/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/groGqv/" target="_blank" rel="external">JavaScript19</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>注：</p>
<ol>
<li>本例为完美运动框架的简单运用，这个运动框架能满足多个元素属性值的同时改变直到所有的属性值都达到目标值才停止；</li>
</ol>
</blockquote>
<h4 id="测试题-18"><a href="#测试题-18" class="headerlink" title="测试题"></a>测试题</h4><p>根据这节课所学到的完美运动框架，写出下面一个小程序：</p>
<blockquote>
<ol>
<li>形式如新浪微博的新消息发布；</li>
<li>点击发布后，公告栏则会生成输入的信息；</li>
<li>信息显示按时间排布，最新的消息显示在最上端；</li>
<li>新生成消息的过程加上完美运动框架，达到高度缓慢撑开，透明度逐渐增加的效果；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件基础》"><a href="#《JS事件基础》" class="headerlink" title="《JS事件基础》"></a>《JS事件基础》</h3><h4 id="关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性"><a href="#关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性" class="headerlink" title="关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性"></a>关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性</h4><ul>
<li>event对象：事件对象，应用在IE6-8及高版本的chrome浏览器，在低版本的chrome浏览器及Firefox中需要用到一个参数：ev，在调用函数时，系统就将这个参数传给函数；为了解决这个兼容问题，可以用一个“或”的表达式，例如：<code>var oEvent=event||ev;</code>，然后调用的时候，直接用oEvent就好了；</li>
<li>document：包含整个页面的内容，上至&lt;!DOCTYPE html&gt;，下至;如果需要给整个页面加点击事件，应该加在document上而不是body上，因为body的范围由它所包含的内容决定；</li>
<li>事件流：最简单的一个事件流的例子——事件冒泡（一般会带来一些困扰，所以很多时候需要取消冒泡：通过事件对象来解决——<code>oEvent.cancelBubble=true;</code>，典型的例子为仿select下拉框）；</li>
<li>鼠标事件：鼠标坐标，clientX及clientY(表示的是可视区的坐标，所有如果有滚动的时候需要加上scrollTop和scrollLeft)；</li>
<li>keyCode：表示键盘上按键的键码，按键事件为onkeydown及onkeyup；（按键卡顿现象：照顾特殊人群，但是会造成不好的影响，解决方案为将事件加上setInterval函数来将延迟给掩饰掉，按键抬起时清除定时器）；</li>
<li>其他属性：ctrlKey，shiftKey、altKey，使用的时候都需要结合事件对象，例如：<code>oEvent.ctrlKey</code>；</li>
</ul>
<h4 id="实例及代码-18"><a href="#实例及代码-18" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EyQxLk/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EyQxLk/" target="_blank" rel="external">JavaScript20</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<blockquote>
<p>注：</p>
<ol>
<li>在输入框中输入任意字符；</li>
<li>鼠标点击enter或者直接用键盘enter；</li>
<li>移动鼠标就能按到效果，输入的字符越多，效果越明显；</li>
<li>如果未输入任何字符，那么将会提示输入；</li>
</ol>
</blockquote>
<h4 id="测试题-19"><a href="#测试题-19" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的鼠标及键盘事件，写出下面一个小程序：</p>
<blockquote>
<ol>
<li>能通过鼠标及键盘控制一个div的运动；</li>
<li>需要将scroll因素考虑在移动的范围内；</li>
<li>需要避免连续按住不放时产生的卡顿现象（利用定时器）；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件中级》"><a href="#《JS事件中级》" class="headerlink" title="《JS事件中级》"></a>《JS事件中级》</h3><h4 id="关键词：默认行为、拖拽"><a href="#关键词：默认行为、拖拽" class="headerlink" title="关键词：默认行为、拖拽"></a>关键词：默认行为、拖拽</h4><ul>
<li>默认行为：浏览器自带的一些行为，有些时候需要阻止系统自带的默认行为，加上自己设置的行为；（比如右键菜单-oncontextmenu）<ol>
<li>阻止右键菜单：需要阻止时，直接oncontexmenu函数返回为false即可；自己设置一个菜单，并且在鼠标右键的时候改变display属性，将定制菜单的位置改为鼠标的位置，然后在页面空白处点击的时候（给document加上onclick事件）将定制菜单栏收回；</li>
<li>设置一个只能输入数字的输入框：默认时，在输入框按下按键则会在输入框显示相应字符或者操作。这也是一种默认行为，当onkeydown事件返回为false的时候，则能阻止这种默认行为。结合keyCode和阻止这种默认事件的功能，则可以设计一个能输入数字及特定按钮（如方向键及退格键）功能的小程序；</li>
</ol>
</li>
<li>拖拽：保证鼠标的位置及被拖动元素的相对位置不变，需要注意的点如下：<ol>
<li>应该是只有杂鼠标按下之后才能移动，鼠标抬起时移动停止；</li>
<li>对于鼠标快速移动时可能移出元素范围带来的移动异常，将移动事件加在document上即可解决；</li>
<li>当移动出视窗时释放鼠标按键，仍然能够移动，为了解决这个问题，需要将鼠标释放按钮事件也加在document上；</li>
<li>在Firefox中拖拽空元素的时候会出现重影，这也是FF中的一种默认事件，可以用返回false的方法来组织这个bug；</li>
<li>被拖拽元素被拖出视窗范围，这时候就可以判断来阻止元素被拖出视窗；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码-19"><a href="#实例及代码-19" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/zBRKYz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBRKYz/" target="_blank" rel="external">JavaScript21</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-20"><a href="#测试题-20" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，制作一个小程序：</p>
<blockquote>
<ol>
<li>在整个页面组织右键菜单的默认属性；</li>
<li>自己定制一个菜单栏，里面可以包括一些链接之类的；</li>
<li>页面空白处单击则菜单栏消失；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件高级应用-01》"><a href="#《JS事件高级应用-01》" class="headerlink" title="《JS事件高级应用-01》"></a>《JS事件高级应用-01》</h3><h4 id="关键词：事件绑定、高级拖拽"><a href="#关键词：事件绑定、高级拖拽" class="headerlink" title="关键词：事件绑定、高级拖拽"></a>关键词：事件绑定、高级拖拽</h4><ul>
<li>事件绑定：attachEvent(name, function)，可以将多个函数加到同一个事件上，在chrome及FF上不兼容，为了兼容需要用到addEventListener（name，function，false）（此属性也不兼容IE9以下的IE浏览器）。所以为了都兼容，应该使用一个判断函数整合这个属性的不同写法，但是要注意addEventListerner属性中的事件是没有“on”的（具体写法可见实例）；</li>
<li>高级拖拽：新增功能———— 1.不拖出父级div或者其他指定对象的区域；2.边缘吸附；3.利用事件捕获来解决在低版本IE下拖拽时会选中文字的问题，setCapture（只兼容IE，功能是将页面的所有事件都集中在加了事件捕获的对象上），与之相应的为releaseCapture，即解除对象的捕获；</li>
</ul>
<h4 id="代码及实例-1"><a href="#代码及实例-1" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/qNoPxz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/qNoPxz/" target="_blank" rel="external">JavaScript22</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>这个小程序所具有的功能：</p>
<blockquote>
<ol>
<li>事件绑定，点击内部的div后会弹出两次会话框；</li>
<li>可以在指定外框自由移动；</li>
<li>不会产生移动时文字的选中；</li>
<li>兼容低版本的IE浏览器；</li>
</ol>
</blockquote>
<h4 id="测试题-21"><a href="#测试题-21" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，重写事件绑定及完美拖拽的小程序，特别注意以下两点：</p>
<blockquote>
<ol>
<li>兼容性问题；</li>
<li>代码重用性；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件高级应用-02》"><a href="#《JS事件高级应用-02》" class="headerlink" title="《JS事件高级应用-02》"></a>《JS事件高级应用-02》</h3><h4 id="关键词：带框拖拽、自定义滚动条"><a href="#关键词：带框拖拽、自定义滚动条" class="headerlink" title="关键词：带框拖拽、自定义滚动条"></a>关键词：带框拖拽、自定义滚动条</h4><ul>
<li>带框拖拽：预先设置一个样式，按下鼠标产生一个div并赋予样式，div的大小与框相同，位置与框相同，移动时只移动框，松开鼠标时才移动框，并且将产生的div移出；</li>
<li>自定义滚动条：控制对象的大小、透明度、文字滚动等；</li>
</ul>
<h4 id="代码及实例-2"><a href="#代码及实例-2" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/wWmQjx/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/wWmQjx/" target="_blank" rel="external">JavaScript23</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>这个小程序具有的功能：</p>
<blockquote>
<ol>
<li>利用滚动条能控制div的大小；</li>
<li>div具有带框移动的功能；</li>
</ol>
</blockquote>
<h4 id="测试题-22"><a href="#测试题-22" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的知识，制作一个自定义的滚动条：</p>
<blockquote>
<ol>
<li>自定义滚动条样式；</li>
<li>能实现通过滚动来控制文字上下翻转的功能；</li>
</ol>
</blockquote>
<hr>
<h3 id="《Ajax基础》"><a href="#《Ajax基础》" class="headerlink" title="《Ajax基础》"></a>《Ajax基础》</h3><h4 id="关键词：服务器、字符集编码、缓存、eval、Ajax原理"><a href="#关键词：服务器、字符集编码、缓存、eval、Ajax原理" class="headerlink" title="关键词：服务器、字符集编码、缓存、eval、Ajax原理"></a>关键词：服务器、字符集编码、缓存、eval、Ajax原理</h4><ul>
<li>服务器：有两种含义：一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器；运行以上软件的计算机，或称为网络主机（Host）。（我自己用的服务器程序为XAMPP）</li>
<li>字符集编码：把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递；</li>
<li>缓存：存储在本地电脑中的资料，通过url来识别是否为同一网站，所以为了避免缓存带来不好的影响，可以通过加上一个时间戳的方式来解决这个问题；</li>
<li>eval：将语句解析成js能够识别的内容；</li>
<li>Ajax原理：<ol>
<li>http请求分为两种方式： get方式及post方式；前者提交的数据直接加在网址上，而后者通过http content传递；前者长度有限制（容量小，不适合传输数据），后者可传输容量较大的数据；前者安全性较差，后者安全性较好；前者有缓存，后者无缓存；因此前者适合获取数据，后者适合上传数据；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例-3"><a href="#代码及实例-3" class="headerlink" title="代码及实例"></a>代码及实例</h4><p>由于本节需要用到本地服务器，因此这里就不上传实例了。</p>
<h4 id="测试题-23"><a href="#测试题-23" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，完成小程序：</p>
<blockquote>
<ol>
<li>搭建本地服务器（我自己用的是XAMPP);</li>
<li>结合已有的ajax文件（如果自己不会写，可参照下节内容中的源代码），新建一个html及txt文本来创建一个实时更新显示内容的页面（通过按钮）；</li>
</ol>
</blockquote>
<hr>
<h3 id="《Ajax中级》"><a href="#《Ajax中级》" class="headerlink" title="《Ajax中级》"></a>《Ajax中级》</h3><h4 id="关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText"><a href="#关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText" class="headerlink" title="关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText"></a>关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText</h4><ul>
<li>编写Ajax对象：<ol>
<li>创建Ajax对象；</li>
<li>连接到服务器；</li>
<li>发送请求；</li>
<li>接收返回值；</li>
</ol>
</li>
<li>注意：在JS中利用没有定义的变量时会弹出错误，而利用没有定义的属性时则会提示undifined；</li>
<li>接收状态值（readyState）：<ol>
<li>0 （未初始化）还没有调用open（）方法；</li>
<li>1 （载入）已调用send（）方法，正在发送请求；</li>
<li>2 （载入完成）send（）方法完成，已收到全部相应内容；</li>
<li>3 （解析）正在解析相应内容；</li>
<li>4 （完成）相应内容解析完成，可以在客户端调用了；</li>
</ol>
</li>
<li>http状态码（status）：最常见的为200，表示读取成功；</li>
<li>onreadystatechange: 表示返回状态；</li>
<li>responseText: 读取的文件内容；</li>
</ul>
<h4 id="实例及代码-20"><a href="#实例及代码-20" class="headerlink" title="实例及代码"></a>实例及代码</h4><p>由于本节也需要在本地服务器运行，所以只能讲代码贴出来，ajax代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">url, fnsucc, fnfail</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. Set a new ajax object:</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">        <span class="keyword">var</span> oAjax=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> oAjax=<span class="keyword">new</span> ActivaXObject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Get connected:</span></span><br><span class="line">    oAjax.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Send the request:</span></span><br><span class="line">    oAjax.send();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Get data back:</span></span><br><span class="line">    oAjax.onreadystatechange=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oAjax.status==<span class="number">200</span>)&#123;</span><br><span class="line">                fnsucc(oAjax.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fnfail)&#123;</span><br><span class="line">                    fnfail(oAjax.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="测试题-24"><a href="#测试题-24" class="headerlink" title="测试题"></a>测试题</h4><p>由于本节所学的内容比较单一，所以根据本节所学的内容自己手写一个完整的Ajax程序。</p>
<hr>
<h3 id="《JS面向对象基础-01》"><a href="#《JS面向对象基础-01》" class="headerlink" title="《JS面向对象基础-01》"></a>《JS面向对象基础-01》</h3><h4 id="关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、"><a href="#关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、" class="headerlink" title="关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、"></a>关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、</h4><ul>
<li>面向对象：对象是一个整体，对外提供一些操作；面向对象指的是使用对象时只关注对象提供的功能，而不关注其内部细节；（这是一种通用思想，而非只在编程中适用）</li>
<li>JS中面向对象：简称OOP，具有以下三个特点：<ol>
<li>抽象：抓住主要问题；</li>
<li>封装：不考虑内部实现，只考虑功能使用；</li>
<li>继承：从已有对象上，继承出新的对象，可以最大限度重用现有代码，包括多重继承（继承多个对象的功能）和多态；</li>
</ol>
</li>
<li>对象组成：包括方法和属性<ol>
<li>方法：和函数类似，函数是自由的，但方法具有归属的对象，这两者都是过程量，是动态的；</li>
<li>属性：和变量类似，变量时自由的，但属性具有归属的对象，这两者都是状态量，是静态的；</li>
</ol>
</li>
<li>this：当前的方法属于谁就指向谁；</li>
<li>注意：不能在系统对象中随意附加方法、属性，否则会覆盖已有方法、属性；</li>
<li>object对象：空白对象；</li>
<li>构造函数：用于构造一个对象的函数，功能与普通函数一样；</li>
<li>工厂方式：创建空白对象，加工对象，返回对象；缺点：创建时没有’new’，函数重复导致资源浪费；</li>
</ul>
<h4 id="实例及代码-21"><a href="#实例及代码-21" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="304" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJQmL/?height=304&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJQmL/" target="_blank" rel="external">JavaScript26</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-25"><a href="#测试题-25" class="headerlink" title="测试题"></a>测试题</h4><p>用工厂方式重写一个面向对象的程序。</p>
<hr>
<h3 id="《JS面向对象基础-02》"><a href="#《JS面向对象基础-02》" class="headerlink" title="《JS面向对象基础-02》"></a>《JS面向对象基础-02》</h3><h4 id="关键词：new、原型-prototype-、类和对象、对象命名规范"><a href="#关键词：new、原型-prototype-、类和对象、对象命名规范" class="headerlink" title="关键词：new、原型(prototype)、类和对象、对象命名规范"></a>关键词：new、原型(prototype)、类和对象、对象命名规范</h4><ul>
<li>new：通过new+构造函数来构造对象，可以理解为“new”会先通过系统在函数内部创建<code>var this=new Object()</code>这个对象，然后在最后的时候又自动返回<code>return this</code>这个对象，这样理解之后，面向对象的方式和工厂方式原理上也是一样的；</li>
<li>原型(prototype)：可以理解为css中的class， 能够同时给多个对象加方法；</li>
<li>类和对象：前者不具备实际功能，而后者具有，它们之间的关系就相当于模子和产品的关系；为了同时给多个对象加方法，那么就需要在类上面加原型，既可以给系统对象加也可以在创建的对象加；</li>
<li>注意：用构造函数加属性，用原型加方法。区别于工厂方式，这种方式叫做混合的构造函数/原型方式，简称混合方式构造对象；</li>
<li>对象命名规范：为了和系统对象保持一致，自己构造出来的对象命名时最好也保持首字母大写；</li>
</ul>
<h4 id="实例及代码-22"><a href="#实例及代码-22" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/OXkrVB/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/OXkrVB/" target="_blank" rel="external">JavaScript27</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-26"><a href="#测试题-26" class="headerlink" title="测试题"></a>测试题</h4><p>用混合方式重写一个面向对象的小程序。</p>
<hr>
<h3 id="《JS面向对象实例》"><a href="#《JS面向对象实例》" class="headerlink" title="《JS面向对象实例》"></a>《JS面向对象实例》</h3><h4 id="关键词：将面向过程的函数改写成面向对象的形式"><a href="#关键词：将面向过程的函数改写成面向对象的形式" class="headerlink" title="关键词：将面向过程的函数改写成面向对象的形式"></a>关键词：将面向过程的函数改写成面向对象的形式</h4><ul>
<li>改写：<ol>
<li>不能有函数嵌套，但可以有全局变量；</li>
<li>将onload改写成构造函数，将全局变量改写成属性，将函数改写成方法；</li>
<li>debug，主要容易出现在this、事件、闭包及传参上；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例-4"><a href="#代码及实例-4" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/jAxqQa/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/jAxqQa/" target="_blank" rel="external">JavaScript28</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-27"><a href="#测试题-27" class="headerlink" title="测试题"></a>测试题</h4><p>按照这节课所学的内容，利用面向对象的方式重写选项卡或者之前写过的任何一个程序。</p>
<hr>
<h3 id="《JS面向对象高级》"><a href="#《JS面向对象高级》" class="headerlink" title="《JS面向对象高级》"></a>《JS面向对象高级》</h3><h4 id="关键词：Json方式、命名空间、继承、call、引用、系统对象"><a href="#关键词：Json方式、命名空间、继承、call、引用、系统对象" class="headerlink" title="关键词：Json方式、命名空间、继承、call、引用、系统对象"></a>关键词：Json方式、命名空间、继承、call、引用、系统对象</h4><ul>
<li>Json方式面对对象：用Json的方式来实现对象虽然比较简单，但是如果对象超过一个，那么又回到了之前写对象的方法。这种方式也有人叫做单体方式。</li>
<li>命名空间：在不同的Json中写具有相同名字的函数，可以让具有相同名字的函数同时工作；</li>
<li>继承：能够继承父级的属性和方法；</li>
<li>call：通过call的方式调用属性时，如果call传入的参数，则参数会替换掉函数中的this；</li>
<li>引用：通过<code>=</code>号使数组、方法或者其他相等的时候，系统会将等号两边指向同一内存位置，所以不管是针对谁做出改变，最终的结果是两者都会发生改变。比如：有两个数组A和B，其中A中有1，2，3，三个变量，又有A=B，这时候如果在B中push一个变量4，那么数组A中也会存在这个变量。为了解决这个问题，可以利用循环将A中的变量一个个都push到数组B中；</li>
<li>总结：属性的继承利用call，方法的继承利用循环；</li>
<li>系统对象：本地对象（非静态对象，如Object/Function/Array/String等），内置对象（静态对象，如Global/Math）,宿主对象（由浏览器提供，如BOM/DOM）；</li>
</ul>
<h4 id="实例及代码-23"><a href="#实例及代码-23" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJpzZ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJpzZ/" target="_blank" rel="external">JavaScript29</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-28"><a href="#测试题-28" class="headerlink" title="测试题"></a>测试题</h4><p>利用继承的特点，用面向对象的方式重写拖拽的小程序。</p>
<hr>
<h3 id="《BOM应用》"><a href="#《BOM应用》" class="headerlink" title="《BOM应用》"></a>《BOM应用》</h3><h4 id="关键词：BOM基础"><a href="#关键词：BOM基础" class="headerlink" title="关键词：BOM基础"></a>关键词：BOM基础</h4><ul>
<li>BOM基础：<ol>
<li>window.open(a, b) 打开新的页面，b表示是打开的新窗口是显示在本页还是新的页面；</li>
<li>window.close() FF中不能用这个去关闭非脚本打开的窗口；</li>
<li>document.write() 先清空，然后写入；</li>
<li>window.navigator.userAgent 表示的是浏览器的类型及版本；</li>
<li>window.location 表示当前页面的地址；</li>
<li>document.documentElement.clientWidth及document.documentElement.clientHeight：表示可视区的宽度及高度；</li>
<li>document.documentElement.scrollTop(IE)及document.body.scrollTop（chrome）：表示滚动条高度；</li>
<li>window.onscroll及window.onresize分别表示在页面滚动及更改窗口尺寸时发生的事件；</li>
<li>alert/confirm/prompt: 系统对话框；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例-5"><a href="#代码及实例-5" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="250" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/dXZRXY/?height=250&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/dXZRXY/" target="_blank" rel="external">JavaScript30</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-29"><a href="#测试题-29" class="headerlink" title="测试题"></a>测试题</h4><p>由于本节课所学的大部分为基础知识，应用都较简单，所以可重写上例中的小程序，巩固知识点。</p>
<hr>
<h3 id="《COOKIES基础与应用》"><a href="#《COOKIES基础与应用》" class="headerlink" title="《COOKIES基础与应用》"></a>《COOKIES基础与应用》</h3><h4 id="关键词：cookie、setDate-、读取cookie、删除cookie"><a href="#关键词：cookie、setDate-、读取cookie、删除cookie" class="headerlink" title="关键词：cookie、setDate()、读取cookie、删除cookie"></a>关键词：cookie、setDate()、读取cookie、删除cookie</h4><ul>
<li>cookie：<ol>
<li>页面用来保存信息；</li>
<li>同一个网站共享一套cookie；</li>
<li>数量、大小有限（一般数量小于50，大小不超过4k或10k）；</li>
<li>有过期时间；（expires）</li>
<li>使用方式<code>document.cookie=&#39;name=value&#39;</code>;</li>
</ol>
</li>
<li>setDate(): 相对于getDate()获取系统时间，setDate()能够设置对象的时间；</li>
<li>读取cookie：需要利用字符串分割，具体见例子；</li>
<li>删除cookie：设置需要删除的cookie的有效期为’-1’即可；</li>
</ul>
<h4 id="实例及代码-24"><a href="#实例及代码-24" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="224" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJOBL/?height=224&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJOBL/" target="_blank" rel="external">JavaScript31</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-30"><a href="#测试题-30" class="headerlink" title="测试题"></a>测试题</h4><p>在FireFox浏览器的环境下尝试使用cookie的相关功能，具体写法可参考上面的实例。</p>
<hr>
<h3 id="《JS中的正则表达式》"><a href="#《JS中的正则表达式》" class="headerlink" title="《JS中的正则表达式》"></a>《JS中的正则表达式》</h3><h4 id="关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test"><a href="#关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test" class="headerlink" title="关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test"></a>关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test</h4><ul>
<li>正则基础：了解正则表达式需要从字符串操作开始，最常见的字符串操作如下<ol>
<li>name.search(a): 表示的是在name中查找a，并返回a的位置；如果不存在则返回-1；</li>
<li>name.substring(value1, value2): 表示在name中截取从第value1到value2（不包括结束位置）的字符；如果只给一个参数，则返回至最后一位；</li>
<li>name.charAt(value): 表示获取字符串的某一位；</li>
<li>name.split(s):利用s来切分name，其中s可以是字符串或者符号；</li>
</ol>
</li>
<li>正则表达式：舶来语，表示的是一套规则，这套规则是计算机可识别的；</li>
<li>写法：JS风格（新建对象，然后使用对象），Perl风格（正则最早是出现在perl语言中）；</li>
<li>match: 提取所有复合条件的元素；<code>i</code>表示忽略大小写，<code>g</code>表示全局搜索；</li>
<li>replace：替换复合要求的元素，用法为：<code>name.replace(a, b)</code>表示将name中的a替换成b（如果有多个，则只替换第一个，除非用正则匹配全局），常用于敏感词过滤；</li>
<li>元字符：用<code>[]</code>表示，<code>[abc]</code>表示a、b、c中的任意一个，<code>[a-z]</code>表示从所有字母，数字同理。<code>[^a]</code>表示出了a；</li>
<li>转义字符：<ol>
<li>\d  表示数字                    \D  表示除了数字</li>
<li>\w  表示英文、数字和下划线       \W  表示除了英文、数字和下划线</li>
<li>\s  空白字符                    \S  表示除了空白字符</li>
<li>.   表示任意字符，很容易出错，不建议使用；</li>
</ol>
</li>
<li>量词：表示个数，用{}<ol>
<li>{n}      表示正好出现n次；</li>
<li>{n, m}   最少n次，最多m次；</li>
<li>{n, }    最少n次，最多无限；</li>
<li><ul>
<li>相当于{1，}，即最少出现1次；</li>
</ul>
</li>
<li>?       相当于{0，1}，即可有可无；</li>
<li><ul>
<li>相当于{0，}，表示可有可无，而且出现多少次都无所谓，很容易出错，不建议使用；</li>
</ul>
</li>
</ol>
</li>
<li>test：<code>reg.test(name)</code>，用于检测name是否符合reg所表示的正则，如果符合则返回true；需要注意的是，只要name一部分符合reg的要求就会返回true，这时候就需要用到<code>^</code>及<code>$</code>，分别表示行首和行尾；</li>
</ul>
<h4 id="实例及代码-25"><a href="#实例及代码-25" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="335" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJrPO/?height=335&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJrPO/" target="_blank" rel="external">JavaScript32</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="external">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h4 id="测试题-31"><a href="#测试题-31" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的正则表达式，制作一个这样的小程序：</p>
<blockquote>
<ol>
<li>能够识别输入的数字是否为电话号码；</li>
<li>如果不是电话号码则弹出“输入的不是电话号码”；</li>
<li>如果符合要求则弹出“输入成功”。</li>
</ol>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从开始学习这门课程到今天正好两个月。当时虽然也已经花了将近一个月的时间去学习JS，但还是感觉很茫然，直到开始学习这门课程。最初是看视频跟着老师的讲解一步一步的写程序，学习完一遍以后，自知很多知识点掌握的还不是很牢固，然后果断作出了复习一遍，重写所有程序的决定。复习的时候，先是重新看一遍老师的讲解，巩固基础知识，然后将当节课的知识点尽量综合起来放在一个程序里面重写出来，这个过程就是举一反三的过程。举几个例子：</p>
<blockquote>
<ol>
<li>第五节课制作日历，第一遍写的时候没有写任何布局相关的内容，重写时所有的css、js和html都是独立完成；</li>
<li>第九节课制作超酷时钟，同样关系到布局问题，而且首次结合图床来写程序；</li>
<li>第十三节课DOM高级应用，将这节课中所学的所有功能都集中在了一起，并且增加了按要求排序这个课程中并没有讲到的功能，而且没有bug；</li>
<li>第十八节课仿flash运动，这个小程序是目前写过的功能最多的程序了，而且实现过程并非照搬老师的讲解，实现的效果也基本一致；</li>
<li>……</li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在复习的过程中，对知识点的理解和掌握程度远远超过第一次学习。这个过程中积攒了些许经验，希望能和大家分享：</p>
<blockquote>
<ol>
<li>写程序之前先理清逻辑关系，否则debug的时候很难发现问题；</li>
<li>动手写比脑子想更重要，看似很简单很套路的知识点，如果自己不去套路一遍，这个套路就不属于你；</li>
<li>有足够的耐心。debug是个很烦人却又很让人兴奋的过程，程序成功运行的瞬间，所有debug的烦恼都消失了；</li>
<li>善用搜索引擎。前端发展了这么多年，我们所踩得坑前人都已经踩烂了，只要有疑问，直接搜关键词基本上都能搜出相关的博客或者问题；</li>
<li>不要好高骛远。基础知识永远不会过时。</li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;毋庸置疑，本课程非常适合新手学习，但同时也不难发现课程中很少触及真正基础的知识，而且后面还有一部分内容并没有讲到。下一步，我将通过书本继续巩固基础知识，同时开始学习JS框架，准备开始做几个简单的项目。这些内容都会在之后的博客中更新。<br>&nbsp;&nbsp;&nbsp;&nbsp;最后，作为一个初学者，我深知在学习过程中的种种疑惑和迷茫，即使在现在，这份心情依然存在。然而，只要不放弃努力，就始终在进步，目标终将会越来越近。<br> </p><h4>&nbsp;&nbsp;&nbsp;&nbsp;<em> The world is a fine place and worth fighting for !</em></h4><p></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从5月25日开始开始学习，用了将近一个月的时间将&lt;a href=&quot;http://study.163.com/course/courseMain.htm?courseId=224014&quot;&gt;视频课程&lt;/a&gt;过了一遍，对比W3school及另外一套课程，这个课程给我的体验是整体进度设置很合理，Blue老师循循善诱，讲课风格非常适合新手学习。为了更好的掌握JavaScript的内容，下文将对每一章节做对应的总结与复习，并有相应的小测试来巩固复习。本文内容适合所有正在学习此课程的同学。&lt;b&gt;对于本课程或者本博客有任何问题，非常欢迎给我发邮件，我会尽我所能回答你的问题。&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML和css基础知识汇总（长期更新）</title>
    <link href="http://detachment.club/2016/06/30/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://detachment.club/2016/06/30/HTML和CSS基础知识汇总/</id>
    <published>2016-06-29T16:00:00.000Z</published>
    <updated>2016-08-31T08:27:36.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)；</li>
<li>HTML 不是一种编程语言，而是一种标记语言 (markup language)；</li>
<li>标记语言是一套标记标签 (markup tag)；</li>
<li>HTML使用标记标签来描述网页；</li>
</ul>
<a id="more"></a>
<h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul>
<li>HTML：Hyper Text Markup Language；</li>
<li>标签：h1-h6; p; a; img; hr; strong; big; small; em; i; sub; sup; pre; code; kbd; tt; samp; var; address; abbr; acronym; bdo; blockquote; q; del; ins; map; area; table; tr; td; th; caption; thead; tbody; tfoot; dl; dt; dd; span; form; input; select ; option; textarea; fieldset; legend; optgroup; frameset(不与body同用); iframe; frameborder; object; embed; audio; video;</li>
<li>属性：align; bgcolor; dir；text-decoration; target; name; alt; background; align; rowspan; colspan; cellpadding; cellspacing; frame; raido; checkbox; action; method; selected; rows; cols; label; noresize;</li>
</ul>
<blockquote>
<p>HTML5部分网站上讲的太笼统了，之后在做项目的过程中再做具体的了解，其中canves这个属性被广泛应用；这两天把html和css复习一遍之后开始复习js，同时开始看书+做项目+写博客。按照这种速度的话,下个月底之前应该能够取得很大的进步。</p>
</blockquote>
<h2 id="CSS-部分"><a href="#CSS-部分" class="headerlink" title="CSS 部分"></a>CSS 部分</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets);</li>
<li>样式定义如何显示 HTML 元素;</li>
<li>样式通常存储在样式表中;</li>
<li>把样式添加到HTML4.0中，是为了解决内容与表现分离的问题;</li>
<li>外部样式表可以极大提高工作效率;</li>
<li>外部样式表通常存储在 CSS 文件中;</li>
<li>多个样式定义可层叠为一。</li>
</ul>
<h3 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h3><ul>
<li><strong>派生选择器</strong>：也被称为上下文选择器（contextual selector），根据元素在其位置的上下文关系来定义样式，是的标记更简洁；</li>
<li><strong>id选择器</strong>：用“#”来定义 （注意：id属性只能在每个HTML文档中出现一次）</li>
<li><strong>类选择器</strong>：以一个“.”显示；</li>
<li><strong>属性选择器</strong>：以“[属性]”的方式显示；（还有属性和值选择器）– 对于属性值有多重不同的选择方式，具体可参照w3school上的说明；</li>
<li><strong>背景</strong>：背景色；背景图像（不能继承）；背景重复（background-repeat）；背景定位（background-position–主要是针对当背景是图像的时候使用，如果只出现一个位置信息，则另一个默认为center）；背景关联（background-attachment，可将背景图像固定在可视区域）；</li>
<li><strong>文本</strong>：缩进文本（text-indent：一般来说，可以为所有块级元素应用text-indent，但无法将该属性应用于行内元素，图像之类的替换元素上也无法应用 text-indent 属性。不过，如果一个块级元素（比如段落）的首行中有一个图像，它会随该行的其余文本移动。如果想把一个行内元素的第一行“缩进”，可以用左内边距或外边距创造这种效果。它的值可为<strong>负数或者百分比</strong>。此属性可继承。）；水平对齐（text-align：justify可实现两端对齐——谨慎使用，因为各浏览器增加空间的方式不同造成效果各异；文字间隔（word-spacing）；字母间隔（letter-spacing）；字符转换（text-transform：uppercase、lowercase、capitalize）；文本装饰（text-decoration：underline、overline、line-through及blink；）；空白字符（white-space：pre、nowrap、pre-wrap及pre-line）；文本方向（direction：ltr、ltr；）</li>
<li><strong>字体</strong>：五种通用字体（font-family）——Serif、Sans-serif、Monospace、Cursive和Fantasy；字体风格（font-style：normal、italic和oblique）；字体变形（font-variant：小型大写字母）；字体加粗（font-weight：bold、bolder、lighter等）；字体大小（font-size：px、em和百分比，其中第一个是静态测量单位，后两者则是相对测量单位）；</li>
<li><strong>链接</strong>：链接的四种状态（link、visited、hover和active，设置时需要注意顺序问题。通过改变连接访问前后及鼠标是否悬停在链接上的属性设置的不同来达到改变样式的目的）；</li>
<li><strong>列表</strong>：列表类型（list-style-type）、列表项图像（list-style-image）、列表标志位置（list-style-position）（注意，这些属性一般都是作用在ul或者ol上的，但根据网站上的例子可以知道有时——比如list-style-image也可以施加到list上。）</li>
<li><strong>表格</strong>：表格边框（border），折叠边框（border-collapse：将表格边框折叠为单一边框），表格文本对齐（水平方向：text-align；垂直对齐方式：vertical-align），表格内边距（padding），表格颜色（background-color）；</li>
<li><strong>轮廓</strong>：（outline，区别于border，轮廓指的是边缘外框的外围，可以起到突出元素的作用。）</li>
<li><strong>框模型</strong>：<img src="http://www.w3school.com.cn/i/ct_boxmodel.gif" alt="image">元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。背景应用于由内容和内边距、边框组成的区域。内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表设置外边距和内边距。在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li>
<li><strong>内边距（padding）</strong>：属性定义元素边框与元素内容之间的空白区域。CSSpadding属性定义元素的内边距。padding属性接受长度值或百分比值，<strong>但不允许使用负值</strong>。单位可以有 <a href="https://www.w3.org/Style/Examples/007/units.en.html#units" target="_blank" rel="external">EM, PX, PT, CM</a>。如果使用百分比设置的内边距，那么这个百分比的基数是<strong>其父元素的width来计算的</strong>，这一点也同样适用在外边距（而且不管是左右边距还是上下边距）。</li>
<li><strong>边框（border）</strong>：围绕元素内容和内边距的一条或多条线，允许规定元素边框的样式、宽度和颜色；CSS 规范指出，边框绘制在“元素的背景之上”。这很重要，因为有些边框是“间断的”（例如，点线边框或虚线框），元素的背景应当出现在边框的可见部分之间。CSS2 指出背景只延伸到内边距，而不是边框。后来 CSS2.1 进行了更正：元素的背景是内容、内边距和边框区的背景。边框的样式（border-style：一共有十种，效果各不相同，而且可以分别为不同的边框设置不同的样式）；边框宽度（border-width：可以指定长度或者使用thin，medium或者thick中的任意一个，但是后面这三个关键词的具体宽度可能会根据不同的用户代理有不同的值）。因此，如果希望边框出现，就必须声明一个边框样式。然后设置边框的宽度才有意义。边框的颜色（border-color）：默认的边框颜色是元素本身的前景色。如果没有为边框声明颜色，它将与元素的文本颜色相同。另一方面，如果元素没有任何文本，假设它是一个表格，其中只包含图像，那么该表的边框颜色就是其父元素的文本颜色（因为 color 可以继承）。这个父元素很可能是body、div 或另一个 table。透明边框（transparent）：CSS2引入了边框颜色值transparent。这个值用于创建有宽度的不可见边框。</li>
<li><strong>外边距（margin）</strong>：围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。这个属性接受任何长度单位、百分数值甚至负值。margin的默认值是 0，所以如果没有为margin声明一个值，就不会出现外边距。但是，在实际中，浏览器对许多元素已经提供了预定的样式，外边距也不例外。块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。</li>
<li><strong>外边距合并</strong>：当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。除此之外，父元素与子元素之间，空块元素，也会发生合并，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="external">具体可参考MDN上的内容</a>。<strong>（这个点可以写一篇博客了。）</strong></li>
<li><strong>定位和浮动</strong>：1. 一切都为框-块框、行内框或者无名块框；2. css中有三种基本的定位机制——普通流、浮动和绝对定位，默认都为普通流中定位；3. 位置属性（position）：包括static、relative、absolute和fixed。具体情况可以参考<a href="http://www.w3schools.com/css/css_positioning.asp" target="_blank" rel="external">w3school上面关于position的内容</a>。<strong>这个相关内容也可以写一篇剪短的博客了，:-D。</strong></li>
<li><strong>浮动（float）</strong>：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。<strong>浮动及浮动清除理解起来也有难度啊，搞清楚后也可以写博客了</strong>。<br>(关于浮动的博客已写，但是还是没有弄的太明白，之后再买书看吧）</li>
<li><strong>元素选择器</strong>：最常见的为元素选择器，在w3c中元素选择器也叫作类型选择器（type selector），类型选择器匹配文档语言元素类型的名称，可以匹配文档树中该元素类型的每一个实例。类型选择其也可适用在XML文档中。</li>
<li><strong>选择器分组</strong>：可以把具有同样样式的元素放在样式的左边，<strong>并且用逗号隔开</strong>，选择器的数量没有限制，可以有任意多组；如：h1，p，span { corlor：white；}；</li>
<li><strong>通配符选择器</strong>：css2中引入了一种新的简单选择器，叫做通配符选择器（universal selector），符号为*，可以与任何元素匹配；</li>
<li><strong>声明分组</strong>：对于同一个元素的不同样式，可以将样式声明在此元素后面，<strong>并用分号隔开</strong>，例如：h1 {corlor：black；background：yellow；font-size：strong；}；</li>
<li><strong>类选择器</strong>：要应用样式而不考虑具体设计的元素，最常用的方法就是使用类选择器，它允许以一种独立于文档元素的方式来指定样式；使用语法为：.className {porperty: value; };类选择器可结合元素选择器，选择出某一种元素中具有某个类名的个体，然后赋予其属性和值，例如：p.important {corlor：red；}；多类选择器指的是一个元素可以有多个类，类与类之间用空格分隔，例如：<p class="important warning">其中类名无顺序之分，通过把两个类选择器链接在一起，可以选择出同时包含这些类名的元素；</p></li>
<li><strong>ID选择器</strong>：ID选择器允许一种独立于文档元素的方式来指定样式，例如：#intro {font-size：14px；}指的是ID为intro的元素的字体大小为14px；与类选择器不同的是，ID选择器：1.只能在文档中出现一次；2. 不能结合使用；3. ID能包含更多含义；<strong>需要注意的是：选择器是区分大小写的，因此写的时候务必要注意！</strong></li>
<li><strong>属性选择器</strong>：属性选择器可以根据元素的属性及属性值来选择元素。属性选择器是在css2中引入的。如：[title] {color:red} （表示：把含有标题的所有元素变成红色）；再如：a[href] {color:red} (表示对有href属性的锚应用属性)；还可以结合起来使用，如：a[href][title] {color:red} (表示将同时具有href和title属性的锚的文本设置成红色）；除此之外，还可以规定具体的属性值，例如：<code>a[href=&quot;http://www.w3school.com.cn/about_us.asp&quot;] {color: red;}</code>（表示只有带有超链接且了解为上述的时候才会变红），而且每个属性选择器都可以对相应的属性赋值；而且需要注意，此时选择器中的属性值和必须完全匹配（注意：如果需要选择不完全匹配，则可以用约等号来选择，如：p[class~=”important”] {color: red;}）；字串匹配属性选择器，在css2完成之后发布，可以匹配属性值以某些字符串开头、结尾或者只是包含的情况，具体见<a href="http://www.w3school.com.cn/css/css_selector_attribute.asp" target="_blank" rel="external">字串属性选择器</a>; 特殊属性选择器，如<code>*[lang|=&quot;en&quot;] {color: red;}</code>，表示只选择lang属性等于en或者以en-开头的所有元素；（这种用法常见于匹配语言值）。</li>
<li><strong>后代选择器（descendant selector）</strong>，又称为包含选择器；比如<code>h1 em {color:red;}</code>，需要注意的是，后代选择器中两个元素之间的层级间隔可以是无限的（区别于后面要讲到的子元素选择器）；</li>
<li><strong>子元素选择器（Child selector）</strong>：只能选择作为某元素子元素的元素。比如下面的例子：<code>h1 &gt; strong {color:red;}</code>，子结合符为“&gt;”，结合符两边的空格是可选的；</li>
<li>相邻兄弟选择器（Adjacent sibling selector）：可选择紧接在一个元素后面的元素，且两者有相同的父元素；写法如下：<code>h1 + p {margin-top:50px;}</code>，表示的是“选择紧接在h1元素后面的段落增加边距，并且这两者有相同的父元素”；相邻兄弟选择器作用的对象是“+”号后面的元素，对前一个元素没有影响；</li>
<li><strong>伪类（Pseudo-classes）</strong>：用于向某些选择器添加特殊的效果；比如超链接中的a:link, a:visited, a:hover, a:active,(注意超链接使用伪类的时候有顺序问题）；:focus 伪类用于引起注意，一般用于<a href="http://www.w3school.com.cn/tiy/t.asp?f=csse_link_focus" target="_blank" rel="external">输入框</a>；除此之外，还有:first-child, :lang等伪类；其中:first-child伪类表示用来选择某元素的第一个子元素；</li>
<li><strong>伪元素（Pseudo-elements）</strong>：用于向某些选择器设置特殊效果；语法为：<code>selector:pseudo-element{property:value;}</code>，主要有<code>:first-line, :first-letter</code>, 在css2中引入了：<code>:before, :after</code>，表示的是在某元素前面（后面）插入新内容（这一点在清除浮动那一章节有重点应用）；</li>
<li><strong>css水平对齐</strong>：1. 使用margin属性（将左边距和右边距都设置为auto，则左右均等分配可用外边距，达到居中的效果。注意：如果宽度为100%，对齐则没有效果）；2. 利用Position属性（当使用绝对定位属性来定位时，元素将从正常流中删除，从而可能产生交叠元素）；3. 使用float属性进行左右对齐；<strong>注意：使用所有属性进行对齐时都应该声明<code>!DOCTYPE html</code>，否则在IE8及以下版本会在右侧增加17px的外边距（为滚动条预留空间）。</strong></li>
<li><strong>css尺寸（Dimension）</strong>：尺寸属性允许控制元素的高度和宽度。同样，也允许增加行间距。除了width，height之外，还有max-height，min-height，max-width，min-height，line-height等；且这些尺寸都可以用像素、百分比来设置；</li>
<li><strong>css分类（Classification）</strong>：css分类属性允许规定如何以及在何处显示元素；有inline，block等，其实就是display属性的值，然后这个值就和css的布局有很大的关联，同样影响布局的还有float以及position，它们之间的关系见我之前写的一篇博客<a href="http://detachment.club/2016/06/27/Float,%20position%20and%20display%20in%20CSS/">Float, Position and Display in CSS</a>;本节还讲到了一个很有意思的属性：cursor，用来实现不同 的光标，使用语法为<code>element {cursor:value; }</code>；</li>
<li><strong>导航栏</strong>：实现导航栏的关键在于对浮动的理解，其他属性都比较简单，实现过程可见：<a href="http://www.w3school.com.cn/css/css_navbar.asp" target="_blank" rel="external">导航条的实现</a>；</li>
<li><strong>图片库</strong>：其实也不是什么图片库，就是把相同的布局，运用在了几张尺寸一样的图片上罢了。在设定任何css属性之前，都需要认真弄清楚需求，一步一步的将布局分解到每一个<code>div</code>中，然后思考每个<code>div</code>中的布局，最终形成整体布局。</li>
<li><strong>图像透明</strong>：属性为<code>opacity; filter:alpha(opacity=value)</code>，如果需要用<code>:hover</code>属性来设置鼠标移入之后的效果，那么一定要声明<code>&lt;!DOCTYPE html&gt;</code>，否则不能应用在除了a以外的其他元素；</li>
<li><strong>css2媒介类型</strong>：媒介类型允许定义以何种媒介来提交文档，文档被显示在显示器、纸媒介或者听觉浏览器上等等；语法为<code>@media class</code>，类别中有screen、print、tv、handheld等等（然后就出现了Bootstrap的自适应？）</li>
</ul>
<blockquote>
<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><h4 id="本文内容主要来源为w3school，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。"><a href="#本文内容主要来源为w3school，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。" class="headerlink" title="本文内容主要来源为w3school，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。"></a>本文内容主要来源为<a href="http://www.w3school.com.cn/index.html" target="_blank" rel="external">w3school</a>，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。</h4></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTML部分&quot;&gt;&lt;a href=&quot;#HTML部分&quot; class=&quot;headerlink&quot; title=&quot;HTML部分&quot;&gt;&lt;/a&gt;HTML部分&lt;/h2&gt;&lt;h3 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTML 指的是超文本标记语言 (Hyper Text Markup Language)；&lt;/li&gt;
&lt;li&gt;HTML 不是一种编程语言，而是一种标记语言 (markup language)；&lt;/li&gt;
&lt;li&gt;标记语言是一套标记标签 (markup tag)；&lt;/li&gt;
&lt;li&gt;HTML使用标记标签来描述网页；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://detachment.club/tags/CSS/"/>
    
      <category term="HTML" scheme="http://detachment.club/tags/HTML/"/>
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Float, Position and Display in CSS</title>
    <link href="http://detachment.club/2016/06/27/Float,%20position%20and%20display%20in%20CSS/"/>
    <id>http://detachment.club/2016/06/27/Float, position and display in CSS/</id>
    <published>2016-06-26T16:00:00.000Z</published>
    <updated>2016-07-04T02:24:08.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;目前是第二遍学习CSS，第一遍学习的时候只是看了一遍教材，当时感觉还行，但是在之后学习JS的过程中就愈发感觉到没有学好这一章节的严重性，所有在第二遍学习的时候，一定要将这个知识点彻底的弄清楚才会进入到下一阶段，这也就是为什么我会花3天的时间来弄清楚这个知识点的原因了。<br>&nbsp;&nbsp;&nbsp;&nbsp;为了搞懂这个问题，首先能想到的当然是先多看几遍教材，然后直接Google，搜索到几篇中文博客，之后在StackOverFlow上搜索与Float相关的问题，这一遍下来，搜索的资料让我看了好久，而我所理解的都将在下面的文章中通过图文来表述。</p>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>normal flow:<blockquote>
<p>Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.<br>&nbsp;&nbsp;正常流：在正常流的盒子就属于格式化上下文，而这个格式化上下文可能是块级的也可能是行间的，但这两者不会同时存在。块级别的盒子参与到块级格式化上下文。行间级别的盒子参与到行间格式化上下文。</p>
</blockquote>
</li>
<li>relative positioning:<blockquote>
<p>Once a box has been laid out according to the normal flow or floated, it may shifted relative to this position. This is called relative positioning.<br>&nbsp;&nbsp;相对定位：如果一个盒子按照正常流或者浮动来进行布局，那么它可能会相对这个位置进行移动。这就是所谓的相对定位。</p>
</blockquote>
</li>
<li>floating:<blockquote>
<p>A float is a box that is shifted to the left or right on the current line. The most interesting characteristic of a float is that content may flow along its side(or be prohibited from doing so by the ‘clear’ property).<br>浮动：浮动就是一个被转移到所在行的左边或者右边的盒子。它最有意思的一个性质就是内容会沿着它的边缘流动（或者是因为有‘clear’属性而导致不能沿着它的边缘流动）</p>
</blockquote>
</li>
<li>clear:<blockquote>
<p>This property indicates which sides of an element’s box(es) may not be adjacent to an earlier floating box. The ‘clear’ property does not consider floats inside the element itself or in other block formatting context.<br>&nbsp;&nbsp;清除：这个属性是用来规定元素盒子的哪一边不能和浮动盒子相邻。‘清除’属性不会作用在浮动元素的本身也不会作用在其他块级层叠上下文中。</p>
</blockquote>
</li>
<li>absolute positioning:<blockquote>
<p>In the absolute positioning model, a box is explicitly offset with respect to its containing block. It is removed from the normal flow entirely (it has no impact on later siblings). An absolutely positioned box establishes a new containing block for normal flow children and absolutely (but not fixed) positioned descendants. The containing block for a positioned box is established by the nearest positioned ancestor.<br>&nbsp;&nbsp;绝对定位：在绝对定位模型中，盒子相对其被包含块的偏移量会被明确的设定。在正常流中它会被完全剔除（对之后的兄弟元素没有影响）。绝对定位的盒子会为其中的正常流子元素产生一个包含块以及绝对（不是固定）定位的后代元素。被定位元素盒子的包含块是由最近的被定为的祖先元素来产生。</p>
</blockquote>
</li>
<li>block formatting context:<blockquote>
<p>Floats, absolutely positioned elements, block containers (such as inline-block, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting context for their contents.<br>&nbsp;&nbsp;块级格式化上下文：浮动，绝对定位元素，非块级盒子以及块级盒子但拥有“overflow”属性不是“visible”（除了当那个值已经被传到视窗的时候）的块级包含者（例如行内块、表格单元以及表格头）会为它们的内容产生一个新的块级格式化上下文。</p>
</blockquote>
</li>
<li>Block-level elements and block boxes:<blockquote>
<p>Block-level elements are those elements of the source document that are formatting visually as blocks. The following values of the ‘display’ property make an element Block-level:’block’, ‘list-item’, and ‘table’.<br>Block-level boxes are boxes that participate in a block formatting context. Each Block-level element generates a principal block-level box that contains descendant boxes and generated content and is also the box involved in any positioning scheme.Except for table boxes, which are described in a later chapter, and replaced elements, a block-level box is also a block container box. A block container box either contains only block-level boxes or establishes an inline formatting context and thus contains only inline-level boxes. Not all block container boxes are block-level boxes: non-replaced inline blocks and non-replaced table cells are block containers but not block-level boxes. Block-level boxes that are also block containers are called block boxes.<br>&nbsp;&nbsp;块级元素以及块级盒子：块级元素指的是源文件中按照块级来进行可见的格式化的元素。下面关于“display”属性的值能够让一个元素变成块级元素：block，list-item 以及 table。<br>块级盒子指的是参与块级格式化上下文的盒子。每个块级元素会生成一个自己的块级盒子，这个块级盒子都包含后代盒子和内容，同时也是这个盒子参与到所有的定位中。除了将在下一节中将要讲到的表格盒子以及替代元素，块级盒子也是块包含盒子。块包含盒子中要么只包含块级盒子要么产生一个行内格式化上下文然后只包含行内盒子。并不是所有的块包含盒子都是块级盒子：不可替代的行内快以及不可替代的表格单元都是可以包含块，但并不是块级盒子。块级盒子，同时也是块包含者被称之为块盒子。</p>
</blockquote>
</li>
<li>Relationships between ‘display’, ‘position’, and ‘float’:<blockquote>
<p>The three properties that affect box generation and layout interact as follows:</p>
<ol>
<li>If ‘display’ has the value ‘none’, then ‘position’ and ‘float’ do not apply. In this case, the element generates no box.</li>
<li>Otherwise, if ‘position’ has the value ‘absolute’ or ‘fixed’, the box is absolutely positioned, the computed value of ‘float’ is ‘none’, and display is set according to the table below. The position of the box will be determined by the ‘top’, ‘right’, ‘bottom’ and ‘left’ properties and the box’s containing block.</li>
<li>Otherwise, if ‘float’ has a value other than ‘none’, the box is floated and ‘display’ is set according to the table below.</li>
<li>Otherwise, if the element is the root element, ‘display’ is set according to the table below, except that it is undefined in CSS 2.1 whether a specified value of ‘list-item’ becomes a computed value of ‘block’ or ‘list-item’.</li>
<li>Otherwise, the remaining ‘display’ property values apply as specified.</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="浮动（Float）"><a href="#浮动（Float）" class="headerlink" title="浮动（Float）"></a>浮动（Float）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;浮动属性可以施加给任何元素（只要此元素不是绝对定位），设定浮动属性的元素从普通流中脱离，形成块级格式化上下文（BFC），而普通流中的元素则表现的此浮动元素不存在一样（除了会使行框变短，从而形成文本绕浮动元素的现象）。浮动属性具有以下几个特点：</p>
<ol>
<li>只有横向浮动，没有纵向浮动；（属性值只有none、left及right）</li>
<li>浮动元素的上外边框不能超过其包含块的上边框；</li>
<li>浮动元素脱离普通流后其包含容器将得不到此元素的高度属性（然后就有了关于clearfix方法的讨论）；</li>
<li>更多特点见<a href="https://www.w3.org/TR/CSS21/visuren.html#propdef-float" target="_blank" rel="external">Float说明。</a></li>
</ol>
<h2 id="定位（Position）"><a href="#定位（Position）" class="headerlink" title="定位（Position）"></a>定位（Position）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;定位属性比较好理解，其值有 inhert, static, relative, absolute, fixed 这五种。其中static为默认值，表示没有定位，根据位置出现在文档的普通流中；inhert 为继承父元素的position属性；relative 为相对定位，相对的是其本身在普通流中的位置，而且设定为相对浮动后，元素仍然占据原来普通流中的位置；absolute 为绝对定位，定位基准是最靠近的定位属性不为static的祖先元素，当设置为未绝对定位后，元素的位置就与普通流无关了，同时也不占据文档流空间，而且在设置为绝对定位后，元素会形成一个新的块级格式化上下文（BFC），原来是行内元素的会变成块级元素，而块级元素的宽度则由其本身的内容决定，而不再是默认的100%了；fixed可以说是absolute的特殊类，它也是固定定位，但是它的定位基准为视窗（viewport），除此之外，与决定定位没有区别。</p>
<h2 id="显示类（Display）"><a href="#显示类（Display）" class="headerlink" title="显示类（Display）"></a>显示类（Display）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Display属性主要决定元素是块级元素还是行间元素。属性值主要有block、inline-block、inline、list-item和none。块级元素为垂直排列，块级元素会自动换行，可设置块的宽高信息；行间元素为水平排列，宽高由内容决定，外部设置对其无效。</p>
<h2 id="Float、Position-和-Display-之间的关系："><a href="#Float、Position-和-Display-之间的关系：" class="headerlink" title="Float、Position 和 Display 之间的关系："></a>Float、Position 和 Display 之间的关系：</h2><ol>
<li>如果display的值为none，那么后两者就不会产生作用，也不会有任何的盒子产生；</li>
<li>除此之外，如果元素为absolute或者fixed定位，那么浮动的属性值相当于‘none’，display的属性如下面的表格所示。元素的位置就由设定决定定位时的值以及所包含容器来决定；</li>
<li>除此之外，如果float属性的值为不是none，那么元素将会浮动，元素的display属性将如下表所示；</li>
<li>除此之外，如果元素是根元素，那么元素的属性如下表所示；</li>
<li>除此之外，元素的display属性则根据设定来取值。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">specified value</th>
<th style="text-align:left">computed value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">inline-table</td>
<td style="text-align:left">table</td>
</tr>
<tr>
<td style="text-align:left">inline, table-x, inline-block</td>
<td style="text-align:left">block</td>
</tr>
<tr>
<td style="text-align:left">others</td>
<td style="text-align:left">same as specified</td>
</tr>
</tbody>
</table>
<h2 id="清除浮动（Clearfix）"><a href="#清除浮动（Clearfix）" class="headerlink" title="清除浮动（Clearfix）"></a>清除浮动（Clearfix）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;容器内如果只存在浮动元素，那么则会因为浮动元素不在普通流中而造成父级容器高度塌陷且无法获取浮动元素高度的情况，为了解决这个问题，除了了各种各样的清除浮动的方法，下面简单介绍几种：</p>
<ol>
<li><p>利用伪类及伪元素来清除，代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用overflow属性，代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 或者是auto */</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block; <span class="comment">/* Necessary to trigger "hasLayout" in IE */</span></span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* Sets element back to block */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* Clearfix! */</span></span><br><span class="line">    <span class="attribute">zoom</span>: <span class="number">1</span>;  <span class="comment">/* Triggering "hasLayout" in IE */</span></span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* Element must be a block to wrap around contents. Unnecessary if only using block-level elements. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用clear属性，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> <span class="attr">style</span>=<span class="string">"clear:both"</span> /&gt;</span> <span class="comment">&lt;!-- So dirty! --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种增加<code>&lt;br&gt;</code>同时结合clear属性的方法虽然看起来非常简单，但非常不推荐使用。主要原因有：如果后期有更好的清除方式，你不想有<code>&lt;br&gt;</code>元素存在那么将存在很大的问题；而且这种增加也不是语义上的增加。</p>
<blockquote>
<h4 id="由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！"><a href="#由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！" class="headerlink" title="由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！"></a><strong>由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！</strong></h4></blockquote>
<h4 id="参考文章-Reference-："><a href="#参考文章-Reference-：" class="headerlink" title="参考文章(Reference)："></a>参考文章(Reference)：</h4><ul>
<li><a href="http://stackoverflow.com/questions/211383/what-methods-of-clearfix-can-i-use/1633170#1633170" target="_blank" rel="external">Stackoverflow–What methods of ‘clearfix’ can I use?</a></li>
<li><a href="http://www.quirksmode.org/css/clearing.html#top" target="_blank" rel="external">Blog–Clearing floats</a></li>
<li><a href="http://yuiblog.com/blog/2010/05/19/css-101-block-formatting-contexts/" target="_blank" rel="external">Blog–CSS 101: Block Formatting Contexts</a></li>
<li><a href="https://www.w3.org/TR/CSS21/visuren.html#dis-pos-flo" target="_blank" rel="external">W3C–Relationships between ‘display’, ‘position’, and ‘float’</a></li>
<li><a href="http://www.jianshu.com/p/07eb19957991#" target="_blank" rel="external">Blog–CSS浮动float详解</a></li>
<li><a href="http://www.cnblogs.com/dolphinX/archive/2012/10/13/2722501.html" target="_blank" rel="external">Blog–CSS布局 ——从display，position， float属性谈起</a></li>
<li><a href="http://www.cnblogs.com/coffeedeveloper/p/3145790.html" target="_blank" rel="external">Blog–对CSS中的Position、Float属性的一些深入探讨</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;目前是第二遍学习CSS，第一遍学习的时候只是看了一遍教材，当时感觉还行，但是在之后学习JS的过程中就愈发感觉到没有学好这一章节的严重性，所有在第二遍学习的时候，一定要将这个知识点彻底的弄清楚才会进入到下一阶段，这也就是为什么我会花3天的时间来弄清楚这个知识点的原因了。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为了搞懂这个问题，首先能想到的当然是先多看几遍教材，然后直接Google，搜索到几篇中文博客，之后在StackOverFlow上搜索与Float相关的问题，这一遍下来，搜索的资料让我看了好久，而我所理解的都将在下面的文章中通过图文来表述。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://detachment.club/categories/CSS/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://detachment.club/tags/CSS/"/>
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
