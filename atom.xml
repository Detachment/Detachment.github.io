<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Share and Create</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://detachment.club/"/>
  <updated>2018-11-20T16:00:00.000Z</updated>
  <id>http://detachment.club/</id>
  
  <author>
    <name>Detachment</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人简历</title>
    <link href="http://detachment.club/2018/11/20/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>http://detachment.club/2018/11/20/个人简历/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2018-11-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密文章，输入密码后查看</h3><div id="security"> <div> <div class="input-group"> <input type="text" style="padding:6px 2px 7px" class="form-control" aria-label="enter the password" id="pass" placeholder="请输入密码"/> <button type="button" onclick="decryptAES()">芝麻开门</button> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1+tpOSVO3NdP87Erw2Ctky7aLQttPh0eIqmlspXB7Y70PP2Ul8G7lvtj2L5VLdm4k5KIjFoZ+sD48nRu94VBRdrOckOKGEo9pOzmAqEtFdpb8sLNscn1gsFZBlDiroOwTPcCbVLIZjDB7bk+W31c2MuUmqpvyqTehQvv4yCLxp1Dh3dwBTODr2TtAMyi+LTwAYGmoQe6r+dI0eRaMe80w+f2qtRDypdCtcuQChIRQVxF5L04vOyBs9P7W2FarxFjlcWs91JJMFR7KkL+kOEZghIoCKFkx/zuGoz0L/uzJ54wO9j2KZI35rpn6xeW/FA2MljvDIDgZGsvU6iFSp2qLC6ZKKeT6JQLPaVVUMoWvq8aOT4jXpXr8/6BQQZwphSZXYSvFpPMH2gcUk1+4ni+ABEu9T9dKb5fYTBGfxXXTXzllz7nF2UAjaJg40LvR2obIhPc+mOujqZClG2+3jr38toLor+rVnIiuxmuaqtwNMLpTG0Hrbtx7PiluKSgXf+vt0eBMZyXfM6VP3QPnerAGbUT5xmR2+aNWv+QPIyTzvmuQhwy5gItJzS20+pOwjSdgS2Mm/tZ40NAVDzyPcVrcNHC6+Gmgj8CQKN5giPwxxKNcJmvPGYUSyNmHyfTqSY/pLbi4nEWVDLAKW3MXqWUhWn9m59RLhEHlI2RpoE5cBeezKNaow6PceZvC70ct12wfO1WSh4TxoJTw6Xc8rlC1RODPe2sQsoTOxQez1TarfBtA4UKpLyiMFsusIfrIIHLJCP0gxe21BXEKJ3kfctRpp5vzuWdsh59ETvDa+aFsUbHMCcF2VrYWDnEYietdO20ZtGIdPiPfNWRG5/698TA05o3UPyrzclN2Ei8Q479aX+XDYogzRCiehuRapsv6IuzO3n91Q2KPePmQs0Zw8MCQw3OJVBfQhdIICG8W43rx5XETSxkcbnEK+Ip53q0/1pLqlYinCxB0pvMLWmYO5S8aeEheI6T4AtmZrSQfPNxzcbGffvJ8J/Oik1IP+Hwf/uy6Te2yng+hi1UO8acY7l6zHX5dd9PNnUDhVJVz8dOvk/0nQODcKkEAkO1bziFMFmJx9Qi9wEmdIoxf70ogMB+sd6dEv8wudF7dGguMp15fhoWSpyA+gN0sPmYz4dRdlTPVrrkCfDH/VLNcw/+WNdO2xoBMAPwXaMTV6i7tLssyNrjx6bUeWX3h6/3bemS2jTwUl9FKcUUBnSGN9mn0l7ITJWVvwEIfaM/CY= </div>]]></content>
    
    <summary type="html">
    
      本文章需权限访问
    
    </summary>
    
      <category term="总结" scheme="http://detachment.club/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://detachment.club/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="简历" scheme="http://detachment.club/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Why is setState asynchronous ?</title>
    <link href="http://detachment.club/2018/11/12/why%20is%20setState%20asynchronous?%20/"/>
    <id>http://detachment.club/2018/11/12/why is setState asynchronous? /</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2018-11-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/facebook/react/issues/11527" target="_blank" rel="noopener">https://github.com/facebook/react/issues/11527</a><br><a href="https://blog.cloudboost.io/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e" target="_blank" rel="noopener">https://blog.cloudboost.io/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/11527&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/facebook/react/issues/11527&lt;/a
      
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://detachment.club/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>解除各种浏览器跨域</title>
    <link href="http://detachment.club/2018/09/06/%E8%A7%A3%E9%99%A4%E5%90%84%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/"/>
    <id>http://detachment.club/2018/09/06/解除各种浏览器跨域/</id>
    <published>2018-09-05T16:00:00.000Z</published>
    <updated>2018-09-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;浏览器跨域保护是一种很常见的策略，各大浏览器都会有这种保护机制，但是在本地进行调试的时候我们并不希望这个策略生效，因为生效的话我们就没法正常拿到数据了。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;浏览器跨域保护是一种很常见的策略，各大浏览器都会有这种保护机制，但是在本地进行调试的时候我们并不希望这个策略生效，因为生效的话我们就没法正常拿到数据了。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器兼容" scheme="http://detachment.club/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
      <category term="总结" scheme="http://detachment.club/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="http://detachment.club/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从点击下载不兼容火狐谈起</title>
    <link href="http://detachment.club/2018/09/04/%E4%BB%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%81%AB%E7%8B%90%E5%8F%8AEdge%E8%B0%88%E5%88%B0creatObjt/"/>
    <id>http://detachment.club/2018/09/04/从点击下载不兼容火狐及Edge谈到creatObjt/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2018-09-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;最近遇到这样一个问题：点击按钮下载文件的时候，在 Safari 和 Chrome 上都没有问题，在 Firefox 和 Edge 上则无反应。一开始我以为是后者默默的把下载好的文件保存在了浏览器的默认位置导致的，直到昨天产品大佬告诉我默认文件夹并没有对应的文件，这才怀疑可能是在实现过程中有兼容性问题。</p><a id="more"></a><h2 id="从-window-URL-createObjectURL-blob-说起"><a href="#从-window-URL-createObjectURL-blob-说起" class="headerlink" title="从 window.URL.createObjectURL(blob) 说起"></a>从 window.URL.createObjectURL(blob) 说起</h2><p>点击下载的时候有一段代码是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">a.style = <span class="string">"display: none"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(a)</span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);   </span><br><span class="line"><span class="keyword">let</span> disposition = response.headers.get(<span class="string">'Content-Disposition'</span>);</span><br><span class="line"><span class="keyword">let</span> filename = (disposition &amp;&amp;disposition.replace(<span class="regexp">/attachment;filename=/</span>,<span class="string">''</span>)) || <span class="string">'data.xlsx'</span></span><br><span class="line">filename = <span class="built_in">decodeURI</span>(filename);</span><br><span class="line">a.href = url;</span><br><span class="line">a.download = filename;</span><br><span class="line">a.click();</span><br></pre></td></tr></table></figure></p><p>这段代码其实很简单，就是先创建个 Blob 对象，然后点击它下载。由于之前没有接触过这个 API， 所以稍微去了解了下，发现两篇文章：<a href="https://juejin.im/entry/5937c98eac502e0068cf31ae" target="_blank" rel="noopener">JavaScript 中 Blob 对象</a>， <a href="https://www.zhangxinxu.com/wordpress/2017/07/js-text-string-download-as-html-json-file/" target="_blank" rel="noopener">JS前端创建html或json文件并浏览器导出下载</a>，比较通俗易懂的介绍了下 Blob 对象的使用方式。这一步是没有什么问题的。</p><p>自然而言的会怀疑到这个API的浏览器兼容性，然后查了一下，结果如下图所示。我是用的 Firefox 是 62 版本的，所以应该也不存在兼容性问题。<br><img src="http://o9ybnkuir.bkt.clouddn.com/UC20180904_224947.png" alt="compatibility"></p><h2 id="到事件监听"><a href="#到事件监听" class="headerlink" title="到事件监听"></a>到事件监听</h2><p>然后开始怀疑是不是点击事件没有触发。<br>触发一个点击事件的前提：事件绑定在元素上，那么如何将一个点击事件绑定在元素上呢？</p><blockquote><p>以下内容引用自 <a href="https://stackoverflow.com/questions/6348494/addeventlistener-vs-onclick" target="_blank" rel="noopener">addEventListener vs onclick</a>         </p></blockquote><ol><li><p>Event Listeners (addEventListener and IE’s attachEvent)<br>在 IE 9 及以前，需要用 <code>attachEvent</code> 方法来绑定点击事件：<br><code>element.attachEvent(&#39;onclick&#39;, function() { /* 具体函数*/})</code><br>在其他绝大多数浏览器中，则可以用 <code>addEventListener</code> 来进行绑定：<br><code>element.addEventListener(&#39;click&#39;, function() { /* 具体函数*/ }, false);</code><br>利用这种方式添加事件绑定的时候，理论上可以在同一个元素绑定无数的事件，唯一需要考虑的就是性能问题以及客户端的内存，这些就都和浏览器有关了。<br>上面的例子中添加的函数都是匿名函数，其实可以先声明一个函数，然后通过函数引用的方式来绑定事件：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunctionReference = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* do stuff here*/</span> &#125;</span><br><span class="line">element.attachEvent(<span class="string">'onclick'</span>, myFunctionReference);</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, myFunctionReference , <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p> 利用  <code>addEventListener</code> 进行绑定的时候需要传第三个参数，这个参数是用来控制事件是否冒泡的。在  <code>attachEvent</code> 方法中没有此参数。     </p></li><li><p>Inline events (HTML onclick=”” property and element.onclick)<br>在支持 JavaScript 的浏览器中，我们可以在元素上加上事件监听函数，方法如下：<br><code>&lt;a id=&quot;testing&quot; href=&quot;#&quot; onclick=&quot;alert(&#39;did stuff inline&#39;);&quot;&gt;Click me&lt;/a&gt;</code><br>虽然大部分有经验的程序员都很少用这种方式，但这种方式确实也可以达到目的，而且简单直接。这种写法的缺点也显而易见：函数必须要非常简单。<br>另外一种写法是：<br><code>element.onclick = function () { /*do stuff here */ };</code><br>这种写法和上面其实是等价的，不过这样写的话函数的复杂程度就可以大大提高了。<br>利用行间事件的写法有一个很明显的缺点：每一个元素都只能有一个对应的事件，事件是作为元素的属性存储的，这样一来如果有多个同样的事件，那么前者就会被后者覆盖：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'testing'</span>);</span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="string">'did stuff #1'</span>); &#125;;</span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="string">'did stuff #2'</span>); &#125;;</span><br></pre></td></tr></table></figure><p> 上面这段代码执行的时候，只有第二个函数会执行，因为第一个事件被覆盖掉了。</p></li></ol><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>上面两个点都没有解决到实际的问题，最后终于在 stackOverflow 上看到了一个问题: <a href="https://stackoverflow.com/questions/30694453/blob-createobjecturl-download-not-working-in-firefox-but-works-when-debugging" target="_blank" rel="noopener">Blob createObjectURL download not working in Firefox (but works when debugging)</a> 利用里面提到的解决方案顺利解决了这个兼容性问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最近遇到这样一个问题：点击按钮下载文件的时候，在 Safari 和 Chrome 上都没有问题，在 Firefox 和 Edge 上则无反应。一开始我以为是后者默默的把下载好的文件保存在了浏览器的默认位置导致的，直到昨天产品大佬告诉我默认文件夹并没有对应的文件，这才怀疑可能是在实现过程中有兼容性问题。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://detachment.club/tags/JavaScript/"/>
    
      <category term="工作" scheme="http://detachment.club/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="浏览器兼容" scheme="http://detachment.club/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>学习计划及路线</title>
    <link href="http://detachment.club/2018/06/14/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://detachment.club/2018/06/14/近期学习计划/</id>
    <published>2018-06-13T16:00:00.000Z</published>
    <updated>2018-10-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经很久没有制定学习计划了，每次都是心血来潮的看到想学的内容然后开始搜索，搜完相关资料后兴致没有了就放弃了。虽然挺舒服的，但从长远的角度来说，这不是一种良性的状态，所以开始恢复写博客，然后将近段时间的学习计划列出来，一步一个脚印。</p><ol><li>网络协议学习 （进行中）              </li><li>node.js，打开通向后端的大门        </li><li>深入学习 React 原理及其生态         </li><li>webpack &amp;&amp; git</li><li>数据结构和算法</li><li>巩固 JS 基础</li><li>解读 next.js 项目</li></ol><a id="more"></a><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><h3 id="1-网络协议"><a href="#1-网络协议" class="headerlink" title="1.  网络协议"></a>1.  网络协议</h3><p>这块知识一直都没有花费时间和精力去学习，每次碰到与这块内容相关的问题都不知所措，所以想拿出时间学习这方案的想法越来越成熟。<br>学习途径：看书《图解 HTTP》</p><h3 id="2-node-js-学习路线"><a href="#2-node-js-学习路线" class="headerlink" title="2.  node.js 学习路线"></a>2.  node.js 学习路线</h3><ol><li>看书：Node.js in Action 和 SMASHING Node.js: Javascript Everywhere.（改为：Node.js 实战第二版）</li><li>跟着书实践</li><li>尝试结合生产环境运用</li><li>运用到生产环境</li></ol><h3 id="3-深入学习-React-生态"><a href="#3-深入学习-React-生态" class="headerlink" title="3. 深入学习 React 生态"></a>3. 深入学习 React 生态</h3><h3 id="4-webpack-amp-amp-git"><a href="#4-webpack-amp-amp-git" class="headerlink" title="4. webpack &amp;&amp; git"></a>4. webpack &amp;&amp; git</h3><h3 id="5-数据结构和算法"><a href="#5-数据结构和算法" class="headerlink" title="5. 数据结构和算法"></a>5. 数据结构和算法</h3><h3 id="6-巩固-JS-基础"><a href="#6-巩固-JS-基础" class="headerlink" title="6. 巩固 JS 基础"></a>6. 巩固 JS 基础</h3><h3 id="7-解读-next-js-项目"><a href="#7-解读-next-js-项目" class="headerlink" title="7. 解读 next.js 项目"></a>7. 解读 next.js 项目</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;已经很久没有制定学习计划了，每次都是心血来潮的看到想学的内容然后开始搜索，搜完相关资料后兴致没有了就放弃了。虽然挺舒服的，但从长远的角度来说，这不是一种良性的状态，所以开始恢复写博客，然后将近段时间的学习计划列出来，一步一个脚印。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络协议学习 （进行中）              &lt;/li&gt;
&lt;li&gt;node.js，打开通向后端的大门        &lt;/li&gt;
&lt;li&gt;深入学习 React 原理及其生态         &lt;/li&gt;
&lt;li&gt;webpack &amp;amp;&amp;amp; git&lt;/li&gt;
&lt;li&gt;数据结构和算法&lt;/li&gt;
&lt;li&gt;巩固 JS 基础&lt;/li&gt;
&lt;li&gt;解读 next.js 项目&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="计划" scheme="http://detachment.club/categories/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="计划" scheme="http://detachment.club/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="学习" scheme="http://detachment.club/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网页多语言版本开发</title>
    <link href="http://detachment.club/2018/06/12/%E7%BD%91%E9%A1%B5%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E5%BC%80%E5%8F%91/"/>
    <id>http://detachment.club/2018/06/12/网页多语言版本开发/</id>
    <published>2018-06-11T16:00:00.000Z</published>
    <updated>2018-06-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着互联网时代的到来，为了满足来自世界各地的访客的需求，网站的多语言版本设计显得越来越重要。本篇博客主要用来说明怎样开发多语言版本。<br>技术栈：React.js + Next.js + Mobx.js + i18next</p><a id="more"></a><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><p>WIP</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着互联网时代的到来，为了满足来自世界各地的访客的需求，网站的多语言版本设计显得越来越重要。本篇博客主要用来说明怎样开发多语言版本。&lt;br&gt;技术栈：React.js + Next.js + Mobx.js + i18next&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://detachment.club/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="多语言" scheme="http://detachment.club/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18next" scheme="http://detachment.club/tags/i18next/"/>
    
      <category term="next.js" scheme="http://detachment.club/tags/next-js/"/>
    
      <category term="React.js" scheme="http://detachment.club/tags/React-js/"/>
    
  </entry>
  
  <entry>
    <title>开发笔记</title>
    <link href="http://detachment.club/2018/06/06/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://detachment.club/2018/06/06/开发笔记/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-10-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客用来记录在工作中遇到的各种疑难杂症及对应的解决方案，方便遇到同样问题时的检索。<br>问题及解决方案汇总：</p><ol><li>React.js + Next.js + i18next 报错：Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type.</li><li>利用 JSON.parse 进行解析的时候报错 ‘Unexpected token i in JSON at position 1’.</li><li>使用 forEach 对数组进行循环改变数组本身的值，然后并没有生效.</li><li>React.js + Next.js 跳转页面没问题，使用 safari 前进后退键的时候报错，使用 chrome 没问题.</li><li>部分浏览器打开页面时报错：Object.assign is not a function.</li><li>发送请求时控制栏报错：TypeError: Failed to execute ‘fetch’ on ‘Window’: Value is not a valid ByteString.</li></ol><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-React-js-Next-js-i18next-报错：Module-parse-failed-Unexpected-token-290-73-You-may-need-an-appropriate-loader-to-handle-this-file-type"><a href="#1-React-js-Next-js-i18next-报错：Module-parse-failed-Unexpected-token-290-73-You-may-need-an-appropriate-loader-to-handle-this-file-type" class="headerlink" title="1.  React.js + Next.js + i18next 报错：Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type."></a>1.  React.js + Next.js + i18next 报错：Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type.</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>官网个人版的数据直接放到重构的机构版时系统报错。由于分工不同，机构版将不同功能分割出来了，把共用部分放在了 common 中，其余不同模块分为了不同的项目，每个项目都是一个单独的 next.js 项目。需要引用项目外的共用文件的时候就利用 bindfs 来进行映射。<br> <img src="http://o9ybnkuir.bkt.clouddn.com/UC20180613_185341.png" alt="errorImg"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--- common</span><br><span class="line">|     - file</span><br><span class="line">|     - file</span><br><span class="line">|--- project A</span><br><span class="line">|     - file</span><br><span class="line">|     - file</span><br><span class="line">|     - next.conf.js</span><br><span class="line">|--- project B</span><br><span class="line">|     - file</span><br><span class="line">|     - file</span><br><span class="line">|     - next.conf.js</span><br></pre></td></tr></table></figure></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>由于和之前的项目相比并没有做过多的改动，但只要一启动就报这种错误，然后用关键词 <strong>Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type</strong>。搜出来结果很多，基本上都是和 webpack 配置相关，然后我反思了下这两个项目都没有配置过 webpack，所以应该不是这里面出现的问题。左看右看，终于找到一条让我眼前一亮的答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Next only compiles files inside <span class="keyword">of</span> the next root, which <span class="keyword">in</span> your <span class="keyword">case</span> is root/server. You can probably use something like <span class="number">3732</span> to compile files outside <span class="keyword">of</span> the root.</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://github.com/zeit/next.js/issues/3819" target="_blank" rel="noopener">Spread Operator not building – Webpack #3819</a><br>看到这个答案后，将所有链接到项目外的路径改成项目内就好了。</p><h3 id="2-利用-JSON-parse-进行解析的时候报错-‘Unexpected-token-i-in-JSON-at-position-1’"><a href="#2-利用-JSON-parse-进行解析的时候报错-‘Unexpected-token-i-in-JSON-at-position-1’" class="headerlink" title="2. 利用 JSON.parse 进行解析的时候报错 ‘Unexpected token i in JSON at position 1’"></a>2. 利用 JSON.parse 进行解析的时候报错 ‘Unexpected token i in JSON at position 1’</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>系统有部分数据保存在 mongoDB 中，取出的数据很多时候会是字符串形式，这时候最普遍的得到具体数据的方式是利用 JSON.parse 来进行解析。大部分的时候都能成功解析，也存在有些时候会出现描述中的错误，这时候就需要分析其中的原因了。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>这个问题其实是因为需要解析的不是一个有效的 JSON 对象导致的，以下引用自 <a href="https://stackoverflow.com/questions/18791718/json-parse-unexpected-token-s" target="_blank" rel="noopener">JSON.parse unexpected token s</a> :</p><blockquote><p>What you are passing to JSON.parse method must be a valid JSON after removing the wrapping quotes for string.<br>so something is not a valid JSON but “something” is.<br>A valid JSON is -<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">JSON</span> = <span class="literal">null</span></span><br><span class="line">&gt;   <span class="comment">/* boolean literal */</span></span><br><span class="line">&gt;   or <span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line">&gt;   <span class="comment">/* A JavaScript Number Leading zeroes are prohibited; a decimal point must be followed by at least one digit.*/</span></span><br><span class="line">&gt;   or JSONNumber</span><br><span class="line">&gt;   <span class="comment">/* Only a limited sets of characters may be escaped; certain control characters are prohibited; the Unicode line separator (U+2028) and paragraph separator (U+2029) characters are permitted; strings must be double-quoted.*/</span></span><br><span class="line">&gt;   or JSONString</span><br><span class="line">    <span class="comment">/* Property names must be double-quoted strings; trailing commas are forbidden. */</span></span><br><span class="line">    or JSONObject</span><br><span class="line">    or JSONArray</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Examples -<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;&#125;'</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'"foo"'</span>); <span class="comment">// "foo"</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'[1, 5, "false"]'</span>); <span class="comment">// [1, 5, "false"]</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'null'</span>); <span class="comment">// null </span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">"'foo'"</span>); <span class="comment">// error since string should be wrapped by double quotes</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>You may want to look <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON?redirectlocale=en-US&amp;redirectslug=JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="noopener">JavaScript and JSON differences</a></p></blockquote><p>说了这么多，那我们应该怎么去处理这种情况呢？其实很简单，用 try…catch 就行了。如果是合法的 JSON 对象就解析，如果不是则不进行处理。</p><h3 id="3-使用-forEach-对数组进行循环改变数组本身的值，然后并没有生效"><a href="#3-使用-forEach-对数组进行循环改变数组本身的值，然后并没有生效" class="headerlink" title="3. 使用 forEach 对数组进行循环改变数组本身的值，然后并没有生效"></a>3. 使用 forEach 对数组进行循环改变数组本身的值，然后并没有生效</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>利用 forEach 进行循环然后遍历改变原数组的需求非常常见，但稍有使用不当就会造成并没有改变原数据的结果，这主要是因为下面这个原因。</p><h3 id="4-React-js-Next-js-跳转页面没问题，使用-safari-前进后退键的时候报错，使用-chrome-没问题"><a href="#4-React-js-Next-js-跳转页面没问题，使用-safari-前进后退键的时候报错，使用-chrome-没问题" class="headerlink" title="4.  React.js + Next.js 跳转页面没问题，使用 safari 前进后退键的时候报错，使用 chrome 没问题"></a>4.  React.js + Next.js 跳转页面没问题，使用 safari 前进后退键的时候报错，使用 chrome 没问题</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>因为在 safari 中没找到简单快捷的操纵 cookie 的方法（在 chrome 中利用扩展 editThisCookie 很方便，在 safari 中可以直接在 console 中加入 cookie，但总归不方便），所以开发的时候一直都是在 chrome 中。项目上线后在 safari 中也测了测，没有发现问题，直到有一天同事告诉我所有的页面在后退的时候都会出现报错页面，而且只会出现在 Safari 中。百思不解，首先想到的是浏览器的兼容性，也找了很多相关的内容来看，有文章提到是因为返回的时候从缓存里面拿数据的原因，并没有提到具体的解决措施。然后想到如果真的是这个原因，那么之前做的个人版应该也会有同样的问题，所以就测了下之前的个人版，发现却并没有这个问题，所以就把思考的重点转移到了分模块打包上。在 next.js 项目的 issue 中找了找也没有找到相关的内容，问题暂时搁置。<br>大概两天后，老板说点击工商页面的时候也出现了报错页面，好像突然就有灵感了！联想到之前也有同事告诉我点击链接的时候会报错，给了我一个新思路：从链接入手！然后在官方文档上看到这么一句话：<code>For the initial page load, getInitialProps will execute on the server only. getInitialProps will only be executed on the client when navigating to a different route via the Link component or using the routing APIs.</code> 到这其实已经心中有数了。之前一直认为 getInitialProps 只会在服务器端执行，所以为了辨识用户身份，将服务器相关的参数传入到了这个函数中，然后在通过 Link 组件或者前进后退的时候，这个函数也会执行，然而此时找不到在函数中使用的参数（如 process 对象），所以系统持之以恒的报错！想到这点，问题便迎刃而解了。</p><h3 id="5-部分浏览器打开页面时报错：Object-assign-is-not-a-function"><a href="#5-部分浏览器打开页面时报错：Object-assign-is-not-a-function" class="headerlink" title="5. 部分浏览器打开页面时报错：Object.assign is not a function."></a>5. 部分浏览器打开页面时报错：Object.assign is not a function.</h3><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>有客户在微信打开我们的网页时发现空白页，测试发现在safari，chrome，firefox下都是没问题的。分析发现微信内置的浏览器版本对应于chrome43版本左右，版本过低导致不支持es6语法导致。问题分析到这就迎刃而解了，在next.js项目下搜索browser顺利找到解决方案。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalEntry = newConfig.entry</span><br><span class="line">  newConfig.entry = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> entries = <span class="keyword">await</span> originalEntry()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entries[<span class="string">'main.js'</span>] &amp;&amp; !entries[<span class="string">'main.js'</span>].includes(<span class="string">'./polyfills.js'</span>)) &#123;</span><br><span class="line">      entries[<span class="string">'main.js'</span>].unshift(<span class="string">'./polyfills.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entries</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  polyfills.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint no-extend-native: 0 */</span></span><br><span class="line"><span class="comment">// core-js comes with Next.js. So, you can import it like below</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your polyfills</span></span><br><span class="line"><span class="comment">// This files runs at the very beginning (even before React and Next.js core)</span></span><br><span class="line"><span class="comment">// console.log('Load your polyfills')</span></span><br></pre></td></tr></table></figure><h3 id="6-发送请求时报错-TypeError-Failed-to-execute-‘fetch’-on-‘Window’-Value-is-not-a-valid-ByteString"><a href="#6-发送请求时报错-TypeError-Failed-to-execute-‘fetch’-on-‘Window’-Value-is-not-a-valid-ByteString" class="headerlink" title="6. 发送请求时报错 TypeError: Failed to execute ‘fetch’ on ‘Window’: Value is not a valid ByteString."></a>6. 发送请求时报错 TypeError: Failed to execute ‘fetch’ on ‘Window’: Value is not a valid ByteString.</h3><h4 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h4><p>组内的一个小伙伴在发送请求的时候发生了这种错误，我拉完代码后却什么问题都没有。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>推测有可能导致的原因：本地node版本，项目依赖包的版本，浏览器版本，用户信息等等。在一一排除这些因素后，项目启动还是会出现报错。网上搜索了下，没有找到特别符合的同类错误。因为使用的是 isomorphic-fetch 来请求数据的，所以也把源码稍微打开看了下，并没有找到这种类型的报错。几乎放弃的时候想起来有人提过这种错误可能是在请求中有中文导致的，逐一去检查，终于发现了原来是同事在cookie中添加了未编码的中文名，编码后重新尝试，终于好了。</p><h3 id="7-命令行提示本地项目启动，浏览器打开却不行"><a href="#7-命令行提示本地项目启动，浏览器打开却不行" class="headerlink" title="7. 命令行提示本地项目启动，浏览器打开却不行"></a>7. 命令行提示本地项目启动，浏览器打开却不行</h3><h4 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h4><p>尝试进行接口测试，本地部署的时候需要运行node服务，随便填了个端口：6666。</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>多次重启未果，猜测可能是端口的原因，网上一查还真是。在chrome中6666端口被禁用的，其他被禁用的端口如下：</p><blockquote><p>1： // tcpmux<br>7： // echo<br>9： // discard<br>11： // systat<br>13： // daytime<br>15： // netstat<br>17： // qotd<br>19： // chargen<br>20： // ftp data<br>21： // ftp access<br>22： // ssh<br>23： // telnet<br>25： // smtp<br>37： // time<br>42： // name<br>43： // nicname<br>53： // domain<br>77： // priv-rjs<br>79： // finger<br>87： // ttylink<br>95： // supdup<br>101： // hostriame<br>102： // iso-tsap<br>103： // gppitnp<br>104： // acr-nema<br>109： // pop2<br>110： // pop3<br>111： // sunrpc<br>113： // auth<br>115： // sftp<br>117： // uucp-path<br>119： // nntp<br>123： // NTP<br>135： // loc-srv /epmap<br>139： // netbios<br>143： // imap2<br>179： // BGP<br>389： // ldap<br>465： // smtp+ssl<br>512： // print / exec<br>513： // login<br>514： // shell<br>515： // printer<br>526： // tempo<br>530： // courier<br>531： // chat<br>532： // netnews<br>540： // uucp<br>556： // remotefs<br>563： // nntp+ssl<br>587： // stmp?<br>601： // ??<br>636： // ldap+ssl<br>993： // ldap+ssl<br>995： // pop3+ssl<br>2049： // nfs<br>3659： // apple-sasl / PasswordServer<br>4045： // lockd<br>6000： // X11<br>6665： // Alternate IRC [Apple addition]<br>6666： // Alternate IRC [Apple addition]<br>6667： // Standard IRC [Apple addition]<br>6668： // Alternate IRC [Apple addition]<br>6669： // Alternate IRC [Apple addition]</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本博客用来记录在工作中遇到的各种疑难杂症及对应的解决方案，方便遇到同样问题时的检索。&lt;br&gt;问题及解决方案汇总：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;React.js + Next.js + i18next 报错：Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type.&lt;/li&gt;
&lt;li&gt;利用 JSON.parse 进行解析的时候报错 ‘Unexpected token i in JSON at position 1’.&lt;/li&gt;
&lt;li&gt;使用 forEach 对数组进行循环改变数组本身的值，然后并没有生效.&lt;/li&gt;
&lt;li&gt;React.js + Next.js 跳转页面没问题，使用 safari 前进后退键的时候报错，使用 chrome 没问题.&lt;/li&gt;
&lt;li&gt;部分浏览器打开页面时报错：Object.assign is not a function.&lt;/li&gt;
&lt;li&gt;发送请求时控制栏报错：TypeError: Failed to execute ‘fetch’ on ‘Window’: Value is not a valid ByteString.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://detachment.club/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="总结" scheme="http://detachment.club/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Node.js" scheme="http://detachment.club/tags/Node-js/"/>
    
      <category term="iOS" scheme="http://detachment.club/tags/iOS/"/>
    
      <category term="webview" scheme="http://detachment.club/tags/webview/"/>
    
      <category term="H5" scheme="http://detachment.club/tags/H5/"/>
    
      <category term="兼容" scheme="http://detachment.club/tags/%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 基础知识</title>
    <link href="http://detachment.club/2018/02/24/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://detachment.club/2018/02/24/MySQL基础知识/</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;本博客用于记录与MySQL相关的知识点。</p><a id="more"></a><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>显示所有数据库：show databases（注意 databases 是复数形式）；</li><li>显示当前数据库中的所有表：show tables；</li><li>显示表结构：describe <code>table-name</code>;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本博客用于记录与MySQL相关的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://detachment.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="MySQL" scheme="http://detachment.club/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://detachment.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>再见了，2017</title>
    <link href="http://detachment.club/2017/12/27/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://detachment.club/2017/12/27/2017年终总结/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2017-12-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密文章，输入密码后查看</h3><div id="security"> <div> <div class="input-group"> <input type="text" style="padding:6px 2px 7px" class="form-control" aria-label="enter the password" id="pass" placeholder="请输入密码"/> <button type="button" onclick="decryptAES()">芝麻开门</button> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      本文章需权限访问
    
    </summary>
    
      <category term="总结" scheme="http://detachment.club/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://detachment.club/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="2017" scheme="http://detachment.club/tags/2017/"/>
    
      <category term="工作" scheme="http://detachment.club/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="计划" scheme="http://detachment.club/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>域名迁移</title>
    <link href="http://detachment.club/2017/06/13/%E5%9F%9F%E5%90%8D%E8%BF%81%E7%A7%BB/"/>
    <id>http://detachment.club/2017/06/13/域名迁移/</id>
    <published>2017-06-12T16:00:00.000Z</published>
    <updated>2017-06-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p> 本域名即将到期（6月22日），之后域名地址更改为：detachment.top。如果你一直在关注我的博客，别忘了更换地址。<br> 同时，在我 github 上的 <a href="https://github.com/Detachment/Detachment.github.io" target="_blank" rel="noopener">https://github.com/Detachment/Detachment.github.io</a> 这个项目里，你也可以找到我的最新博客地址，谢谢关注。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;通知&lt;/h2&gt;&lt;p&gt; 本域名即将到期（6月22日），之后域名地址更改为：detachment.top。如果你一直在关注我的博客，别忘了更换地址。&lt;br&gt; 同时，
      
    
    </summary>
    
      <category term="博客" scheme="http://detachment.club/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://detachment.club/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="域名" scheme="http://detachment.club/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>漫漫前端路</title>
    <link href="http://detachment.club/2017/04/19/%E6%BC%AB%E6%BC%AB%E5%89%8D%E7%AB%AF%E8%B7%AF/"/>
    <id>http://detachment.club/2017/04/19/漫漫前端路/</id>
    <published>2017-04-18T16:00:00.000Z</published>
    <updated>2017-06-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从正式辞职到又一次开始上班，我用了整整 13 个月（差一天），时间不饶人。<br>&nbsp;&nbsp;&nbsp;&nbsp;谨以此文记录在前端路上走的每一步。</p><a id="more"></a><h2 id="路之伊始"><a href="#路之伊始" class="headerlink" title="路之伊始"></a>路之伊始</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;假设我们足够聪明，我们可以在脑海中以时间为横坐标，以对自己的认可程度为纵坐标，作一条曲线。那么这条曲线便是我们的人生之路。很久以前睿智的长辈就告诉我们，有几个时刻对这条曲线的影响会远远大于其他时刻，这些时刻包括：高考、工作和婚姻。目前我已经经历了其中了两个时间点，我认为这么说其实并不恰当。知道自己想干什么 以及 开始追求喜欢的人，在我看来才是最关键的两个点。<br>&nbsp;&nbsp;&nbsp;&nbsp;大学四年在一种不断尝试以及不断失败的模式中度过，结果就是直到毕业也没有确定自己将来到底要走一条怎样的路。毕业后进入一家机械公司，为了更好的了解工艺，选择在制造部门呆了半年，然后转到设计部。这之后在设计部做了近一年半的机械工程师。表面上的一切顺利与躁动不安的年龄格格不入。15 年下半年发生了两件事情，其一是遇到了一个喜欢的女生，其二是家里发生了一些变故。这两件事情就像是两阵风，迎面吹过，平息了内心的躁动，竟考虑安定下来了。然而时间的力量是巨大的，只用了半年，事情发生了很大的变化，此时我又开始寻思改变了。创造所带来的成就感可以让我感觉到自己的存在，在这样的环境下我无法做到这点，不能再这样消极度日了。下定决心要转行了。<br>&nbsp;&nbsp;&nbsp;&nbsp;既然要转，就面临着选择的问题。根据面向工资转行定理，很自然的想两个行业：金融和计算机。在我看来，计算机的趣味性和可创造性胜过金融，所以我用小脑做出了转计算机的决定。然后又面临选择了：做前端还是后端？要想了解一个复杂的事情，大多会选择自己熟悉的点进行切入。最开始接触的是 Python，大学的时候两个室友都选修过这门课。然后通过了解知道这门胶水语言的强大，但也正因为它的强大，我放弃了它。因为如果选择学习它，不可避免的需要在更细分的领域做出选择，而做出选择不仅需要精力还需要智慧。在这样的背景下，机缘巧合接触到了前端。最初对前端的了解是学习路线明确，可快速上手，而且涉及到视觉和交互等方面（后来才知道这部分其实已经细分到 UI 及交互设计师了）。然后就开始了前端的学习之路。<br>&nbsp;&nbsp;&nbsp;&nbsp;学习路线在我的 16 年总结中已经说的比较详细了，总的来说就是一个不断尝试的过程。这篇博客中就另外两个选择说说自己当时的想法吧：其一是为什么不选择参加培训班，其二是为什么在自学半年后放弃工作机会而继续学习。<br>&nbsp;&nbsp;&nbsp;&nbsp;参加培训班从来都没有出现在我的选择范围，细细一想，存在的原因有以下几点。上面也提到过，整个大学阶段我都处于一种比较低落的状态，虽然在不断的尝试，却并没有寻找到自己的一条路。时间虽然能慢慢减弱这种挫败感，但却无论如何也无法消除。这种自我否定的想法让我时而变得非常消极，因此我想再给自己一段思考的时间，而这段时间到底多长，我无从得出结论。基于这样的原因，我希望这段时间能够完全按照自己的想法来生活，不管是学习、玩耍还是作息。而这一点，培训机构是无论如何也满足不了的。所以就此一点，就可以完全将培训机构排除在外了。对于一个从来没有出现在脑子里面的问题作出答案，原因是被问到的次数太多了。<br>&nbsp;&nbsp;&nbsp;&nbsp;为什么不尽早参加工作？ 一部分是因为上面提到的原因：我仍然没有找到自己想要的答案，这段时间尚不能结束。另一部分的原因是当时技术水平太低，很容易限制自己的眼界，从而形成技术天花板。当然了，这只是我的想法，对于是否正确，我现在还无法做出判断。只需要对自己的选择负责就问心无愧了。</p><h2 id="上下而求索"><a href="#上下而求索" class="headerlink" title="上下而求索"></a>上下而求索</h2><h3 id="2017-05-21-工作第一个月"><a href="#2017-05-21-工作第一个月" class="headerlink" title="2017-05-21 工作第一个月"></a>2017-05-21 工作第一个月</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;工作还差三天就满一个月了，说一说这一个月来的感受。<br>&nbsp;&nbsp;&nbsp;&nbsp;刚入职的时候，先熟悉公司的整体业务逻辑、技术栈和工具。知道了前端主要用 React 之后，开始跟着官方文档学习。学了差不多一个礼拜，文档还没有完全看完呢，松哥找我说，先写起来吧，这样学不是办法。然后就给了我一个重构页面的小任务练手。从这开始才真正的接触到公司的业务逻辑。这才感受到，看起来非常简单的页面，背后的逻辑竟这么复杂。之前自学的时候所接触和了解的部分和真正工作中的复杂程度根本不在一个量级，我所看到的只是冰山一角罢了。<br>&nbsp;&nbsp;&nbsp;&nbsp;写了两三天，一头雾水，完全不了解里面的数据流，写出来的页面显示不了任何数据。松哥过来看了看，啪啪啪的一顿写，数据就出来了。根据他修改的部分，我又重新去看了看 Reflux 的官方文档，再来对比实际的代码进行理解，终于有了一点感觉。继续写了两三天，数据没啥问题了，但又有了其他问题：关联样式。松哥一直强调代码和样式的复用，表面上我也确实理解，但是在实际的应用过程中却很难取得这样的效果。这个还得建立在对整个系统样式的理解上，否则很难做到游刃有余的复用之前的样式。<br>&nbsp;&nbsp;&nbsp;&nbsp;一个礼拜又过去了，给了我一个真正项目上的简单页面的编写任务。初步了解了下，感觉非常简单，一两天就能做出来。哈哈哈，还是太年轻。我的想法是先从接口获取数据，然后根据数据编写页面。捣鼓了两三天，又是 JQuery 又是 Openresty 的看，想把数据弄到手，结果一无所获。这时候松哥又出现了，告诉我接口先不管，先用静态的数据来模拟，之后再来帮我一起写接口。又是两三天，自认为样式差不多了，给松哥看了看，满以为完成的很好。松哥一看，一脸黑线：你这写的啥样式？这样的样式能复用吗？能自适应吗？有初始化吗？哈哈哈，我被问的一脸懵逼，确实是没有注意这些方面。之前自学的时候，只管在表面上看起来达到效果，哪管得上规范呐。这方面还是得多注意注意。之后开始写接口了，也是一问三不知，被松哥吐槽你咋啥都不知道。看完写好的代码，又学习了新姿势，开心。<br>&nbsp;&nbsp;&nbsp;&nbsp;高中物理老师说的一句话到现在还记得，说的是人对于知识体系的理解程度分为四个阶段：1. 不知道不知道；2. 知道不知道；3. 不知道知道；4. 知道知道。认为很有道理，然后对比分析了下自己，很明显的处于第一个阶段。所以有时候根本不知道自己应该加强哪些方面，因为所有方面都需要加强。这也是目前面临的一个最大的问题。我认为解决问题的最佳途径就是多和松哥以及公司的前辈交流。调整自己的步调，努力做到和公司共振的状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;下个月的目标：一方面加强对公司业务逻辑的理解，另一方面在数据库和网络协议方面要下点心思。其实了解数据库也是为了更好的理解业务逻辑，有机统一。还有一点就是：技术博客还是得定期写一写，鞭策自己不断的学习。给自己定一个小要求，每两周写一篇技术博客，主题不限。每个月写一写总结，就更新一下这篇文章。</p><h3 id="2017-06-25-工作第二个月"><a href="#2017-06-25-工作第二个月" class="headerlink" title="2017-06-25 工作第二个月"></a>2017-06-25 工作第二个月</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;到昨天为止，工作满两个月。本来计划好的两周一篇技术博客，一个月一次的总结，现在却并没有做到。应该是时间有点紧，暂时还么有完全适应这种工作节奏吧。<br>&nbsp;&nbsp;&nbsp;&nbsp;这个月大体在忙两件事：1. 学习 redux，为重构后台界面做准备；2. 补充完善现在正在做的 H5 页面。懂得了一个道理：在工作中，快速学习和快速开发能力是非常重要的。以前自己一直走的是系统性学习的路线，现在应该要在快速的经验式学习上有所投入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从正式辞职到又一次开始上班，我用了整整 13 个月（差一天），时间不饶人。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;谨以此文记录在前端路上走的每一步。&lt;/p&gt;
    
    </summary>
    
      <category term="人生" scheme="http://detachment.club/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="心得" scheme="http://detachment.club/tags/%E5%BF%83%E5%BE%97/"/>
    
      <category term="人生" scheme="http://detachment.club/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>【权限】 经验不够，诚意来凑</title>
    <link href="http://detachment.club/2017/03/30/%E3%80%8A%E7%BB%8F%E9%AA%8C%E4%B8%8D%E5%A4%9F%EF%BC%8C%E8%AF%9A%E6%84%8F%E6%9D%A5%E5%87%91%E3%80%8B/"/>
    <id>http://detachment.club/2017/03/30/《经验不够，诚意来凑》/</id>
    <published>2017-03-29T16:00:00.000Z</published>
    <updated>2017-03-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密文章，输入密码后查看</h3><div id="security"> <div> <div class="input-group"> <input type="text" style="padding:6px 2px 7px" class="form-control" aria-label="enter the password" id="pass" placeholder="请输入密码"/> <button type="button" onclick="decryptAES()">芝麻开门</button> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      本文章需权限访问
    
    </summary>
    
      <category term="人生" scheme="http://detachment.club/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="求职" scheme="http://detachment.club/tags/%E6%B1%82%E8%81%8C/"/>
    
      <category term="心得" scheme="http://detachment.club/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 基础知识总结（进行中）</title>
    <link href="http://detachment.club/2017/03/21/JavaScript%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://detachment.club/2017/03/21/JavaScript 基础知识总结/</id>
    <published>2017-03-20T16:00:00.000Z</published>
    <updated>2017-03-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇博客为 JavaScript 基础知识总结，长期更新。</p></blockquote><a id="more"></a><h2 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><h2 id="在-HTML-中使用-JavaScript"><a href="#在-HTML-中使用-JavaScript" class="headerlink" title="在 HTML 中使用 JavaScript"></a>在 HTML 中使用 JavaScript</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h2><h3 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h3><p>按值访问：<br>按引用访问：  </p><h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><p>只能给引用类型值动态添加属性  </p><h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><ul><li>ECMAScript 中所有函数的参数都是按值传递的  </li><li>命名参数：  </li></ul><h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><ul><li>基本类型： typeof</li><li>引用类型： instanceof</li></ul><h3 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h3><ul><li>执行环境：  </li><li>变量对象：   </li><li>作用域链：</li><li>活动对象：</li></ul><h4 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h4><p>两种情况下会延长： with 语句以及 try-catch 语句的 catch 块</p><h4 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h4><ul><li>声明变量：</li><li>查询标识符：</li></ul><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>原理：找到不再继续使用的变量，然后释放其占用的内存。</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>JavaScript 中最常用的垃圾收集方式</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>不太常见的垃圾收集策略。含义是跟踪记录每个值被引用的次数。</p><ul><li>循环引用：</li><li>将变量设置为 null 意味着切断变量与它之前引用的值之间的连接</li></ul><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>讨论的是以怎样的标准来确定是否回收</p><h4 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h4><ul><li>解除引用：优化内存的最佳方式，就是为执行中的代码只保存必要的数据。一旦不再有用，最好将其值设置为 null 来释放引用。（解除引用并不意味着自动回收所占内存，而是让值脱离执行环境，以便垃圾收集器下次将其回收）</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。常被称为类，但并不妥当。因为尽管 ECMAScript 从技术上讲是一门面向对象的语言，但是不具备面向对象语言所支持的类和接口等基本结构。</p><ul><li>对象定义：</li><li>引用类型有时候也被称为对象定义</li><li>实例：</li><li>构造函数：</li></ul><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li>创建：构造函数或者对象字面量</li><li>表达上下文：</li><li>语句上下文：</li><li>访问对象属性方式：点或者方括号，方括号会先计算后访问</li></ul><h3 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h3><ul><li>创建：构造函数（可省略 new ）或者数组字面量表示法</li><li>用字面量表示法创建时，不会调用相关函数（对象及数组都是这样）</li><li>数组的 length 可写</li></ul><h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><ul><li>对于只有一个全局作用域： instanceof</li><li>对于网页中包含多个框架： Array.isArray()</li></ul><h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><p>所有对象都有 toLocalString(), toString(), valueOf() 方法，对于数组：</p><ul><li>toString()：返回由数组每个值的字符串形式拼接而成并且以逗号隔开的字符串（实际上是调用数组每个值的 toString() 方法）</li><li>valueOf(): 返回数组</li><li>alert() 的参数应该是字符串形式，如果不是则会调用 toString() 方法</li><li>toLocalString()：除了是调用每个值的 toLocalString() 方法，其与和 toString() 没有区别</li></ul><h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><ul><li>栈：可以限制插入和删除项的数据结构，是一种 LIFO (last-in-first-out) 的数据结构</li><li>push()：参数任意，添加到数组末尾，返回的是 <strong>数字的长度</strong></li><li>pop()：移除数组最后一项，返回的是 <strong>被移除的项</strong></li></ul><h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><ul><li>队列：FIFO(First-in-First-Out)</li><li>shift(): 移除第一项，并返回该项，数组长度减一</li><li>unshift(): 在数组前端添加项，并返回数组长度</li></ul><h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><ul><li>reverse(): 反转数组的顺序</li><li>sort(): 默认情况下按照升序排列，其原理是调用每个项的 toString() 方法，然后比较字符串，不适用大多情况，因此常传入比较参数。</li></ul><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ul><li>concat(): 合并数组</li><li>slice(): 取部分数组</li><li>splice(): 接收多个参数，第一个为要删除的起始位置，第二个表示要删除的项数，第三个表示要插入的项。返回被删除的项，并且会改变原数组。</li></ul><h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><ul><li>indexOf(): 两参数，分别为要查找项及开始位置。返回在第一个匹配项在数组中的位置，不存在则返回 -1。使用全等比较。</li><li>lastIndexOf(): 同上，从数组末尾开始</li></ul><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>每个方法接收两个参数：处理函数及作用域（可选）。处理函数接收三个参数：数组项、项的位置及数组对象。都不会改变原数组。</p><ul><li>every(): 在函数作用后，所有项返回 true 则返回 true</li><li>filter(): 返回函数结果为 true 的项组成的数组</li><li>forEach(): 无返回值</li><li>map(): 返回函数作用后的新数组</li><li>some(): 有一项返回 true 则返回 true</li></ul><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><p>归并数组所有项，最终返回一个值。每个方法接收两个参数：作用在每一项的函数及归并基础值（可选）。每个函数接收四个参数：前一个值、当前值、项的索引以及数组对象</p><ul><li>reduce(): 从左往右</li><li>reduceRight(): 从右往左</li></ul><h3 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h3><ul><li>日起对象： new Date()，自动获得当前日期和时间</li><li>Date.parse(): 根据传入字符串返回对应毫秒数</li><li>Date.UTC(): 返回毫秒数，但传入参数不同</li><li>Date.now(): 调用该方法时的日期和时间毫秒数</li></ul><h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><h4 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h4><p>都是日期对象中的属性，书本 P102</p><h3 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h3><ul><li>创建： 字面量形式 <code>var expression = / pattern(模式) / flags(标志)</code>，或者用 new RegExp() 构造函数</li><li>模式：正则表达式，如包含元字符则需转义</li><li>标志：匹配行为。有 g，i，m</li></ul><h4 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h4><p>主要实例属性有：global, ignoreCase, lastIndex, multiline, source。能获取模式的各种信息，但用途不大</p><h4 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h4><ul><li>exec():</li><li>test(): 接收一个字符串参数，匹配则返回 true，不匹配返回 false</li></ul><h4 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h4><p>主要属性有 input, lastMatch, lastParen, leftContext, multiline, rightContext</p><h4 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h4><p>虽比较完备，但还是缺少一些特性，比如：</p><ul><li>向后查找</li><li>交集和并集</li><li>原子组</li><li>Unicode 支持</li><li>条件匹配</li><li>等等</li></ul><h3 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h3><p>函数是一个对象，所以函数名实际上是一个指向函数对象的指针，不会和函数绑定</p><h4 id="没有重载（深入理解）"><a href="#没有重载（深入理解）" class="headerlink" title="没有重载（深入理解）"></a>没有重载（深入理解）</h4><p>将函数名想象为指针，有助于理解为什么 ECMAScript 中没有重载的概念</p><h4 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h4><p>JavaScript 引擎是怎么确定代码中是否有函数声明的？先得扫描全部代码还是有特定的标记？</p><h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>函数可以作为值来使用</p><h4 id="函数内部的属性"><a href="#函数内部的属性" class="headerlink" title="函数内部的属性"></a>函数内部的属性</h4><p>函数内部有两个特殊的对象：arguments, this</p><ul><li>arguments: 类数组对象。有一个特殊属性： callee，用于保存一个指向拥有此 arguments 对象的函数的指针（在阶乘函数中非常有用）</li><li>this：引用的是函数执行的环境对象</li><li>caller：保存了调用当前函数的函数的引用</li></ul><h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4><p>每个函数都有两个属性：length 和 prototype</p><ul><li>length：函数希望接收的参数个数</li><li>prototype：对于 ECMAScript 的引用类型而言，prototype 是保存所有实例方法的真正所在。不可枚举   </li></ul><p>每个函数包含两个非继承而来的方法：apply()，call()。都用于设置函数中的 this 的值。最强大的地方在于扩中函数作用域。<br>还有一个方法： bind()，用于绑定函数实例的 this 的值   </p><p>函数继承而来的 toString(), toLocalString(), valueOf() 都会返回函数代码</p><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>三个特殊引用类型：Boolean, Number, String。每当读取一个基本类型时，后台会自动创建一个对应的基本包装类型对象。<br>引用类型及基本包装类型的主要区别在于对象的生存期。</p><h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><p>用处不大，容易造成误解</p><h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4><ul><li>toFixed(): 按照指定小数位返回数值字符串表示</li><li>toExponential(): 以指数形式返回数字的字符串表示</li><li>toPrecision(): 以合适的形式返回数字的字符串表示</li></ul><h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><ul><li>length 属性：表示字符串中包含多少字符</li><li>charAt(): 获得指定位置的字符</li><li>charCodeAt(): 获得指定位置的字符编码</li><li>可以用方括号的方式访问字符</li><li>concat()</li><li>字符串操作方法：slice(), substr(), substring()。对原始字符串无影响。这三者在传入参数为负数时有很大的差别。</li><li>字符串位置方法：indexOf(), lastIndexOf()。第一个参数为需查找字符，第二个为查找开始位置。可通过第二个参数找到字符串中所有字符</li><li>trim()：删除字符串前置及后缀的所有空格</li><li>大小写转换：toLowerCase(), toLocaleLowerCase(), toUpperCase(), toLocaleUpperCase()</li><li>模式匹配方法：match()，参数为正则表达式，返回一个数组；search()，参数也为正则表达式，返回第一个匹配项的索引，没有则返回 -1；replace()，替换字符。第一个参数为正则表达式或者字符串，第二个参数为字符串或者函数，函数有三个参数：模式匹配项、匹配项位置及原始字符串。split() 根据指定的分隔符将字符串分割并返回一个结果的数组。</li><li>localCompare(): 比较两个字符串，并返回一个值（0，-1 或者 1）</li><li>fromCharCode(): 将接收的字符编码转换成字符串</li></ul><h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><p>由 ECMAScript 实现提供的，不依赖宿主环境的对象，在程序执行之前已经存在</p><h4 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h4><ul><li>编码方法：encodeURI(), encodeURIComponent(), decodeURI(), decodeURIComponent()</li><li><strong>eval():</strong> 好比一个完整的解析器，参数为要执行的代码。代码中的变量或者函数不会被提升，因为是在 eval() 执行时创建的</li><li>属性：undefined, NaN, Infinity 等等</li><li>window 对象</li></ul><h4 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h4><ul><li>属性：Math.E, Math.LN10 等等</li><li>方法：Math.min(), Math.max()</li><li>舍入方法：Math.ceil(), Math.floor(), Math.round()</li><li>随机：Math.rondom()</li><li>其他方法：Math.abs(), Math.log() 等等</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><hr><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>ECMAScript 中有两种属性：数据属性和访问器属性</p><ul><li>数据属性：[[Configurable]], [[Enumerable]], [[Writtable]], [[Value]]。如要修改，需要使用 Object.defineProperty() 方法，接收三个参数：属性所在对象、属性名以及一个描述符对象</li><li>访问器属性：访问器属性不包含数据值，包含 getter 函数以及 setter 函数。有四个特征：[[Configurable]], [[Enumerable]], [[Get]], [[Set]]</li></ul><h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>利用 Object.defineProperties() 方法一次定义多个属性</p><h4 id="读取属性的特征"><a href="#读取属性的特征" class="headerlink" title="读取属性的特征"></a>读取属性的特征</h4><p>利用 Object.getOwnPropertyDescriptor() 方法，接收两个参数，分别为属性所在对象及要读取描述符的属性名</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>抽象创建具体对象的过程。解决了创建多个相似对象的问题，却没解决对象识别的问题（即怎么知道一个对象的类型）</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><ul><li>与工厂模式三点不同：不显式的创建对象，直接将属性和方法赋给 this 对象，没有 return 语句</li><li>constructor 属性：指向构造函数</li><li>与工厂模式相比：优点是——可以将自定义的构造函数的实例标识为特定类型；缺点——每个方法都要在每个实例上重新创建一遍</li><li>可以将同种方法提取放在全局解决上述缺点，但是又形成另一个缺点：如果对象需要定义的方法太多，则全局函数过多，那么就毫无封装性可言了</li></ul><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>prototype 属性是一个指针，指向的对象包含了由特定类型的所有实例共享的属性和方法</p><ul><li>理解原型对象：prototype 属性。 [[Prototype]]是实例中指向构造函数原型对象的指针，虽无法访问，但可以通过 isPrototypeOf() 来确定这种关系。ES5 中可以通过 Object.getPrototypeOf() 来返回这个指针所指向的对象。不能通过对象实例重写原型对象中的属性，重新创建会屏蔽查找原型对象中的属性。hasOwnProperty() 用于判断属性存在实例中还是原型中。</li><li>原型与 in 操作符：单独使用时，只要能访问到的属性（不管是实例中还是原型对象中），都返回 true，因此可结合 hasOwnProperty() 判断属性。在 for-in 循环中使用时略有不同。获得所有可枚举的实例属性：Object.keys()，返回属性字符串数组。如果想获得所有实例属性，用 Object.getOwnPropertyNames() 方法。</li><li>更简单的原型语法：用对象字面量重写原型对象，但结果就是 constructor 属性不在指向当前构造函数，而是 Object 构造函数</li><li>原型的动态性</li><li>原生对象的原型</li><li>原型对象的问题：最大的问题是由共享的本性导致的。</li></ul><h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>构造函数模式定义实例属性，原型模式定义方法和共享属性</p><h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>将原型放在构造函数里面，通过 if 判断达到只执行一次的效果</p><h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><p>和工厂模式基本一样，区别在于使用 new 操作符。。。</p><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><ul><li>稳妥对象：没有公共属性，其方法也不引用 this 的对象</li><li>与寄生模式不同之处：不使用 new 操作符，不引用 this</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>OO 语言支持两种继承方式：接口继承及实现继承。前者继承方法签名，后者继承方法本身。由于在 ECMAScript 中函数无签名，所以只能实现继承，主要通过原型链来实现。</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>基本思想是利用原型链让一个引用类型继承另一个引用类型的属性和方法。让一个原型对象等于另一个类型的实例</p><ul><li>别忘记默认简单原型：所有的对象都继承自 Object 对象</li><li>确定原型和实例的关系：instanceof —— 只要构造函数在实例的原型链上出现过即返回 true；isPrototypeOf() 同样，只要原型链上出现过的原型都返回 true</li><li>谨慎的定义方法：先定义再添加，且添加的时候不能为对象字面量</li><li>原型链的问题：其一来自于包含引用类型值的原型；其二不能向超类型的构造函数传参</li></ul><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>借用构造函数的基本思想是在子类型构造函数的内部调用超类型构造函数</p><ul><li>传递参数：可以向超类型构造函数传参</li><li>借用构造函数的问题：函数复用性差</li></ul><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>有时候也叫作伪经典继承，结合原型链继承和借用构造函数继承。使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。最大的问题是无论什么情况下都会两次调用超类型的构造函数：一次是在创建子类型原型的时候，一次是在子类型构造函数的内部</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型可以基于已有对象创建新对象。 ES5 中的 Object.create() 方法用于规范原型式继承</p><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>思路与寄生构造函数和工厂模式类似</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>这种方式可以解决在组合继承模式下的问题。寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。普遍认为这种方式是引用类型最理想的继承方式。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><hr><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>定义函数的两种方式：函数声明及函数表达式</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数是一个函数调用自身的情况下构成的。递归的时候，用 arguments.callee 比直接用函数名保险</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另外一个函数作用域的函数。<br>[[Scope]] 属性保存全局变量对象的作用域链<br>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含实际的变量对象<br>闭包会携带包含函数的活动对象，所以比一般函数更占内存，所以使用的时候需要注意</p><h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>闭包只能取得包含函数中任何变量的最后一个值</p><h4 id="关于-this-对象"><a href="#关于-this-对象" class="headerlink" title="关于 this 对象"></a>关于 this 对象</h4><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>闭包中引用了包含函数的活动对象</p><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。函数声明后面不能加圆括号，函数表达式可以。自执行匿名函数可以减少闭包占用内存的问题，因为执行完即销毁，没有指向匿名函数的引用了</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>任何函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。<br>特权方法：指的是有权访问私有变量和私有函数的公用方法<br>缺点：针对每个实例都会创建同样一组新方法</p><h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>在私有作用域中封装构造函数并将公有方法添加到构造函数的原型中。这样每个通过这个构造函数创建的实例都会共享同样的方法。好处是有利于代码复用，坏处是每个实例都没有了自己的私有变量</p><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>模块模式：为单例创建私有变量和特权方法。单例指的是只有一个实例的对象。JavaScript 中一般利用对象字面量的方式创建单例</p><h4 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h4><p>（不知所云）</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><hr><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h2 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h2><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h2 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h2><h2 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h2><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>事件流：描述从页面接收事件的顺序。一种是冒泡流（IE），一种是事件捕获流（网景）。</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>从具体发生的元素到不具体的上层节点。<br>现代浏览器都支持事件冒泡</p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>接收事件的顺序和事件冒泡相反<br>老版本浏览器不支持，建议放心使用事件冒泡，有特殊需要时再使用事件捕获</p><h4 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h4><p>“DOM2 级事件” 中规定 的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段</p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><p>事件是用户或者浏览器自身执行的某种动作，而响应这个动作的函数就叫做事件处理程序   </p><h4 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h4><ul><li>event 变量</li><li>利用 with 扩展作用域</li><li>缺点：其一是存在时差问题，其二是这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果，其三是 HTML 代码和 JavaScript 代码紧密耦合</li></ul><h4 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h4><h4 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h4><p>定义了两个方法：addEventListener() 以及 removeEventListener()，都接收三个参数：要处理的事件名，事件处理函数以及布尔值<br>通过 addEventListener()　添加的事件处理程序只能通过 removeEventListener() 来移除   </p><h4 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h4><p>定义了两个方法：attachEvent() 以及 detachEvent()，都接收两个参数：事件处理程序名及处理函数，事件会添加到冒泡阶段<br>和 DOM0 级处理程序的差异：DOM0 级中事件处理程序在元素的作用域作用域中运行，而 IE 则在全局作用域，因此 this 值不同<br>有多个处理程序时，后添加的先执行</p><h4 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h4><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>触发 DOM 上的事件时会产生一个事件对象 event，这个对像包含所有与事件相关的信息</p><h4 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h4><ul><li>在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标  </li><li>enent 的 type 属性</li><li>阻止特定事件的默认行为，可使用 preventDefault() 方法。注意，只有 cancelable 属性设置为 true 的事件才可以使用此方法来取消其默认行为</li><li>stopPropagation() 方法用于立即停止事件处理程序在 DOM 层次中的传播</li><li>eventPhase 属性</li><li>event 对象只存在于事件处理程序执行期间，执行完后即被销毁</li></ul><h4 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h4><h4 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h4><p>将所有的情况封装到一个函数中，根据不同的情况判断后执行（其实主要是 IE 和其他浏览器）</p><hr><blockquote><p>后面的内容之后再来复习</p></blockquote><h2 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h2><h2 id="使用-Canvas-绘图"><a href="#使用-Canvas-绘图" class="headerlink" title="使用 Canvas 绘图"></a>使用 Canvas 绘图</h2><h2 id="HTML5-脚本编程"><a href="#HTML5-脚本编程" class="headerlink" title="HTML5 脚本编程"></a>HTML5 脚本编程</h2><h2 id="错误处理及调试"><a href="#错误处理及调试" class="headerlink" title="错误处理及调试"></a>错误处理及调试</h2><h2 id="JavaScript-和-XML"><a href="#JavaScript-和-XML" class="headerlink" title="JavaScript 和 XML"></a>JavaScript 和 XML</h2><h2 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h2><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h2 id="Ajax-与-Comet"><a href="#Ajax-与-Comet" class="headerlink" title="Ajax 与 Comet"></a>Ajax 与 Comet</h2><p>Ajax 指的是 Asynchronous JavaScript XML，技术的核心是 XMLHttpRequest 对象（简称 XHR）</p><h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><h4 id="XHR-的用法"><a href="#XHR-的用法" class="headerlink" title="XHR 的用法"></a>XHR 的用法</h4><ul><li>open() 方法</li><li>send() 方法</li><li>响应后的 XHR 对象属性：responseText, responseXML, status, statusText, readyState(0, 1, 2, 3, 4)(异步请求时的属性)</li><li>readystatechange 事件</li><li>abort() 方法</li></ul><h4 id="HTTP-头部信息"><a href="#HTTP-头部信息" class="headerlink" title="HTTP 头部信息"></a>HTTP 头部信息</h4><ul><li>setRequestHeader()：设置自定义头部信息，需要在 open() 方法之后，sent() 方法之前调用</li><li>getResponseHeader(): 取得特定响应头部信息</li><li>getAllResponseHeaders(): 返回多个头部信息</li></ul><h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>常用于向服务器查询某些信息<br>查询字符串的参数名和值都需要使用 encodeURIComponent() 编码后才能放在 URL 末尾</p><h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>向服务器发送应该被保存的数据<br>模仿表单提交来发送数据</p><h3 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h3><p>并非所有浏览器都完整的实现了 2 级规范，但所有的浏览器都实现了它规定的部分内容</p><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>FormData 为序列化表单及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利<br>方便之处体现在不需要明确的在 XHR 对象上设置请求头部</p><h4 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h4><p>IE8 是唯一支持 timeout 属性的浏览器</p><h4 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType() 方法"></a>overrideMimeType() 方法</h4><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><p>6个进度事件：loadstart, progress, error, abort, load, loadend。目前大部分支持前面五个事件，目前还没有浏览器支持 loadend 事件。</p><h4 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a>load 事件</h4><h4 id="progress-事件"><a href="#progress-事件" class="headerlink" title="progress 事件"></a>progress 事件</h4><p>三个属性：lengthComputable, position, totalSize<br>可以根据这个属性为用户创建一个进度指示器</p><h3 id="跨域源资源共享"><a href="#跨域源资源共享" class="headerlink" title="跨域源资源共享"></a>跨域源资源共享</h3><p>CORS(Cross-Origin Resource Sharing) 跨域源资源共享<br>基本思想：使用自定义的 http 头部让浏览器与服务器进行沟通，从而决定请求或者响应是否成功</p><h4 id="IE-对-CORS-的实现"><a href="#IE-对-CORS-的实现" class="headerlink" title="IE 对 CORS 的实现"></a>IE 对 CORS 的实现</h4><p>在 IE8 中引入了 XDR(XDomainRequest) 类型，与 XHR 类似，但能实现安全可靠的跨域通信。<br>所有 XDR 请求都是异步执行的，不能用它来创建同步请求</p><h4 id="其他浏览器对-CORS-的实现"><a href="#其他浏览器对-CORS-的实现" class="headerlink" title="其他浏览器对 CORS 的实现"></a>其他浏览器对 CORS 的实现</h4><p>其他浏览器都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持</p><h4 id="Preflighted-Reqeusts"><a href="#Preflighted-Reqeusts" class="headerlink" title="Preflighted Reqeusts"></a>Preflighted Reqeusts</h4><h4 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h4><p>withCredentials 属性</p><h4 id="跨浏览器的-CORS"><a href="#跨浏览器的-CORS" class="headerlink" title="跨浏览器的 CORS"></a>跨浏览器的 CORS</h4><p>条件判断浏览器，主要区别在于 XDR 和 XHR</p><h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h3><h4 id="图像-Ping"><a href="#图像-Ping" class="headerlink" title="图像 Ping"></a>图像 Ping</h4><p>图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式<br>常用于跟踪用户点击页面或动态广告曝光次数。缺点有二：其一是只能发送 GET 请求，其二是无法访问服务器的响应文本。<br>图像 Ping 只能用于浏览器与服务器间的单向通讯</p><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP 是 JSON with padding 的简写，由回调函数及数据组成。<br>极为流行，因为简单易用。与图像 Ping 相比，优点在于可以直接访问响应文本，而且支持浏览器和服务器之间双通信。两点不足：从其他域加载涉及到安全问题，要确定请求失败并不容易。</p><h4 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h4><p>Comet 是一种服务器向页面推送数据的技术。（由 Alex Russell 发明）<br>两种实现 Comet 方式：长轮询和流<br>长轮询是传统轮询（也称为短轮询）的翻版：页面发起一个服务器请求，然后服务器一直保持打开，直到有数据可发送<br>HTTP 流：浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向服务器发送数据</p><h4 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h4><p>SSE（服务器发送事件）：围绕只读 Comet 交互推出的 API 或者模式。支持短轮询、长轮询和 HTTP 流，而且在断开时能够自动确定何时重新连接。   </p><ul><li>EventSource 对象</li></ul><h4 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h4><p>目标是在一个单独的持久连接上提供双工、双向通信<br>好处：能够在客户端和服务器之间发送非常少的数据，适合移动应用<br>坏处：制定协议的时间比制定 JavaScript API 的时间还要长，而且可能存在一致性和安全性的问题</p><h4 id="SSE-与-Web-Sockets"><a href="#SSE-与-Web-Sockets" class="headerlink" title="SSE 与 Web Sockets"></a>SSE 与 Web Sockets</h4><p>考虑两点：其一是否有自由度建立和维护 Web Sockets 服务器；其二是否需要双向通信</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>CSRF(Cross-Site Reqeust Forgery)：跨站点请求伪造</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><hr><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>利用 Object.prototype.toString.call(name) 对变量名为 name 的对象进行检测，返回的结果形式 [object NativeConstructorName] 就显示了其构造函数名。注意这种方法不能检测非原生构造函数的构造函数名。</p><h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>惰性载入表示函数执行的分支仅会发生一次。<br>实现方式：其一是在函数被调用时再处理函数，其二是在声明时就指定适当的函数    </p><h4 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4><p>主要用于事件处理程序及定时器中</p><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>基本方法：使用闭包返回一个函数</p><h3 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h3><p>一旦把对象定义为防篡改，就无法撤销了。</p><h4 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h4><p>Object.preventExtensions() 以及 Object.isExtensible()<br>不可扩展，但已有成员可以修改和删除</p><h4 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h4><p>密封对象不可扩展而且已有成员不能被删除<br>通过 Object.seal() 来密封，也可以通过 Object.isSealed() 来检测是否被密封</p><h4 id="冻结的对象"><a href="#冻结的对象" class="headerlink" title="冻结的对象"></a>冻结的对象</h4><p>最严格的防篡改级别是冻结对象，既不可扩展，又是密封的，而且数据属性的 [[Writtable]] 特性会被设置为 false。如果定义 [[Set]] 函数，访问器属性仍然是可写的。<br>Object.freeze()   </p><h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><p>关于定时器要记住的最重要的事情是：指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。</p><h4 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h4><p>主要的问题是某些间隔可能会被跳过，而且多个定时器的代码执行之间的间隔可能会比预期小。解决办法是链式调用延时定时器。</p><hr><h2 id="离线应用与客户端存储"><a href="#离线应用与客户端存储" class="headerlink" title="离线应用与客户端存储"></a>离线应用与客户端存储</h2><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="新兴的-API"><a href="#新兴的-API" class="headerlink" title="新兴的 API"></a>新兴的 API</h2><hr><h2 id="ECMAScript-6-入门"><a href="#ECMAScript-6-入门" class="headerlink" title="ECMAScript 6 入门"></a>ECMAScript 6 入门</h2><h3 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h3><p>###</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇博客为 JavaScript 基础知识总结，长期更新。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="总结" scheme="http://detachment.club/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://detachment.club/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建 《vue-hackernews-2.0》</title>
    <link href="http://detachment.club/2017/03/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%20Vue-HackerNews-2.0%20%E9%A1%B9%E7%9B%AE/"/>
    <id>http://detachment.club/2017/03/11/从零开始构建 Vue-HackerNews-2.0 项目/</id>
    <published>2017-03-10T16:00:00.000Z</published>
    <updated>2017-03-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>欢迎大家来到我的第一个程序搭建教程: <strong>从零开始搭建 《vue-hackernews-2.0》</strong>。</p><blockquote><p>项目源码地址: <a href="https://github.com/Detachment/Build-vue-hackernews-2.0-from-scratch" target="_blank" rel="noopener">Bulid vue-hackernews-2.0 from Scratch</a>   </p></blockquote><p>作为一个前端开发的初学者，在接触学习到 Vue.js 的时候，我发现官方提供并极力推荐的项目《vue-hackernews-2.0》对于新手而言比较难理解。但同时我又被这种高度工业化的项目所吸引，所以我决定花一段时间来弄清楚这个项目到底是怎么运行起来的。 在这个教程中我将会通过利用不同的版本的迭代的方式来逐步重建这个项目。</p><a id="more"></a><p><strong>这个项目是面向初学者的。</strong> 整个教程中，我逐步实现了这个项目的四个版本，每一个版本之间有一定的递进关系。为了方便理解掌握每个版本的内容，在每个版本的说明中，我会尽量把在相应版本中所需要掌握的知识点列出来。</p><blockquote><p>注明：简便起见，如未特别说明，在之后的所有章节中我会用 Vue-HN 来代替 vue-hackernews-2.0 项目。 项目运行的系统是 Windows 7，因条件限制未在其他系统上测试，请见谅。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-Vue-js-Vuex-Vue-router-HN-API-Firebase-ES6"><a href="#0-Vue-js-Vuex-Vue-router-HN-API-Firebase-ES6" class="headerlink" title="0. Vue.js, Vuex, Vue-router, HN API, Firebase, ES6"></a>0. Vue.js, Vuex, Vue-router, HN API, Firebase, ES6</h3><h4 id="章节前言"><a href="#章节前言" class="headerlink" title="章节前言"></a>章节前言</h4><p>作为一个前端初学者，我对最原始的页面构造比较熟悉，也就是页面只由 HTML、CSS 以及 JavaScript 构成。所以自从我开始学习 Vue-HN 这个项目我就想是不是可以用最原始的方法来实现这个项目（当然，不考虑用户体验及性能等方面）。在经过多次失败的尝试之后，我终于只利用 Vue.js 及其生态中的一些库实现了这个版本。下面这两个动图就分别是我这个版本和官方版本。</p><p align="center"><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/0-edition/Anthor.gif" width="700px" alt="Origin Website"><br>    [ 我的版本 ]<br>    <br><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/0-edition/Mine.gif" width="700px" alt="Plane Vue.js"><br>    [ 官方版本 ]<br></p><p>从上面的动图我们可以清楚的看到，基本上官方给出例子中的所有功能在我这个版本中都被实现出来了，而且仅仅只依赖于 Vue.js 以及其生态中的一些库。在开始搭建这个版本的项目之前，你应该对下面所列的链接中的知识点有所了解。了解完之后开始看代码才会有初步的认识。（了解每个链接对应的知识点即可，链接仅供参考。比如要了解 ES2015 的知识，就很推荐阮一峰老师的教程）</p><ul><li><a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js 2.0: The Progressive JavaScript Framework</a></li><li><a href="https://router.vuejs.org/en/" target="_blank" rel="noopener">Vue-router 2.0: A Simple Router for Vue.js</a></li><li><a href="http://vuex.vuejs.org/en/" target="_blank" rel="noopener">Vuex 2.0: State Management Patter and Library for Vue.js Application </a></li><li><a href="https://github.com/HackerNews/API" target="_blank" rel="noopener">Hacker News API: HackerNews API Works with Firebase</a></li><li><a href="https://babeljs.io/learn-es2015/" target="_blank" rel="noopener">Learn ES2015: A detailed overview of ECMAScript 2015 features</a></li><li><a href="https://firebase.google.com/docs/web/setup" target="_blank" rel="noopener">Firebase: App success made simple</a></li></ul><p>一眨眼看到需要了解这么多资料，你可能会被吓到。其实你不用担心，因为列出来的这些链接中除了 Vue.js 及其生态需要花较多时间来深入了解之外，其与的只需要稍微了解就行。比如 ES6 的内容，你暂时只需要了解箭头函数、 Promise 异步操作、扩展运算符等一些基本知识。另外两个链接则是 API，在用到的时候稍微花一点点时间浏览官方文档就行。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>搭建这个版本的时候，有几个关键的技术难点需要解决：</p><ul><li><p>怎样在不安装 Firebase 包的情况下通过 HackerNews 提供的 API 获取所需要的数据？<br><strong>Answer :</strong> 通过阅读 Firebase 的官方文档，我发现可以通过在文件中通过连接引入的方式来获取 Firebase 包的内容。除此之外，本地只需要针对项目稍加配置就行。下面是通过与不通过安装包的两种本地配置代码：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// without installing firebase package:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">    databaseURL: <span class="string">"https://hacker-news.firebaseio.com"</span></span><br><span class="line">&#125;;</span><br><span class="line">firebase.initializeApp(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> api = firebase.database().ref(<span class="string">'/v0'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// with firebase package:</span></span><br><span class="line"><span class="keyword">import</span> Firebase <span class="keyword">from</span> <span class="string">'firebase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = inBrowser</span><br><span class="line">  ? <span class="keyword">new</span> Firebase(<span class="string">'https://hacker-news.firebaseio.com/v0'</span>)</span><br><span class="line">  : (process.__API__ || (process.__API__ = createServerSideAPI()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServerSideAPI</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Firebase(<span class="string">'https://hacker-news.firebaseio.com/v0'</span>)</span><br></pre></td></tr></table></figure></li><li><p>怎么实现 vuex 和 router 之间的通讯？<br><strong>Answer :</strong> 保证通讯需要注意以下两点:</p><ul><li>在同一个 Vue 实例里面注册这两个插件;</li><li>通过一个叫做 “vuex-router-sync” 的插件实现通讯.  <blockquote><p>注意: 因为我们这个版本中并没有引入包管理工具，所以我们需要手动将这个插件包的 index.js 文件中的代码提取出来，稍作更改后通过链接的形式引入到主页面*    </p></blockquote></li></ul></li><li><p>怎么转换各个单文件组件（也就是 .vue 文件）？<br><strong>Answer :</strong> 每个单文件组件都包含三个部分： HTML 模板， JavaScript 脚本以及 CSS 样式。模板部分我们通过 “x-template” 来替换， JavaScript 脚本我们通过 “Vue.extend” 来替换， CSS 样式则直接写在样式表中就可以了。如果你想知道详细的信息，那就需要下载源码来瞧瞧了。</p></li></ul><p>在攻克这些难点，又加上对于 Vue.js 及其生态有较深入的了解之后，你应该也能自己完成这个版本的项目搭建过程了！（虽然不能用于生产，没有什么实际意义，但是实现的过程我认为还是很有意思的。）</p><blockquote><p>注意：因为文件之间的依赖原因，所以浏览器对于主页面文件头中的链接加载顺序直接影响到这个版本的成败。经测试，在 Firefox 和 IE 中都会优先加载本地文件然后加载外链，这并不是我所希望的顺序，所以在这两个浏览器中测试失败（可以通过将本地文件上传云存储，然后替换成外链解决）。在 Chrome 中测试成功。</p></blockquote><h4 id="后续版本"><a href="#后续版本" class="headerlink" title="后续版本"></a>后续版本</h4><p>目前一切顺利。但是如果我们更耐心些，重新审视这个版本的项目，我们会发现存在一些致命的缺陷。比如所有的文件都很混乱，项目的结构非常的脆弱，而且没有任何措施用于提高访问速度、优化用户体验。这些都会造成很高的维护成本。<br>在下一个版本中，我们将针对这些作出一些改进。  </p><hr><h3 id="1-Webpack-Vue-js-Vue-router-Vuex-and-Hackernews-API"><a href="#1-Webpack-Vue-js-Vue-router-Vuex-and-Hackernews-API" class="headerlink" title="1. Webpack, Vue.js, Vue-router, Vuex and Hackernews API"></a>1. Webpack, Vue.js, Vue-router, Vuex and Hackernews API</h3><h4 id="章节前言-1"><a href="#章节前言-1" class="headerlink" title="章节前言"></a>章节前言</h4><p>经过第一个版本后，我们对这个项目有了初步的了解。在这个版本中，我们会使用一些工具，使得我们这个项目初步模块化，同时也更加便于维护。在这个版本中我们将会使用到一些基本的插件和包，并通过 webpack 来实现功能。我们只需要简单的配置一下 webpack 就行，不会涉及到服务器端的内容，不会涉及缓存也不会涉及生产模式及开发模式的不同配置。下面的动图就是这个版本的成品，同时这个动图里面还包含了对整个项目的简单解构。</p><p align="center"><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/1-edition/first_edition.gif" width="700px" alt="Basic functions and simple deconstruction"><br>    [ 基本功能及简单解构 ]<br></p><p>为了更好的理解这个版本的内容，下面会列出一些需要了解的工具、插件和库的链接，你只需要对这些有基本的了解就行。（如果前面版本中已经列出来了，那么本节将不再重复。比如 Vue.js 及其生态、ES6 等等）：</p><ul><li><a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack 2.0: Moudle Bundler</a></li><li><a href="https://www.npmjs.com/package/es6-promise" target="_blank" rel="noopener">Package: es6-promise</a></li><li><a href="https://www.npmjs.com/package/firebase" target="_blank" rel="noopener">Package: firebase</a></li><li><a href="https://www.npmjs.com/package/vuex-router-sync" target="_blank" rel="noopener">Package: vuex-router-sync </a></li><li><a href="https://www.npmjs.com/package/buble" target="_blank" rel="noopener">Package: buble</a></li><li><a href="https://www.npmjs.com/package/buble-loader" target="_blank" rel="noopener">Package: buble-loader</a></li><li><a href="https://www.npmjs.com/package/css-loader" target="_blank" rel="noopener">Package: css-loader</a></li><li><a href="https://www.npmjs.com/package/file-loader" target="_blank" rel="noopener">Package: file-loader</a></li><li><a href="https://www.npmjs.com/package/rimraf" target="_blank" rel="noopener">Package: rimraf</a></li><li><a href="https://www.npmjs.com/package/stylus" target="_blank" rel="noopener">Package: stylus</a></li><li><a href="https://www.npmjs.com/package/autoprefixer" target="_blank" rel="noopener">Package: autoprefixer</a></li><li><a href="https://www.npmjs.com/package/stylus-loader" target="_blank" rel="noopener">Package: stylus-loader</a></li><li><a href="https://www.npmjs.com/package/url-loader" target="_blank" rel="noopener">Package: url-loader</a></li><li><a href="https://www.npmjs.com/package/vue-loader" target="_blank" rel="noopener">Package: vue-loader</a></li></ul><p>上面的清单好像有点过长，很容易唬到人，不过完全不用担心。因为对于这些工具、插件和库，我们目前所需要了解的仅仅是它们的用途是什么以及怎么正确的使用它们。相信我，这些对于所有人来说都是没有什么难度的。（英语不好的可以借助各种翻译工具，问题也不大）</p><h4 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h4><p>搭建这个版本有几个比较重要的步骤，下面将分别对每一步进行简单的介绍。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p><strong>项目结构分析。</strong> 其实这一步应该是写在上一个版本中的，因为每当我们开始做一个新的项目的时候，不可避免的需要先去考虑项目的整体结构、功能、风格以及通过怎样是手段来实现这些。分析完以后再来动手代码搭建整个项目才是正确的方式。这个项目的简单解构在上面的动图中已经展示出来了（解构在动图的后半部分，耐心看完）。<br>简单归纳，项目的结构还是比较简单的，主要由几个不同的页面组成，每个页面又由几个相同或者不同的组件组成。  </p><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p><strong>获取数据。</strong> 把获取数据作为第二步是因为它和项目的整体结构是独立的。在这一步我们需要利用到由 HackerNews 官方提供的 API（这个 API 利用 Firebase 制作）。然后定义一些获取数据的函数，形成 api.js 文件。然后在 Vuex 中调用这些函数，达到数据集中管理的目的。完成这一步后，项目的目录大概是这样子的：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> -- src</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- store</span></span><br><span class="line">|<span class="string">           </span>|<span class="string"> -- api.js    </span></span><br><span class="line">|<span class="string">           </span>|<span class="string"> -- index.js</span></span><br></pre></td></tr></table></figure></p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p><strong>搭建组件及页面。</strong> 基于第一步中对于项目的结构分析，我们开始编写组件及页面的代码。先编写组件的代码，然后将组件引入到页面中，再来构建页面。组件直接可以通过 <code>components option</code> 来相互引入，父子组件之间的数据传递可以利用 <code>props</code> 特性。完成这一步之后，项目结构大概是这样子的：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> -- src</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- store</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- api.js    </span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- index.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">        </span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- components</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Item.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemList.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Comment.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Spinner.vue</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- views</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- UserView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- CreateListView.js</span></span><br></pre></td></tr></table></figure></p><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><p><strong>完成项目剩下部分。</strong> 在这一步中，我们会引入 Vue.js 的路由系统：Vue-router。引入后，我们就可以将组件中的链接替换成路由中的路径。然后利用前文提到过的 <code>vuex-router-sync</code> 插件来同步路由和数据中心。除此之后，我们还需要定义几个全局筛选函数，并且注册在同一个 Vue 实例中。其他还有一些小的工作，比如引入 logo 图片，新建入口文件（为下一步 webpack 打包做准备）等等。完成这一步之后的项目目录大概如下所示：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">-- public</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- logo-48.png</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">-- src</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- store</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- api.js    </span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- index.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">        </span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- components</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Item.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemList.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Comment.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Spinner.vue</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- views</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- UserView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- CreateListView.js</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- filters</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- index.js</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- router</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string">-- index.js</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- app.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- App.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- entry.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- index.html</span></span><br></pre></td></tr></table></figure></p><h5 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h5><p><strong>终于要用上 webpack 啦！</strong> 如果你对于 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> , <a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a> 以及 <a href="https://docs.npmjs.com/getting-started/what-is-npm" target="_blank" rel="noopener">npm</a> 这些内容完全不知道，那么你就需要在开始这一步之前花几个小时的时间来了解一下。 在这个版本中，我们利用包管理工具 <code>npm</code> 来安装或者卸载插件。在初始化我们的项目的时候，我们既可以通过在命令行中输入 <code>npm init</code> （自动新建 node 配置文件，默认文件名为 <code>package.json</code> ）又可以自己手动新建一个名为 <code>package.json</code> 的配置文件。安装完各种插件后，我们可以开始配置 webpack 了。为了方便起见，我们会新建一个配置文件，默认文件名为 <code>webpack.config.js</code> ，在这个文件里面我们将会对项目进行简单配置。具体的配置情况可以去看原文件。   </p><blockquote><p>注意：在使用 <code>npm</code> 之前，你必须先安装最新版本的 <code>node.js</code>，否则无法运行成功。</p></blockquote><h4 id="后续版本-1"><a href="#后续版本-1" class="headerlink" title="后续版本"></a>后续版本</h4><p>对比上一个版本，我们在这个版本已经有点取得了一点进步，因为这个版本开始初步模块化了，也更加的易于维护。由于文件依赖及链接加载顺序的的关系，上一个版本只支持在 Chrome 浏览器中运行，而这个版本则不存在这个问题。因为我们在组件化的过程中已将所需要的对应依赖通过模块引入了。<br>然而，这个版本的项目还远远不够完美。在下一个版本中，我们将会将更多的因素考虑在内，而这些因素都会对用户体验产生很重要的影响。</p><hr><h3 id="2-Server-Packages-and-Plugins-for-Better-Performance"><a href="#2-Server-Packages-and-Plugins-for-Better-Performance" class="headerlink" title="2. Server, Packages and Plugins for Better Performance"></a>2. Server, Packages and Plugins for Better Performance</h3><h4 id="章节前言-2"><a href="#章节前言-2" class="headerlink" title="章节前言"></a>章节前言</h4><p>于我而言，这个版本是整个项目中最难的一个版本。为了优化用户体验，原作者将很多因素考虑在内，这就会带来很多需要了解的新知识，比如 node.js 中的 express 框架以及各种插件。服务器端及客户端、生产模式及调试模式的不同配置是这个版本的重点。在接下来的片段中，我会将我所理解的部分分享给大家。<br>由于这个版本和<a href="https://vue-hn.now.sh/top" target="_blank" rel="noopener">官网</a>的一样，我就不上效果图了。</p><h4 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h4><ol><li><p><strong>开启 Node server 之路： <code>server.js</code></strong><br><a href="https://vuejs.org/v2/guide/ssr.html" target="_blank" rel="noopener">在一些情况下</a> 你可能会需要在你的项目中使用到 SSR (Server-Side Rendering) ，以此来优化网页。在这个版本中，我们即将这个功能考虑在内。<br>既然是服务器端渲染，那么我们首先需要一个服务器。在这个版本中，我们采用的目前非常流行的运行在 Node.js 环境下的 express 框架。通过阅读官方提供的文档，很快我们就可以对此框架有一个初步的了解，知道其主要的用途及使用方法。（中文教程可参考阮一峰老师的 Node.js 入门。）<br><a href="http://expressjs.com/" target="_blank" rel="noopener">Express: Fast, unopinionated, minimalist web framework for Node.js</a><br>除此之外，我们还需要了解一些 Node.js 相关知识，比如 Path 模块、文件系统、系统变量等等。其实对于目前而言，这些内容也只是需要知道它们代表什么意思，以及怎么使用它们就够了。而这也是非常简单的。下面的链接是一些相关的需要了解的内容：<br><a href="https://nodejs.org/api/" target="_blank" rel="noopener">Node.js v7.7.2 Documentation</a><br>如果你之前不了解 SSR，那么点击下面的链接：<br><a href="https://www.npmjs.com/package/vue-server-renderer#api" target="_blank" rel="noopener">vue-server-renderer</a><br>除了上面的以外，下面这些插件和包能够使项目性能更加优化：<br><a href="https://www.npmjs.com/package/serve-favicon" target="_blank" rel="noopener">serve-favicon: Node.js middleware for serving a favicon</a><br><a href="https://www.npmjs.com/package/compression" target="_blank" rel="noopener">compression: Node.js compression middleware.</a><br><a href="https://www.npmjs.com/package/serialize-javascript" target="_blank" rel="noopener">serialize-javascript: Serialize JavaScript to a superset of JSON</a><br>浏览过上述文档后，我们就具备了理解 <code>server.js</code> 文件的知识储备。这很关键，因为这个文件直通服务器之门。</p></li><li><p><strong>生产模式及开发模式</strong><br>这两种模式 <strong>最大</strong> 的区别就是是否具有热替换及热更新功能。在生产模式下， webpack 不会监控文件的更新，在开发模式下是会的。相对于生产模式而言，开发模式更复杂一些（因为会使用到一些中间件），所以我们先来讨论一下开发模式吧。<br>正如名字所说，我们只会在开发过程中使用开发模式。所以在这个模式下，我们不是特别关心所加载的文件大小、文件数量以及访问速度等。这些都会导致在两种不同模式下的 webpack 配置文件有部分差异。为了实现热替换及热更新功能，我们可以使用 webpack 提供的 <code>webpack-hot-middleware</code> 和 <code>webpack-dev-middleware</code> 中间件。实现热更新的原理是调用 webpack 的 HMR API 来监测服务器变化。相关文档如下：<br><a href="https://www.npmjs.com/package/webpack-hot-middleware" target="_blank" rel="noopener">webpack-hot-middleware</a><br>除了上面的中间件，还需要了解下面链接中所包含的内容，这会使得我们能更好的的理解开发模式下服务器配置文件，也就是 <code>setup-dev-server.js</code> ：<br><a href="https://webpack.js.org/api/node/" target="_blank" rel="noopener">webpack node API</a><br><a href="https://webpack.js.org/api/node/#stats-object" target="_blank" rel="noopener">webpack API: stats-object</a><br>在生产模式下，服务器端会渲染经过 webpack 打包处理过的打包文件，然后客户端接收相关页面。在这个模式下为了提高访问速度，优化用户体验，我们会会使用一些其他的插件。比如下面列出来的两个插件就只是应用在生产模式下：<br><a href="https://www.npmjs.com/package/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a><br><a href="https://www.npmjs.com/package/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a><br>如果你想知道这两种模式在 webpack 配置上的详细差别，可以去看 <code>webpack.client.config.js</code> 和  <code>webpack.base.config.js</code> 配置文件。</p></li><li><p><strong>服务器端和客户端</strong><br>在配置 webpack、获取页面数据的时候，我们既需要配置客户端，也需要配置服务器端，并且要保证它们之间不产生冲突。至于在 Vue.js 中使用 SSR 功能时应该怎样在 webpack 中配置，官方文档有详细说明，可以点击下面的链接：<br><a href="https://www.npmjs.com/package/vue-server-renderer" target="_blank" rel="noopener">vue-server-renderer</a>。保证两端协调工作的一个关键点是在加载初始页面时怎样保证初始数据一致，想了解这点可以去阅读 <code>server-entry.js</code> 和 <code>client-entry.js</code> 文件。     </p></li><li><p><strong>当在命令行中输入 <code>npm run dev</code> 时，具体会发生什么？</strong><br>未完待续。  </p></li></ol><h4 id="后续版本-2"><a href="#后续版本-2" class="headerlink" title="后续版本"></a>后续版本</h4><p>基本上这就是我对这个项目的理解了。有一些不懂的地方没有说明，也有一些懂的地方没有说到。之后对整个项目有更深入、更高层次的理解再来补充这一章。在下一个版本中，我将会根据我自己的喜好对整个项目进行一些改造（主要是外在的页面）。下个版本再见。  </p><hr><h3 id="3-Change-the-Project-as-I-like"><a href="#3-Change-the-Project-as-I-like" class="headerlink" title="3. Change the Project as I like"></a>3. Change the Project as I like</h3><h4 id="章节前言-3"><a href="#章节前言-3" class="headerlink" title="章节前言"></a>章节前言</h4><p>在这个版本中，我将会根据自己的喜好对整个网页进行一些改造，使得网页整体更具有 Vue.js 风格，至少从视觉上来说更加的 Vue.js。下面的动图可以预览到我这个版本的成品，为了对照官方例子，你可以去<a href="https://vue-hn.now.sh/top" target="_blank" rel="noopener">官网</a>查看原网页。对于所添加及更改的部分，本节的下半部分将会详细介绍。</p><p align="center"><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/3-edition/last-edition-resize.gif" width="700px" alt="Last Edition of Vue-HackerNews"><br>    [ Vue-HackerNews 最后版本 ]<br></p><h4 id="开发过程-1"><a href="#开发过程-1" class="headerlink" title="开发过程"></a>开发过程</h4><ol><li><p><strong>使网页更具 Vue.js 风格</strong><br>打开这个版本（或者看上面的动图），一个最明显的变化就是网页的主色调发生了改变。我将页面中所有的橘黄色（<code>#ff6600</code>）都替换成了浅绿色（<code>#41b883</code>）。主色调是一个网站风格的重要组成部分，比如 HackerNews 的橘黄、知乎的深蓝、github 的墨黑以及 Vue.js 的浅绿。<br>至少从视觉上，我觉得这更加的 Vue.js 了，嘿嘿。</p></li><li><p><strong>增加根据评论数量、时间以及得分排序功能</strong><br>排序功能在很多网站上都能见到，能够方便大家快速找到自己想找的内容。所以我认为在这个项目上加上这个功能会比较酷（虽然不确定在这个网页上有没有实际意义）。为了增加这个功能，我新增了如下代码（部分）：   </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line">getters: &#123;</span><br><span class="line">    <span class="comment">// Add this function to getters. This function is uesd</span></span><br><span class="line">    <span class="comment">// to change the order of items in activeItems.</span></span><br><span class="line">    activeItemsSort(state, getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getters.activeItems.sort(<span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> A[m] - B[m]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 除此之外在 <code>ItemList.vue</code> 文件中也增加了一些代码，如果你对此感兴趣的话，那么可以把源文件看一下，也挺简单的。 样式上的改动也挺大的，感兴趣也可以去了解下。</p></li><li><p><strong>保持在不同设备上的自适应</strong><br>为了能和上一个版本一样，仍然能够自适应各种尺寸的设备，我在改变页面布局之后，对相关 CSS 样式进行了设置。从上面的动图可以看到，为了配合排序，主页面的布局发生的变化还是挺大了。在自适应设备的时候，为了使页面看起来更优雅一些，我将部分不太重要的信息给省略了。具体的设置可以看源文件。  </p></li></ol><ol start="4"><li><strong>在 <code>ItemView.vue</code> 页面增加 <code>toTop</code> 按钮</strong><br>返回顶部按钮也是很多网站的常见功能。由于首页只有20条信息，所以在首页上我没有加上这个。但是在评论页面，动辄上百条，我认为加上这个按钮应该会方便一些。反正都是根据我自己的喜好来加的，有没有实际意义我也不知道，哈哈。</li></ol><h4 id="章节结尾"><a href="#章节结尾" class="headerlink" title="章节结尾"></a>章节结尾</h4><p>到目前为止，这个项目的所有版本都已经完成了。在完成这些版本的过程中，我感受到了思考和创造带来的乐趣。这就是生活啊，希望大家也能感受到。<br>最后，衷心感谢原作者 <a href="https://github.com/yyx990803" target="_blank" rel="noopener">尤雨溪前辈</a> 给我们提供了一个这么好用的框架以及这么精彩的官方示例！</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>从开始接触这个项目到现在已经过去好几个月了，一直想通过学习这个项目来巩固 Vue.js 的知识点，但很长一段时间都没有什么收获。因为知识储备不够，很多内容都看不懂。碰壁碰多了就知道转弯。然后去学习 ES6 以及 Node.js 相关知识，再来看的时候，很多地方就豁然开朗了。在这之后，对这个项目的理解速度就远超过之前了。    </p><p>一天晚上睡不着，就思考着这种情况对于前端新手应该是挺常见的，我为什么不把自己的经验教训分享出来给大家？然后就有了这个项目。<br>项目实现的过程遇到各种困难，特别是第一个版本和第三个版本。第一个版本所遇到的关键点在上面已经说过了，不断的阅读各种文档然后尝试，最后终于在 Chrome 中跑了起来。挫败感是常态，成就感是偶尔才有的。第三个版本是官方完整版，自认为直到现在对其的理解程度都只有十之七八。但也暂时不纠结了，没有工作经验，很多在工程中需要考虑的因素对我而言还比较捉摸不透。很多问题在经验丰富的开发者来看是一种常识，但对于新手而言却会感到无比的困惑。“书读百遍，其义自见” 就是这个意思吧。  </p><p>现在项目完成了，再来回顾整个项目，有点感慨。最开始对这个项目的想法是从简到繁一步一步和大家一起重建这个项目，整个过程会非常详细。现在项目完成了，由于精力和知识层次的限制，却并没有完全达到这种效果，还是有点遗憾。不过除此之外，项目覆盖的还是比较全面的。<br>最后，希望看过我这个教程的小伙伴能够有所收获；如果有小伙伴或者前辈发现文中出现错误，也请不吝赐教，先谢谢大家了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;欢迎大家来到我的第一个程序搭建教程: &lt;strong&gt;从零开始搭建 《vue-hackernews-2.0》&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目源码地址: &lt;a href=&quot;https://github.com/Detachment/Build-vue-hackernews-2.0-from-scratch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bulid vue-hackernews-2.0 from Scratch&lt;/a&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一个前端开发的初学者，在接触学习到 Vue.js 的时候，我发现官方提供并极力推荐的项目《vue-hackernews-2.0》对于新手而言比较难理解。但同时我又被这种高度工业化的项目所吸引，所以我决定花一段时间来弄清楚这个项目到底是怎么运行起来的。 在这个教程中我将会通过利用不同的版本的迭代的方式来逐步重建这个项目。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://detachment.club/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue.js" scheme="http://detachment.club/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>博客构建笔记(更新：增加排序功能)</title>
    <link href="http://detachment.club/2016/12/28/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://detachment.club/2016/12/28/博客构建笔记/</id>
    <published>2016-12-27T16:00:00.000Z</published>
    <updated>2018-05-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;记录总结学习过程的重要性不言自明。博客正好就是这一过程的体现平台，所以构建并完善这个平台就显得尤为重要了。由于周期性的懒癌发作，所以可惜的是构建此博客的前期并未记录下来，这两天因为开始写年终总结了，所以连续为博客增加了两项功能，至此我认为应该记录一下。</p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一直都知道很多博客有订阅 rss 的功能，但是从来没有使用过，所以前期构建的时候并没有将这个功能作为博客的核心功能。直到邮件订阅了一些网站之后，只要有更新就会自动推送邮件，并且在邮件中就能看到更新的内容。这才感受到这个功能的便捷性，然后决定我也要给我的博客增加这个功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;经过一番探索，经过以下步骤可以实现 rss 及邮件订阅的功能：</p><ol><li>利用 npm 下载安装 hexo-generator-feed 插件，命令如下：<br><code>$ npm install --save hexo-generator-feed</code></li><li><p>在主题配置文件 <code>_config.yml</code> 中增加以下内容：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#Feed configuration</span></span><br><span class="line"><span class="symbol">plugin:</span></span><br><span class="line">- hexo-generator-feed</span><br><span class="line"></span><br><span class="line"><span class="symbol">feed:</span></span><br><span class="line"><span class="symbol">  type:</span> atom      <span class="comment">// Feed type. (atom/rss2)</span></span><br><span class="line"><span class="symbol">  path:</span> atom.xml  <span class="comment">// Feed path. (Default: atom.xml/rss2.xml)</span></span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">20</span>       <span class="comment">// Maximum number of posts in the feed.</span></span><br><span class="line"><span class="symbol">  hub:</span>            <span class="comment">// URL of the PubSubHubbub hubs (Leave it empty if you don't use it)</span></span><br><span class="line"><span class="symbol">  content:</span> true   <span class="comment">// (optional) set to 'true' to include the contents of the entire post in the feed.</span></span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件 <code>_config.yml</code> 中设置 rss 项：<br><code>rss: &quot;/atom.xml&quot;</code></p></li><li>至此，更新部署博客就能看到有 rss 订阅功能了，需要邮件订阅功能则需要从下面一步开始；</li><li>利用 feedbuner 来制作一个feed（如果没有账号可以注册一个或者用谷歌账号登录）：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner1.JPG" alt="第一张图"></li><li>在上图中填入你的博客订阅地址，如下所示：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner2.JPG" alt="第二张图"></li><li>之后直接点击 next 就成功制作了一个feed：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner3.JPG" alt="第三张图"></li><li>制作完之后在种子信息面板开启邮件订阅的功能：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner4.JPG" alt="第四张图"></li><li>至此，你已经得到了两种形式的代码了，根据自己的需要使用到自己的网站上，我使用的是超链接的形式。</li></ol><hr><h3 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这也是一个一直想要的功能，因为很有可能有些博客的重要性比其他的更高，但是由于默认按照时间来排序导致翻页之后才能看到这些文章。正好这两天在捣鼓博客，索性将这个功能也做出来。最开始的时候准备将博客的源码文件捋清楚后自己修改代码，但是打开hexo文件夹一看，打了个哆嗦就把文件夹关了：我是不是傻，为啥不先去搜索一番？<br>&nbsp;&nbsp;&nbsp;&nbsp;果然，一搜就发现有很多人多有这个需求: <a href="https://github.com/iissnan/hexo-theme-next/issues/415" target="_blank" rel="noopener">如何置顶post？</a>。整个帖子看下来的结论是：各种尝试的结果都或多或少有bug，所以此暂时暂时搁置，日后再来开发。不过里面倒是有个链接指出了通用配置方法，这也是目前我所采用的方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">原文写的比较详细</a>，我也就不再多费口舌了，总的来说就是更改排序规则，并将新的变量（top）增加到post的开头部分。经测试，效果不错。</p><hr><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于某些涉及隐私，或者只希望分享给有限人群的博客，加密功能就非常实用了。之前一直没有将这个功能加上来，因为需求没这么迫切。最近准备开始投简历，里面会涉及一些个人信息，但是又希望公司能够通过博客的形式看到简历，这个功能就必不可少了。通过搜索，找到这个一个帖子，基本能满足需求：  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://edolphin.site/2016/05/31/encrypt-post/" target="_blank" rel="noopener">加密博客内容，使用密码访问</a>  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;仔细看了一下这篇博客及对应项目的 GitHub 文档，满足基本需求不成问题，但是有两点不足：第一，官方文档写的不是太好，有些地方不好理解；第二，对于基于 GitHub page 的博客基本无效。然后在 GitHub 上顺藤摸瓜，找出了下面这个项目：   </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">hexo-blog-encrypt</a>    </p><p>&nbsp;&nbsp;&nbsp;&nbsp;文档清晰易懂，开发者响应迅速，最重要的是能够完整加密。如果非要提不足的地方，那就是解密后目录栏不会自动更新。和开发者沟通过，这个需要根据不同的 Hexo 主题进行对应的更改，经过一番尝试后测试失败。由于时间问题，暂时我就不去管它了。<br>&nbsp;&nbsp;&nbsp;&nbsp;所以，如果你也需要为博客设置密码，推荐第二种方式。<br>&nbsp;&nbsp;&nbsp;&nbsp;非常感谢两位开发者做出的探索。</p><hr><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><pre><code>换电脑后写博客没有以前那么方便了，加上懒癌晚期，一直拖着没有把以前电脑上的资源迁移过来，所以大半年都没有写博客了。昨天晚上不知道哪根筋搭错了，终于决定将很久都没有做的事情完成下。看了几篇博客，有些挺难理解的，一步一步尝试做下来总会失败。可能是没有理解其中缘由，也可能是时过境迁，以前的方法不再适用。最终成功的方法来自知乎用户@[skycrown](https://www.zhihu.com/people/skycrown)：[使用hexo，如果换了电脑怎么更新博客？](https://www.zhihu.com/question/21193762)</code></pre><blockquote><p>不知道题主是不是换了新电脑，需要在新电脑上进行部署，如果是，可以参考下面的方法：<br>1、从官网<a href="https://link.zhihu.com/?target=https%3A//git-scm.com/" target="_blank" rel="noopener">Git**</a>下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：<br>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ 把其中的邮件地址换成自己的邮件地址，然后一路回车<br>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。<br>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。<br><strong>注意</strong>：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。<br>2、下载<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/" target="_blank" rel="noopener">Node.js**</a>，并安装<br>3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo<br>4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。<br>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。<strong>总结：</strong>_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。<br>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。<strong>总结：</strong>.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。<br>5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。<br>6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：<br>（1）为了使用hexo d来部署到git上，需要安装<br>npm install hexo-deployer-git –save<br>（2）为了建立RSS订阅，需要安装<br>npm install hexo-generator-feed –save<br>（3）为了建立站点地图，需要安装<br>npm install hexo-generator-sitemap –save<br>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明<br>7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！</p></blockquote><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code>之前已经写过了置顶的功能，逻辑是如果 post 中有 top 字段，那么先比较 top 字段值的大小，然后根据发布时间来进行排序。但是有些文章是在不断修改的，所以我认为按照修改时间来排序是一种更好的策略。对于从来不修改的文章而言，发布时间和更新时间一致，所以都可以满足。因为 Next 默认主题是不显示修改时间的，所以如果需要按照修改时间排序，首先得显示修改时间，这个需求可以在这个问题下找到答案：[如何将首页和归档页的博文按照更新时间排序？](https://github.com/iissnan/hexo-theme-next/issues/1895) 在将修改时间添加到配置文件之后，每篇博客开始的时候就需要将 updated 字段加进去，这块有个坑：**date 和 updated 的值不能一样，否则不会显示。**修改的策略其实和置顶一致，只需要把 `node_modules/hexo-generator-index/lib/generator.js` 中以下部分的 date 改成 update 就行：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码引用自： <a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决Hexo置顶问题</a></p></blockquote><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><p>略</p><h3 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h3><p>略</p><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>最近又收到七牛云的邮件了，说是之前的测试域名马上就要到期了，到期后会收回。为了避免到时候所有的图片都看不到，开始准备把图片迁移，有两种方案，其一：绑定自己的域名；其二，找其他图床。本来想着绑定就绑定吧，也没啥影响，然后发现绑定之前必须要备案才行，也就是说你所有的实名信息都需要提交到工信部，这我就不开心了。虽说也不准备做什么违法乱纪的事情，但总是不想处于这种监管的状态的。所以开始找第二种方案。然后发现了 sm.ms 图床，有很好的 api 支持，找到一篇文章有相关记录，里面很详细的记录了整个配置的过程：<a href="https://spencerwoo.com/2018/01/28/SM-MS/" target="_blank" rel="noopener">SM.MS: 一名优秀的图床的艺术之旅。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;记录总结学习过程的重要性不言自明。博客正好就是这一过程的体现平台，所以构建并完善这个平台就显得尤为重要了。由于周期性的懒癌发作，所以可惜的是构建此博客的前期并未记录下来，这两天因为开始写年终总结了，所以连续为博客增加了两项功能，至此我认为应该记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://detachment.club/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://detachment.club/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="置顶" scheme="http://detachment.club/tags/%E7%BD%AE%E9%A1%B6/"/>
    
      <category term="订阅" scheme="http://detachment.club/tags/%E8%AE%A2%E9%98%85/"/>
    
      <category term="加密" scheme="http://detachment.club/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="迁移" scheme="http://detachment.club/tags/%E8%BF%81%E7%A7%BB/"/>
    
      <category term="排序" scheme="http://detachment.club/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="版权" scheme="http://detachment.club/tags/%E7%89%88%E6%9D%83/"/>
    
      <category term="打赏" scheme="http://detachment.club/tags/%E6%89%93%E8%B5%8F/"/>
    
      <category term="图床" scheme="http://detachment.club/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>写在2016年的尾巴</title>
    <link href="http://detachment.club/2016/12/27/%E5%86%99%E5%9C%A82016%E5%B9%B4%E7%9A%84%E5%B0%BE%E5%B7%B4/"/>
    <id>http://detachment.club/2016/12/27/写在2016年的尾巴/</id>
    <published>2016-12-26T16:00:00.000Z</published>
    <updated>2016-12-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一年的时间过得太快，但足以发生很多很多的事情，这也造成了提笔难言的窘境。如果要叙述一个复杂的故事，最简单的办法就是利用时间作为线索，采用顺序的叙述结构。这种结构同样非常适合年终总结。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;在前言中，我就简单的以时间为线来简单的流水一遍我这一年：</p><ul><li>1-3月：设计制作最后三套轮胎自动搬运设备，3月底辞职；</li><li>4-5月：在w3school上学习html，css，JavaScript的相关知识；重新使用github；</li><li>6-7月：利用视频教程学习JavaScript；搭建博客并将整个学习过程总结到博客上；</li><li>8-9月：学习jQuery，BootStrap并利用所学模仿制作了简历；开始投简历、面试、得到offer并放弃；学习《JavaScript编程精解》；初步接触vue.js；</li><li>10月：学习vue.js及相关工具（router、vuex、loader）；学习webpack的使用；学习git；投简历被拒；</li><li>11月：学习《JavaScript高级程序设计》；尝试利用vue.js制作完整项目遇阻；</li><li>12月：重新学习vue.js并准备做完整的项目，遇阻；学习ES6语法；利用xmind总结vue.js；年终总结。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;上面所提到的虽不全面，但也大体覆盖了这近一年所做的主要努力。下面的正文还将从各个方面来进行总结，从另一个角度来更加全面的回顾这一年所发生的的事情。</p><hr><script src="https://use.fontawesome.com/e4cb940bf3.js"></script><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;下面将从这两个方面来总结：学习工作与生活娱乐。</p><h3 id="学习工作"><a href="#学习工作" class="headerlink" title="学习工作"></a>学习工作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前端学习的内容无外乎语言本身（HTML，CSS 及 JavaScript）的学习及辅助工具应用方面（框架、模块化工具等）的学习，那么就从这两方面来说说目前的情况吧。</p><ul><li><strong>语言本身</strong><ol><li><strong>HTML</strong>：主要从w3s上学习，项目中碰到问题靠搜索解决。对于 HTML5 中新加入的新特征了解但没达到熟悉的程度；   </li><li><strong>CSS</strong>：主要从w3s上学习，了解在 CSS3 中新加入的特征但实践不够；</li><li><strong>JavaScript</strong>：<ul><li><strong>前期</strong>：w3s上学习了一阵子，摸不着头脑。转而到网易云课堂学习了《精通JavaScript开发》，当时自觉已经大概了解了这门语言，现在看来还是 too young，too simple。之后在准备面试的时候看到各种 JavaScript 方面的考题都不会做，然后又开始在网上找资源来学习知识，这时候找到《JavaScript秘密花园》以及汤姆大叔的JS总结博客，如获至宝。又一次 be naive。总结是个升华的过程，而学习基础知识则是升温过程。其实当时也懂得这个道理，只是在希望能尽快找到工作的心态影响下变得浮躁。</li><li><strong>中期</strong>：开始看书，第一本看的是 《JavaScript 编程精解》。书如其名，处处体现一个精字，导致看完一遍之后和朋友切磋的时候被暴虐。因为本书中对很多基础性的概念并没有做出详尽的介绍，所以我看了一遍之后对这些都是一知半解。但不可否认的是，这本书里面的编程技巧让我大开眼界。总而言之：新手不推荐这本书。看的第二本书是《JavaScript高级程序设计》，它为我打开了新世界的大门。这本书深入浅出的为初学者介绍了所需要了解的绝大部分关于 JavaScript 的知识点，看完后我受益匪浅，值得反复阅读、总结。在学 vue.js 做项目的时候发现有大量的 ES6 新增的特性在发挥作用，所以后期也学习了 ES6 规范。学习 ES6 的途径是阮一峰老师的博客。总体而言，对于我这种水平的新手来说，教程难度适中，看过一遍之后能够理解大概80%左右的知识点。所以，对于希望能初步掌握 ES6 规范的学习者来说，我还是很推荐这份教程的。</li><li><strong>后期</strong>：JS 语言的学习将在很长一段时间处于中期阶段，因为很多知识点都需要通过在实践中慢慢的掌握，而这也是目前我所严重欠缺的方面。虽然此阶段的到来还很遥远，不过总体方针还是有的：关注了解与前端相关的知识如服务器端（node.js）以及网络协议等；关心语言的发展趋势，如果可能的话，甚至去影响趋势。</li></ul></li></ol></li></ul><ul><li><p><strong>框架工具学习</strong></p><ol><li><strong>jQuery</strong>：主要通过 w3s 来学习，掌握基本用法，未深究；</li><li><strong>BootStrap</strong>：通过视频及官方文档来学习。有独立项目，其中个人简历即在此阶段完成的；</li><li><p><strong>Vue.js</strong>：仔细看过几遍官方文档并有总结，对基本用法了熟于心。同时也了解关于 Vue.js 的一些辅助插件，如 vuex、vue-router 以及 vue-loader。在很快的一段时间内将会利用这些来完成一个复杂程度较高的完整前端项目。附简单的总结图如下（利用 xMind 制作，如有需要源文件的可以给我发邮件）：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/vuex.png" alt="vue.js"></p><p><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/Vue.png" alt="vue.js"></p></li><li><strong>webpack</strong>：完整的看了一遍文档，并翻译发布了一篇博客，有过少许实践经验。在这个过程中接触到 npm，yarn，gitbook等等；</li><li><strong>git</strong>：熟练使用 git 的基本操作，写过一篇相关博客。</li><li><strong>其他</strong>：了解（基本能看懂代码） bower、gulp、sass、karma、eslint 等，但都没有实践经验。这也是之后需要加强的方面。</li></ol></li></ul><ul><li><strong>博客写作</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;自从6月份开通到现在为止，一共发布了10篇博客，除了两篇为翻译文档，其余全为原创。有一篇访问量超过2500pv，对自己来说也是一个鼓励。以此同时，有多位朋友看过博客后通过邮件和我联系并给于肯定，在此对他们表示感谢，也希望大家在前端学习的路上大家都能越走越远。下面附上一些简单的博客流量图：<br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji1.JPG" alt="tongji"><br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji2.JPG" alt="tongji"><br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji3.JPG" alt="tongji"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;至此，学习工作方面的内容基本上也已经总结的差不多了，接下来继续总结生活娱乐方面。</p><h3 id="生活娱乐"><a href="#生活娱乐" class="headerlink" title="生活娱乐"></a>生活娱乐</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;All work and no play makes Jack a dull boy. 从以下两个方面来总结吧：精神建设以及生活质量。</p><ul><li><p><strong>精神建设</strong></p><ol><li><p><strong>电影</strong>：看电影是一个终生爱好，可能和小时候的经历有关。按照时间顺序简单的总结下今年看过的影片（包括电影和剧集，数据来自豆瓣记录以及下载记录），根据个人喜好推荐加粗部分的电影：</p><ul><li>一月份： <strong>《老炮儿》</strong>《黑金》《我的少女时代》《机械姬》<strong>《走到尽头》</strong>《为了N》（剧集）;</li><li>二月份：<strong>《守望者》</strong>《美国狙击手》《史蒂夫·乔布斯》<strong>《夜行者》</strong>《暗杀》<strong>《视觉》</strong>；</li><li>三月份：《八恶人》《饥饿游戏3：嘲笑鸟》<strong>《聚焦》</strong> <strong>《荒野猎人》</strong>《蝙蝠侠大战超人：正义黎明》<strong>《控方证人》</strong>《功夫熊猫3》；</li><li>四月份：<strong>《纸牌屋 第四季》</strong>；</li><li>五月份：<strong>《危楼愚夫》《成长系列》《盗梦空间》</strong>，其中<a href="https://movie.douban.com/subject/10748226/" target="_blank" rel="noopener">《成长系列》</a>极力推荐；</li><li>六月份：无记录。（可能在 B 站上有看，但是记录不可查）；</li><li>七月份：《危机13小时》《奇幻森林》《人间世》《知无涯者》《行尸走肉》；</li><li>八月份：<strong>《一个叫欧维的男人决定去死》</strong>《红眼航班》<strong>《云图》</strong>；</li><li>九月份：《惊天盗魔团》《寒战2》<strong>《黑客军团2》《心迷宫》</strong>《你眼中的世界》<strong>《杀死一只知更鸟》《阿凡达》</strong>；</li><li>十月份：<strong>《荒野生存》</strong>《黑镜3》《西部世界》《冰血暴2》《毕业生》<strong>《追梦赤子心》</strong></li><li>十一月份：<strong>《我们这一天》</strong>《斯诺登》<strong>《头脑特工队》</strong>《逃避虽可耻但有用》<strong>《七武士》《双峰 第一季》</strong>《双峰 第二季》</li><li>十二月份：<strong>《行星地球2》</strong>《萨利机长》<strong>《梦之安魂曲》《驴得水》《疯狂的麦克斯4》</strong>《豪勇七蛟龙》<strong>《夜班经理》</strong></li></ul><blockquote><p>由于有部分电影在 B 站上看的，导致没有任何记录，所以可能有 10%-20% 左右的电影没有归纳出来。</p></blockquote></li><li><p><strong>书籍</strong>：除了专业书籍之外，还看了一些其他方面的书，以下大概按照时间来排序：</p><ul><li><p><strong>《无声告白》</strong>：这是一本关于家庭教育的书，我认为每个身为人父（母）的人都应该看一看这本书。文章中的心理描写非常精彩，比如下面这一段：</p><blockquote><p>多年来对爱的渴望让她变得敏感，她就像一条饥饿的狗，不停的翕动鼻孔，捕捉着哪怕是最微弱的食物的香气。她不会弄错的。她一看到就认出了它。那是爱，是一厢情愿的深切渴慕，只有付出，得不到回报；是小心翼翼而安静的爱恋，却无所畏惧，无论如何，都会执着的进行下去。  </p></blockquote></li><li><p><strong>《黑客与画家》</strong>：讨论了很多关于计算机以及互联网行业的问题，比如编程语言发展趋势。对我影响不大，看完之后很多内容多忘记了。摘取一段作者对于怎么致富的方法的看法：</p><blockquote><p>要致富，你需要有两样东西：可测量性和可放大性。你的职位产生的业绩，应该是可测量的，否则你做的再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做的决定能够产生巨大的效应。</p></blockquote></li><li><p><strong>《月亮与六便士》</strong>：什么是信仰？什么又是真正的幸福？</p><blockquote><p>难道做自己最想做的事，生活在让你感到舒服的环境里，让你的内心得到安宁是糟践自己吗？难道成为年入上万英镑的外科医生、娶得如花美眷就算是成功吗？我想这取决于你如何看待生活的意义，取决于你认为你应该对社会做出什么贡献，应该对自己有什么要求。</p></blockquote></li><li><p><strong>《自控力》</strong>：这本书通过一系列的实验给我们展示了关于自控力种种方面的研究成果。对于有严重拖延症的人来说，值得一看。摘抄部分结论：</p><blockquote><p>人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学习数学，他就会越来越擅长数学。如果你让他忧虑，他就会越来越忧虑。如果你让他专注，他就会越来越专注。</p></blockquote></li><li><p><strong>《三体全集》</strong>：佩服作者的想象力和知识面，不过不符合个人口味，看了40%左右，弃坑。摘录部分笔记：</p><blockquote><p>也许，人类和邪恶的关系，就是大洋与漂浮于其上的冰山的关系，它们其实是同一物质组成的巨大水体。冰山之所以被醒目的认出来，只是由于其形态不同而已，而它实质上只不过是这整个巨大水体中较小的一部分……人类真正的道德自觉是不可能的，就像他们不可能自己把着自己的头发离开大陆。</p></blockquote></li><li><p><strong>《一个人的朝圣》</strong>：我只是想安安静静的去拜访个老朋友而已，你们这帮记者除了弄个大新闻还会啥？</p><blockquote><p>他发现正是这些普通人的渺小与孤独使他诧异，牵动他内心的温柔。在这个世界上有多少人每天做的事就是不断将一只脚放到另一只脚前面，日子久了，生活便显得平淡无奇。哈罗德无法再否认其实一路上见过的每个陌生人虽然是独特的，却又是一样的，这就是人生的两难。</p></blockquote></li><li><p><strong>《阿城精选集》</strong>：阿城先生的《棋王》《树王》以及《孩子王》都写的非常精彩，其中又以《棋王》最为精彩：</p><blockquote><p>王一生孤身一人坐在大屋子中央，瞪眼看着我们，双手支在膝盖上，铁铸一个细树桩，似无所见，似无所闻。高高的一盏电灯，暗暗地照在他脸上，眼睛深陷进去，黑黑的似俯视大千世界，茫茫宇宙。那生命像聚在一头乱发中，久久不散，又慢慢弥散开来，灼的人脸热。</p></blockquote></li><li><p><strong>《人类简史》</strong>：跳出人类的设定来看人类的发展。不同心态的人看完会有不同的结论，在这个思考的过程会刷新自己的认知。于我而言，这本书让我看问题多了一个角度：上帝视角。摘取《奢侈生活的骗局》中的一段：</p><blockquote><p>有多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背负着巨额贷款，要支付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且生活里面不能没有高级红酒和国外假期。他们该怎么做？他们会放下一切，回去野外挖树根？当然不可能，而是加倍努力，继续把自己累的半死。</p></blockquote></li><li><p><strong>《杀死一只知更鸟》</strong>：先看的书，再看的电影，足见我很喜欢这部作品。从种族歧视的角度探讨何为正义的作品不少，但这本书有着其独特的味道，比如书中的家庭教育。如果我有一个女儿，那么我希望她能够像斯考特一样纯真、勇敢而又具有独立而思辨的灵魂。</p><blockquote><p>勇敢是：当你还未开始就已知道自己会输，可你依然要去做，而且无论如何你都要把它坚持到底。你很少能赢，但有时也会。</p></blockquote></li><li><p><strong>《沉默的大多数》</strong>：这是一本王小波的杂文集，讨论的范围非常广，阅读的过程中能感受到一种思辨的快乐。这本书对我最大的影响是它让我相信一个有智慧的实诚人是可爱的。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恕我直言，能够带来思想快乐的东西，只能是人类智慧至高的产物。比这再低一级的东西，只会给人带来痛苦；而这种低档货，就是出于功利的种种想法。  –《思维的乐趣  第二章》<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我现在当然有自己的善恶标准，而且我现在并不比别人表现的坏。我认为低智、偏执、思想贫乏是最大的邪恶。按照这个标准，别人说我最善良，就是我最邪恶时；别人说我最邪恶时，就是我最善良时。当然，我不想把这个标准推荐给别人，但我认为，聪明、达观、多知的人，比之别样的人更堪信任。  –《思维的乐趣 第四章》<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果说贫穷是种生活方式，捡垃圾和挑大粪只是这种方式的契机。生活方式像是一个曲折漫长的故事，或者使人迷失的迷宫。很不幸的是，任何一种负面的生活都能产生很多乱七八糟的细节，使得他变得有趣；人就在这种趣味中沉沦下去，从根本上忘记了这种生活需要改进。用文化人类学的观点来看，这些细节加在一起，就叫做“文化”。  –《有关贫穷》</p></blockquote></li></ul><p>上面这些书都是看完了的，现在正在看小波的《黄金时代》、张纯如的《南京大屠杀》，已经购买计划要看的有《情人》《菊与刀》《江村经济》《唐吉坷德》等等。</p></li></ol></li><li><p><strong>生活质量</strong></p><ul><li><strong>做饭水平</strong>：经过一年的锻炼，做饭经验丰富；</li><li><strong>健身进展</strong>：对比去年，背阔肌和三头肌有明显进步；最近也加强了对大腿、肩部的锻炼，目前效果不明显；俄式挺身还是没有学会，核心力量太弱；训练的不够系统，整体进步趋于平缓；</li><li><strong>摄影水平</strong>：原地踏步；</li><li><strong>游戏水平</strong>：效率上涨100点，但是浪费太多时间和精力，已决定afk。</li></ul></li></ul><hr><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;2016年还有两天就过完了。这一年，我彻底的改变了自己的职业发展方向，一切从头开始。这一年，虽然过得还不够充实，但每一天都是按照自己的意愿来生活。这一年，胜过了很多年。<br>&nbsp;&nbsp;&nbsp;&nbsp;2017年希望自己和周围的人身体都健健康康。除此之外，也希望自己能够找到一份适合自己的工作，实现自己的价值。<br>&nbsp;&nbsp;&nbsp;&nbsp;最后套用一句小波的话来结束整篇文章：虽然人生在世会有种种不如意，但你仍可以在幸福与不幸中做出选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;新年快乐~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一年的时间过得太快，但足以发生很多很多的事情，这也造成了提笔难言的窘境。如果要叙述一个复杂的故事，最简单的办法就是利用时间作为线索，采用顺序的叙述结构。这种结构同样非常适合年终总结。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://detachment.club/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript" scheme="http://detachment.club/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue.js" scheme="http://detachment.club/tags/Vue-js/"/>
    
      <category term="ES6" scheme="http://detachment.club/tags/ES6/"/>
    
      <category term="2016" scheme="http://detachment.club/tags/2016/"/>
    
  </entry>
  
  <entry>
    <title>怎样利用 git 撤销操作</title>
    <link href="http://detachment.club/2016/10/29/%E6%80%8E%E6%A0%B7%E5%88%A9%E7%94%A8%20git%20%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://detachment.club/2016/10/29/怎样利用 git 撤销操作/</id>
    <published>2016-10-28T16:00:00.000Z</published>
    <updated>2016-10-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于版本管理系统而言，最重要的一个特性之一就是能够撤销错误的操作。在 git 中，撤销有很多种可能的意思。<br>&nbsp;&nbsp;&nbsp;&nbsp;每当你做出一个 提交 的时候，git 都会立即在你的 repository 保存一个快照，之后你就可以通过 git 来恢复到这个项目的前一个版本了。<br>&nbsp;&nbsp;&nbsp;&nbsp;这下面这篇文章中，我将会就几种常见的情景来讨论怎样通过 git 来完美的撤销这些操作。</p><a id="more"></a><h2 id="不同情况"><a href="#不同情况" class="headerlink" title="不同情况"></a>不同情况</h2><h3 id="撤销已发布"><a href="#撤销已发布" class="headerlink" title="撤销已发布"></a>撤销已发布</h3><p><strong>情景</strong>：你刚按下 <code>git push</code> ，将修改推送到了 github ，然后就发现在你的提交中存在一些问题。这时候那就会想撤销操作。</p><p><strong>解决</strong>： <code>git revert &lt;SHA&gt;</code></p><p><strong>原理</strong>： <code>git revert &lt;SHA&gt;</code> 这个操作会生成一个新的 commit，这个提交和 提供的 SHA 是相反的：如果之前的提交是 “matter”，那么这个提交就是 “anti-matter”，也就是说之前操作中新增的内容将会被删除，之前操作中被删除的内容也将会被增加。</p><p>这是 git 中最基础也最安全的撤销操作情景，因为它不会 <em>改动</em> 变更历史——你可以放心的使用 <code>git push</code> “相反的”提交来撤销你错误的操作。</p><hr><h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><p><strong>情景</strong>：你把提交信息的最后一个字打完：<code>git commit -m &quot;Fxies bug #42</code>，提交之后推送之前，你发现你的提交信息出错了，应该是：<code>Fixes bug #42</code>。这时候你也会想到撤销操作。</p><p><strong>解决</strong>：<code>git commit --amend or git commit --amend -m &quot;Fixes bug #42&quot;</code></p><p><strong>原理</strong>：<code>git commit --amend</code> 操作会用一个新的提交来更新、替换上一个提交。如果新提交的内容中有已处于可提交状态的修改，那么也会一并提交；如果没有，那么只需要重写上一次的提交信息即可。</p><hr><h3 id="撤销本地操作"><a href="#撤销本地操作" class="headerlink" title="撤销本地操作"></a>撤销本地操作</h3><p><strong>情景</strong>：一只喵从键盘上走过，不小心保存了修改，然后很巧的是 IDE 此时崩溃退出了。这时候你还没有提交，你希望能够将这个文件中所有的修改都撤销——直到恢复成上一次提交的状态。</p><p><strong>解决</strong>：<code>git checkout -- &lt;bad filename&gt;</code></p><p><strong>原理</strong>：<code>git checkout</code> 指令会将工作文件夹中的这个文件恢复成在 Git 中上一次保存的状态。你可以提供一个确切的分支名，或者是需要恢复到的 SHA。如果都省略，Git 就默认是恢复到 HEAD ——也就是目前分支的上一次提交状态。</p><p><strong>注意</strong>：利用这种方法所做的任何撤销都是真的撤销了。因为没有提交操作，所以 Git 之后也没办法来恢复了。用这种方法的时候一定要确定你所需要撤销的到底是什么！（你可以利用 <code>git diff</code> 来确认提交信息）</p><hr><h3 id="重置本地操作"><a href="#重置本地操作" class="headerlink" title="重置本地操作"></a>重置本地操作</h3><p><strong>情景</strong>：你在本地提交过几次（但还没有推送），然后你发现这些都是垃圾，然后你想撤销最近三次的提交——就好像它们从来没发生过一样。</p><p><strong>解决</strong>：<code>git reset &lt;last good SHA&gt; or git reset --hard &lt;last good SHA&gt;</code></p><p><strong>原理</strong>：<code>git reset</code> 操作会让你的项目历史记录回滚到指定的 SHA，就像这些提交从来没有发生过一样。默认状态下，这个操作会将工作目录保存下来，这时候提交虽然没有了，但是这些提交的内容还是存在硬盘上的。这是最安全的做法，但是很多时候，你需要同时撤销提交并同时删除这些文件——这时候就需要加上 <code>--hard</code> 了。</p><hr><h3 id="重置本地操作后恢复"><a href="#重置本地操作后恢复" class="headerlink" title="重置本地操作后恢复"></a>重置本地操作后恢复</h3><p><strong>情景</strong>：你已经提交了一些修改，然后发现不对，就利用上面的方法撤销了提交。这时候你又发现：我要撤销刚刚的撤销！</p><p><strong>解决</strong>：<code>git reflog and git reset or git checkout</code></p><p><strong>原理</strong>：<code>git reflog</code> 是一种非常好的用于恢复项目历史记录的办法。通过这个办法，几乎可以恢复任何已经提交过的修改。</p><p>你可能对用于显示不同提交的 <code>git log</code> 指令比较熟悉，而 <code>git reflog</code> 也是类似的，区别在于，它显示的是 <code>HEAD</code> 的修改情况列表。</p><p>注意点：</p><ul><li>只有 .HEAD 文件被修改时 HEAD 才会修改，这些情况包括：切换分支、通过 <code>git commit</code> 提交、通过 <code>git-reset</code> 恢复。需要注意的是通过 <code>git checkout --&lt;bad filename&gt;</code> 操作并不会修改 HEAD（上面的方法中提到过这个操作不会被提交），所以 reflog 方法这时候不适用。</li><li><code>git reflog</code> 不会被永久保存。Git 内部每隔一段时间就好清理一些无法识别的对象。所以不要指望几个月前的提交记录能够永远在 reflog 中找到。</li><li>你的 <code>reflog</code> 仅仅只能你自己使用。你无法通过这个指令来恢复其他开发者尚未推送的提交。</li></ul><p><img src="https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png" alt=""></p><p>那么，回到正题，怎样通过 <code>git reflog</code> 来达到撤销已撤销的目的呢？这还得根据不同的情况讨论：</p><ul><li>如果你想将项目历史恢复成特定时候的状态，使用 <code>get reset -hard &lt;SHA&gt;</code></li><li>如果你想在你的工作目录下重新创造一些和之前一样的文件，同时不更改项目记录，那么就用 <code>git checkout &lt;SHA&gt; --&lt;filename&gt;</code></li><li>如果你想重新提交一个确切的操作到你的项目，那就是用 <code>git cherry-pick &lt;SHA&gt;</code></li></ul><hr><h3 id="修改合并分支"><a href="#修改合并分支" class="headerlink" title="修改合并分支"></a>修改合并分支</h3><p><strong>情景</strong>：你提交了一些修改，然后发现提交到了 master 分支，而你本来是想提交到一个叫做 feature 的分支上。</p><p><strong>解决</strong>：<code>git branch feature, git reset --hard origin/master, and git checkout feature</code></p><p><strong>原理</strong>：你可能比较习惯使用 <code>git checkout -b &lt;name&gt;</code> 来建立并切换到新建立的分支上——然而，有时候你并不希望立刻切换到新建立的分支。通过 <code>git branck feature</code> 创建了一个叫做 feature 的分支，这也是你将要合并提交的分支，而且这样操作，目前所在的分支还在 master 上（并没有切换到 feature）。<br>然后，通过 <code>git reset --hard</code> 将 master 分支回滚到之前 origi/master 未提交的状态。不过不要担心，在 feature 分支上，这些提交还是有的。<br>最后，通过 <code>git checkout</code> 指令将分支切换至 feature，然后你就可以开心的进行提交了。</p><hr><h3 id="同步更新分支"><a href="#同步更新分支" class="headerlink" title="同步更新分支"></a>同步更新分支</h3><p><strong>情景</strong>：你在本地分支 master 的基础上新建了一个叫做 feature 的分支，但是这时候的本地分支 master 比远程主机上的 origin/master 分支落后几个版本。然后你将本地 master 分支同步至 origin/master，然后你希望这时候提交到 feature 分支上的修改能够在现在这个状态的基础上，而不是之前落后几个版本的状态。</p><p><strong>解决</strong>：<code>git checkout feature and git rebase master</code></p><p><strong>原理</strong>：你本来可以这样做：首先利用 <code>git reset</code>（后面故意不加 –hard，这样的话 master 虽然回滚到上个版本但是硬盘上这些可提交的修改并没有删除），然后通过 <code>git checkout &lt;branch name&gt;</code> 切换至 feature 分支，最后在这个分支上重新提交（以达到和之前 master 分支一样的状态）。通过这种办法可以达到目的，但是你会失去提交历史。下面有一个更好的方法。</p><p><code>get rebase master</code> 操作会执行很多事情：</p><ul><li>首先在目前所在分支和本地 master 分支之间确定谁是谁的父级；</li><li>然后将目前所在分支的状态重置成父级的状态，并把之后的提交都暂时保存在一个区域；</li><li>最后更新升级到和 master 分支最新状态一样，然后重新操作暂时保存区域的提交。</li></ul><hr><h3 id="大量的撤销-恢复操作"><a href="#大量的撤销-恢复操作" class="headerlink" title="大量的撤销/恢复操作"></a>大量的撤销/恢复操作</h3><p><strong>情景</strong>：你从某个方向来开始了一项研究，研究到一半，你发现另一种方法会更好。这时候你已经提交了几次了，而你其实并不完全需要它们。所以你希望其中的一些提交完全消失。</p><p><strong>解决</strong>：<code>git rebase -i &lt;earlier SHA&gt;</code></p><p><strong>原理</strong>：-i 指令将 rebase 指令转入一种可交互模式。rebase 指令的作用前几步和上面都一样，唯一不一样的是在合并提交的时候，它会暂停然后让你选择需要合并的提交。</p><p><code>rebase -i</code> 会打开默认文本编辑器，文本中会列出可合并的提交，如下：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953863/f6b1ab88-d891-11e4-97c1-e0630ac74e74.png" alt=""></p><p>前面两列是包含着关键信息：第一个是用来提交操作的指令，第二个是提交操作的 SHA 的值。利用 <code>rebase -i</code> 合并操作的默认指令是 <code>pick</code>。</p><p>对于不想要的提交，你只需要在文本编辑器中删除对应的内容。如上面这张图，如果你不想要错误的提交，那就删除1、3、4这三行。</p><p>如果你想保持提交的内容但是想修改提交的提交信息，那你可以使用 <code>reword</code> 命令。只需要在第一列中替代 <code>pick</code>。虽然立即就改写提交信息听起来很爽，但是实际上并没有用，因为 <code>rebase -i</code> 会将 SHA 后面的信息都无视掉。这个文本只是用来提醒我们这个提交的内容是什么，在执行完 <code>rebase -i</code> 命令之后，就可以改写任意的提交信息了。</p><p>如果你想将两个提交合并，你可以使用 <code>squash</code> 或者 <code>fixup</code> 指令，如下：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953865/f6b605ca-d891-11e4-98cf-d567ca9f4edc.png" alt=""></p><p>这两个指令都会使得对应的提交和它之前的提交结合成一个提交。在上面的例子中，第一个和第二个会结合成一个提交，然后第三个和第四个也会结合成一个提交。</p><p>当使用 <code>squash</code> 时， Git 会让我们给新合并的提交一个新的提交信息；当使用 <code>fixup</code> 的时候，Git 会自动将列表中将合并的提交的最开始的提交信息作为新的提交信息。拿上图为例，前两个合并时需要输入一个新的合并提交的信息，而后两个合并时，会自动将第三个提交信息作为合并后的提交信息。</p><p>当你保存然后关闭文本编辑器的时候， Git就会依次执行编辑器中的内容。如果你希望更改合并的顺序，只需要在文本编辑器中改动。拿上图为例，如果你想合并 <code>af67f82</code> 和 <code>0835fe2</code> ，你只需要这样更换顺序：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953864/f6b4a9d2-d891-11e4-9ac9-10039c031d06.png" alt=""></p><hr><h3 id="更改早先的提交"><a href="#更改早先的提交" class="headerlink" title="更改早先的提交"></a>更改早先的提交</h3><p><strong>情景</strong>：你突然想起来，如果在之前的一次提交中加入某一个文件效果会更好。这时候你还没有推送这个提交，而这个提交并不是最近的一次，所以不能用 <code>commit --amend</code></p><p><strong>解决</strong>：<code>git commit --squash &lt;SHA of the earlier commit&gt; and git rebase --autosquash -i &lt;even earlier SHA&gt;</code></p><p><strong>原理</strong>：利用 <code>git commit --squash</code> 可以创建一个新的提交并有类似这样的提交信息 <code>squash! Earlier commit</code>(你可以手动输入像这样的提交信息，但是使用 <code>commit --squash</code> 可以让你少打一些字 。)</p><p>你也可以使用 <code>git commit --fixup</code> 指令来操作，利用这个指令不需要手动输入提交信息。这上面这个情境中，利用这个指令更好一些，因为不需要更改提交信息。</p><p>利用 <code>rebase --autosquash -i</code> 指令，然后会打开默认的文本编辑器，而且里面已经包含了提交信息，如下图：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953862/f6a7a1d8-d891-11e4-8784-c32262ff54da.png" alt=""></p><p>当你使用 <code>squash</code> 或者 <code>fixup</code> 指令的时候，你可能不知道你需要合并的提交的 SHA —— 你只记得是一次还是五次之前。这时候操作符 <code>^</code> 和 <code>~</code> 就很方便了。<code>HEAD^</code> 表示 HEAD 之前的一次， <code>HEAD~4</code> 表示的是 HEAD 的前四个提交，也就是倒数第五次提交（因为 HEAD 本身是倒数第一次）。</p><hr><h3 id="停止对已监测文件的监测"><a href="#停止对已监测文件的监测" class="headerlink" title="停止对已监测文件的监测"></a>停止对已监测文件的监测</h3><p><strong>情景</strong>：你最近将 <code>application.log</code> 加入到了仓库中，然后现在每次运行这个程序， Git 就会提示在这个文件中有未处于提交状态的修改。虽然你将 <code>*.log</code> 写入了 <code>.gitignore</code> 文件，但是情况并没有变化。要怎么才能让 git 放弃监测这个文件的变化呢？</p><p><strong>解决</strong>：<code>git rm --cached application.log</code></p><p><strong>原理</strong>：<code>.gitignore</code> 会使得 Git不去监测文件的变化，对于之前没有检测过的文件，它甚至会无视文件的存在。只要文件被提交了， Git 就会持续监测它的变化。类似的，如果利用 <code>git add -f</code> 或者覆盖 <code>.gitignore</code> 文件，那么 Git 也会监测这些文件的变化。</p><p>如果你想使得那些本不应该被监测的文件脱离监测，那么你可以使用 <code>git rm --cached</code> 指令。利用这个指令会停止 Git 对它的监测，同时这个文件在硬盘上不受影响。由于这个文件现在不被监测了，所以利用 <code>git status</code> 不能看到这个文件了。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这是一篇译文，原文地址为： <a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="noopener">How to undo (almost) anything with Git</a>。由于自己碰到了这方面的问题，然后搜索过程中发现了这片文章，写的很全面，所以就翻译了一下。翻译的过程中可能会有一些理解上的偏差，欢迎盆友们指正。</p><blockquote><p><strong>commit：</strong>  在文中被翻译为 提交<br>  <strong>push：</strong> 在文中被译为 推送</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于版本管理系统而言，最重要的一个特性之一就是能够撤销错误的操作。在 git 中，撤销有很多种可能的意思。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;每当你做出一个 提交 的时候，git 都会立即在你的 repository 保存一个快照，之后你就可以通过 git 来恢复到这个项目的前一个版本了。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这下面这篇文章中，我将会就几种常见的情景来讨论怎样通过 git 来完美的撤销这些操作。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="git" scheme="http://detachment.club/tags/git/"/>
    
      <category term="工具" scheme="http://detachment.club/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="github" scheme="http://detachment.club/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>webpack学习指南</title>
    <link href="http://detachment.club/2016/10/17/webpack%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>http://detachment.club/2016/10/17/webpack学习指南/</id>
    <published>2016-10-16T16:00:00.000Z</published>
    <updated>2016-10-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;前端工程化已成为趋势，善于使用各种工具无疑能极大的提高工作效率，所以这段时间将陆续会有几篇关于这些工具的介绍文章，文章的内容大多是关于这些工具的文档的翻译。<br>&nbsp;&nbsp;&nbsp;&nbsp;本文所有资料来源都是 webpack 官网，有意看原文的戳链接： <a href="http://webpack.github.io/docs/.html" target="_blank" rel="noopener">webpack document</a></p><a id="more"></a><h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>现在的网页应用有以下特点：</p><ul><li>有越来越多的JavaScript代码；</li><li>现代浏览器能提供越来越多的接口；</li><li>虽然有越来越多的代码，但很少会一次加载完。  </li></ul><p>这些代码需要得到有序管理，模块系统随之产生。</p><p>在JavaScript中，有许多不同的方式用来引入数据以及定义依赖关系，常见的有以下几种：</p><ul><li>通过<code>&lt;script&gt;</code>标签引入（没有模块系统）</li><li>CommonJS</li><li>AMD及其相关</li><li>ES6模块</li><li>其他……</li></ul><p><strong> <code>&lt;script&gt;</code> 标签</strong></p><p>如果不利用模块系统的话，通过<code>&lt;script&gt;</code>标签引入如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"libraryA.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module3.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这些数据的接口将连接到全局对象中。常见的问题如下：</p><ul><li>在全局对象中产生冲突；</li><li>数据引入顺序非常重要；</li><li>开发者需要手动管理引入模块的依赖关系；</li><li>在数据较多的情况下会导致引入列表过长，难以管理。</li></ul><p><strong>CommonJS：同步请求</strong>  </p><p>通过利用<code>require</code>方法来加载依赖，同时返回一个接口，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"module"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"../file.js"</span>);</span><br><span class="line">exports.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = someValue;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>服务器端的模块可以重用</li><li>有很多已写好的模块（npm）</li><li>简单易用</li></ul><p>缺点：</p><ul><li>网络的阻塞调用效果不太好，而且网络请求是异步的</li><li>复合模块不能并行请求</li></ul><p>应用：</p><ul><li>node.js</li><li>browerify</li><li>modules-webmake</li><li>wreq</li></ul><p><strong>AMD：异步请求</strong>  </p><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">异步的模块的定义</a><br>有一些浏览器在处理同步引入模块时会有一些问题，为此引入了异步加载模块，具体方式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">define(<span class="string">"mymodule"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>特点：</p><ul><li>符合异步加载网络请求的模式</li><li>并行加载符合模块</li></ul><p>缺点：  </p><ul><li>读写难度较大</li><li>类似于一种变通方式  </li></ul><p>应用：  </p><ul><li>require.js</li><li>curl</li></ul><p>更多关于<a href="http://webpack.github.io/docs/commonjs.html" target="_blank" rel="noopener">CommonJS</a>以及<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a>的内容。</p><p><strong>ES6模块</strong></p><p>ES6加入了一些JavaScript构造器，这就组成了一种模块系统，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"jquery"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">module</span> <span class="string">"localModule"</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>特点：</p><ul><li>静态分析变得简单</li><li>指明了ES标准的方向</li></ul><p>缺点：</p><ul><li>本地浏览器支持还需要时间</li><li>已有的模块较少</li></ul><p><strong>转移</strong></p><p>因为模块需要在客户端执行，那么就必须将它们从服务器端转移到浏览器端。<br>有两种极端的转移情况：</p><ul><li>每个模块一个请求</li><li>所有的模块在一个请求</li></ul><p>这两种情况都是存在的，但都不是最优的：</p><ul><li>每个模块一个请求：<ul><li>优点：按需加载模块</li><li>缺点：更多的请求以为着更多的工作量</li><li>缺点：应用启动速度慢</li></ul></li><li>所有模块在一个请求：<ul><li>优点：请求工作量较少，延迟较低</li><li>缺点：不需要（或暂不需要）的模块也会被一并加载</li></ul></li></ul><p><strong>Chunked 转移方式</strong></p><p>面对上面两种方式所带来的问题，在大多数的案例中，采用折中的方案会取得比较好的效果。</p><p>→ 编译所有模块:将模块组合分成较小一些的组（chunks）。<br>这样做能够使得初始化是没有被请求的数据在被请求时再加载，能起到加快启动速度的同时加载比需要更多的代码。</p><p>“代码分割点”可以由开发者自己决定。</p><p>→  大代码库成为可能！</p><p>注：这个构思来自于 <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting" target="_blank" rel="noopener">Google’s GWT.</a></p><p>更多关于 <a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="noopener">代码分割。</a></p><p><strong>为什么只应用在JavaScript？</strong></p><p>为什么模块系统仅仅用于管理JavaScript？还有许多其他资源需要管理：</p><ul><li>样式</li><li>图片</li><li>字体</li><li>html文件</li><li>等等  </li></ul><p>以及转化过或者处理过的：</p><ul><li>coffeescript → JavaScript</li><li>elm → JavaScript</li><li>less stylesheets → css stylesheets</li><li>等等</li></ul><p>这些处理起来非常简单，如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">"./style.css"</span>)<span class="comment">;</span></span><br><span class="line">require(<span class="string">"./style.less"</span>)<span class="comment">;</span></span><br><span class="line">require(<span class="string">"./template.jade"</span>)<span class="comment">;</span></span><br><span class="line">require(<span class="string">"./image.png"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>想达到这种效果，需要用到loader，更多阅读 <a href="http://webpack.github.io/docs/using-loaders.html" target="_blank" rel="noopener">loader。</a></p><hr><h3 id="Webpack及安装"><a href="#Webpack及安装" class="headerlink" title="Webpack及安装"></a>Webpack及安装</h3><p><strong>Webpack介绍</strong></p><p><strong>Webpack是一种模块打包机。</strong><br>Webpack用于处理有依赖关系的模块，它会生成一些静态文件来表示这些模块。简单而言，如下图所示：<br><img src="http://webpack.github.io/assets/what-is-webpack.png" alt="Webpack"></p><p><strong>为什么还需要模块打包机？</strong><br>简单而言，是因为现在的打包机无法满足大型的单页应用。而真正促使开发新型打包机的原因是代码分割和静态文件在模块化的过程中需要无缝连接。我尝试过拓展现存的打包机，但是都不能达到这些要求（注：Webpack作者）。</p><p><strong>目标</strong>  </p><ul><li>将依赖分割成不同的chunk，按需加载</li><li>让初始加载时间较少</li><li>每个静态文件都应该是一个模块</li><li>能将第三方的库整合成模块</li><li>打包机本身可高度定制</li><li>适合大型项目</li></ul><p><strong>Webpack有什么不同？</strong>  </p><p><a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="noopener">代码分割</a><br>Webpack的依赖关系有两种类型：同步和异步。<br>异步依赖相当于分割点，会形成一个新的chunk。当chunk之间的关系最优化之后，每个chunk都会有一个相关文件。   </p><p><a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">Loaders</a><br> Webpack只能在本地处理JavaScript，而利用loaders能够将其他资源转化成JavaScript，通过这种手段，所有的资源都能形成模块。  </p><p><strong>智能解析</strong><br>Webpack的智能解析功能使得它基本上能够处理所有第三方库，甚至允许模块以下面这种方式来表示依赖关系：<code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;).</code>它能兼容常见的模块模式，如 <a href="http://webpack.github.io/docs/commonjs.html" target="_blank" rel="noopener">CommonJS</a> 以及 <a href="http://webpack.github.io/docs/amd.html" target="_blank" rel="noopener">AMD</a>。</p><p><a href="http://webpack.github.io/docs/plugins.html" target="_blank" rel="noopener">插件系统</a><br>Webpack的强大离不开其强大的插件系统的支持。这也使得Webpack具有高度定制性，也吸引人们创造更多的开源插件</p><p><strong>安装</strong><br><strong>node.js</strong><br>首先安装 <a href="http://nodejs.org/" target="_blank" rel="noopener">node.js</a>，里面包含了一种包管理工具，叫做npm。  </p><p><strong>Webpack</strong><br>用npm来全局安装Webpack，全局安装的话就可以在全局环境中直接用 <code>Webpack</code> 命令了，命令行如下：<br><code>$ npm install webpack -g</code>  </p><p><strong>在项目中引入</strong><br>做项目的时候最好以项目依赖的方式引入Webpack，那样的话就不会去依赖全局的Webpack了。<br>首先利用npm新建一个package.json配置文件，命令行如下：<br><code>$ npm init</code><br>上面提到的项目依赖的方式安装Webpack可以通过以下命令行实现：<br><code>$ npm install webpack --save-dev</code></p><p><strong>版本</strong><br>有两个版本的Webpack可供下载，一个是稳定版本，另一个是测试版本。测试版本有<code>-beta</code>的后缀，这个版本会包含一些带有实验性质的性能，而且也没有经过大量的测试。所以建议对稳定性能要求较高的同志们选择稳定版本，命令行如下：<br><code>$ npm install webpack@1.2.x --save-dev</code></p><p><strong>开发者工具</strong><br>如果需要使用开发者工具，就需要安装了，命令行如下：<br><code>$ npm install webpack-dev-server --save-dev</code></p><hr><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>安装</strong><br>上面已经提到可全局安装或者以项目依赖的方式安装。在实际项目中，建议都以项目依赖的方式安装，本文为了方便展示，都是以全局安装为例的。  </p><p><strong>开始使用</strong>  </p><ul><li><p>首先用CommonJS语法创建一个模块化的JavaScript项目，名字为<code>cat.js</code>，代码如下：  </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cats.js</span></span><br><span class="line"><span class="keyword">var</span> cats = [<span class="string">'dave'</span>, <span class="string">'henry'</span>, <span class="string">'martha'</span>];</span><br><span class="line">module.<span class="keyword">exports</span> = cats;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js(Entry Point)</span></span><br><span class="line">cats = <span class="built_in">require</span>(<span class="string">'./cats.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cats);</span><br></pre></td></tr></table></figure><p><code>Entry Point</code>是项目接入模块的入口，Webpack也是从这个接口开始检查各个模块之间的依赖关系的。</p></li><li><p>打包文件：Webpack需要指定入口文件（app.js），同时也需要明确的指定输出文件的名字（app.bundle.js），指令如下：<br><code>webpack ./app.js app.bundle.js</code><br>然后Webpack会解读入口文件同时分析其依赖（以及依赖的依赖），分析完以后，会将所有的依赖绑定输出到输出文件中（本例为app.bundle.js）。<br><img src="https://dtinth.github.io/webpack-docs-images/usage/how-it-works.png" alt="webpack"></p></li><li><p>然后就可以运行了，在node中运行及结果如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">app</span>.bundle.js</span><br><span class="line">[<span class="string">"dave"</span>, <span class="string">"henry"</span>, <span class="string">"martha"</span>]</span><br></pre></td></tr></table></figure><p>当然了，也可以在浏览器的环境下运行。  </p></li></ul><p><strong>使用进阶</strong><br>webpack具有很多高级功能，很多功能通过命令行工具很难体现出来，这时候我们就需要去创建配置文件了。</p><ul><li><p>项目结构：在实际的生产环境中，我们会将源文件和输出文件放在不同的文件夹中以便于管理，典型的例子如下图所示：<br><img src="https://raw.githubusercontent.com/dtinth/webpack-docs-images/2459637650502958669ea6b11bf49dc0b3b083ae/usage/project-structure.png" alt="folders"></p><blockquote><p><em>在实际的生产环境中会有很多类似但并不完全相同的项目结构，比如有些项目会将 src 文件夹命名为 APP ，会将 bin 文件夹命名为 dist 或者是 build ，等等诸如此类，其实都是一样的。</em></p></blockquote></li><li><p>配置文件：当项目变得越来越庞大复杂的时候，手动设置这些就显得不是那么明智了，这时候可以创建一个配置文件，名字叫做<code>webpack.config.js</code>:</p><ol><li><p>创建一个<code>webpack.config.js</code>的配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    entry: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'./bin'</span>,</span><br><span class="line">        filename: <span class="string">'app.bundle.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>将配置文件放在合适的位置，现在运行webpack只需要以下代码：<br><code>webpack</code><br>然后webpack就会去解析配置文件，并按照配置文件中的配置来解读接入文件以及输出文件到指定位置。</p></li></ol></li><li><p>引入loaders：webpack本身只支持JavaScript模块，为了支持其他模块，就需要引入各种loader了。loader能够将其他资源加载成webpack能够识别的JavaScript。典型的例子如 babel-loader，json-loader等，如下图：<br><img src="https://dtinth.github.io/webpack-docs-images/usage/babel-loader.png" alt="babel-loader"><br><img src="https://dtinth.github.io/webpack-docs-images/usage/json-loader.png" alt="json-loader"><br><img src="https://dtinth.github.io/webpack-docs-images/usage/yaml-loader.png" alt="yaml-loader"></p></li><li><p>以babel-loader为例说明如下：</p><ol><li>安装Babel：<br><code>npm install --save-dev babel-core babel-preset-es2015</code></li><li>安装babel-loader：<br><code>npm install --save-dev babel-loader</code></li><li>新建一个.babelrc文件，这个文件用来配置Babel，使其利用预先设置的语法（es2015）来解析。.babelrc的内容如下：<br><code>{ &quot;presets&quot;: [ &quot;es2015&quot; ] }</code></li><li><p>更改 webpack.config.js 文件，使的所有的 .js 文件都用 babel-loader 来处理：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">module.exports</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  entry:</span> <span class="string">'./src/app.js'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  output:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">'./bin'</span><span class="string">,</span></span><br><span class="line"><span class="attr">      filename:</span> <span class="string">'app.bundle.js'</span><span class="string">,</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  module:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      loaders:</span> <span class="string">[&#123;</span></span><br><span class="line"><span class="attr">          test:</span> <span class="string">/\.js$/,</span></span><br><span class="line"><span class="attr">          exclude:</span> <span class="string">/node_modules/,</span></span><br><span class="line"><span class="attr">          loader:</span> <span class="string">'babel-loader'</span></span><br><span class="line">      <span class="string">&#125;]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><em>注意：这里讲node_modules文件排除在外了，因为不排除的话，这些外部的插件库也会被Babel处理，从而减缓编译速度</em>  </p></blockquote></li><li><p>安装所需要的其他库（以jQuery为例）：<br><code>npm install --save jquery babel-polyfill</code></p><blockquote><p><em>注意：这里没有用 –save-dev，因为这些库只有在项目运行时才会使用，同时为了能在低版本的浏览器中使用ES6的特性，这里安装了babel-ployfill。</em></p></blockquote></li><li><p>编辑 <code>src/app.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;</span><br><span class="line"><span class="keyword">import</span> cats <span class="keyword">from</span> <span class="string">'./cats'</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'&lt;h1&gt;Cats&lt;/h1&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">const</span> ul = $(<span class="string">'&lt;ul&gt;&lt;/ul&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> cat <span class="keyword">of</span> cats) &#123;</span><br><span class="line">    $(<span class="string">'&lt;li&gt;&lt;/li&gt;'</span>).text(cat).appendTo(ul);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用webpack来打包模块：<br><code>webpack</code></p></li><li><p>创建一个index.html文件，并将打包好的文件引入，以便于在浏览器中展示出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;script src="bin/</span>app.bundle.js<span class="string">" charset="</span>utf<span class="number">-8</span><span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>当打开index.html时，不出意外的话会看到下图：<br><img src="https://dtinth.github.io/webpack-docs-images/usage/cats.png" alt="cats"></p></li></ol></li><li><p>引入插件：在实际生产环境中，我们可能会需要使用一些插件来处理打包好的文件，比如说我们可能会想压缩文件以便于更快的加载速度，这时候就需要使用插件了，以 <code>uglify</code> 插件为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'./bin'</span>,</span><br><span class="line">        filename: <span class="string">'app.bundle.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">            compress: &#123;</span><br><span class="line">                warnings: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            output: &#123;</span><br><span class="line">                comments: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>由于webpack本身自带 Uglify 这个插件，所以使用时不需引入，但是如果需要使用其他没有内置的插件的时候，还是需要手动引入的，而且自己也可以写插件。</p><hr><h3 id="使用-Loaders"><a href="#使用-Loaders" class="headerlink" title="使用 Loaders"></a>使用 Loaders</h3><p><strong>什么是 loaders ？</strong><br>loaders是一些对你的项目中的资源进行转化的工具，它们是一些把源文件的路径作为参数的函数，然后通过函数返回新的路径。<br>例如，webpack中可以通过使用loader来加载CoffeeScript或者是JSX。</p><p>loader的特征：</p><ul><li>loaders 可以链式应用（如上一节提到的.yml文件的解析）。链式应用的中间文件的格式可以是任意的，只要最后输出的格式是JavaScript格式即可</li><li>loaders 可以是同步的或者是异步的；</li><li>loaders 可以在nodejs环境下运行，也可以实现所有可能实现的功能；</li><li>loaders 可接受查询参数，可以利用这个功能来配置loader；</li><li>loaders 可以在配置文件中被绑定到正则表达式或者扩展中；</li><li>loaders 可以通过npm来发布或者是安装；</li><li>一般的模块都可以通过 <code>package.json loader</code> 在输出<code>main</code>之外还输出一个 loader ；</li><li>loaders 可以读取配置文件；</li><li>插件可以使 loaders 的功能更强大；</li><li>loaders 可以生成任意的附加文件；</li><li><a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">等等</a></li></ul><p><strong>解析loaders</strong><br>loaders 的解析方式和模块类似，loader 模块一般会输出一个 nodejs 能够识别的函数。通常情况下我们会用 npm 来管理 loaders ，但是我们也可以以文件的形式直接放在应用文件夹中。</p><ul><li><p>引用 loaders<br>按照惯例，我们通常将 loaders 命名为<code>xxx-loader</code>其中 xxx 表示的就是具体的名称，比如 <code>json-loader</code>。在引用的时候，既可以用全名，也可以用简写（不包括loader部分）。<br>loader 的命名规则以及搜索优先顺序被定义在 webpack 配置 API 文件 <code>resolveLoader.moduleTemplates</code> 中。<br>loader 的命名规则有时候会派上用场，尤其是利用 <code>require()</code> 来引用它们的时候。</p></li><li><p>安装 loaders<br>只要 npm 中有你需要的 loaders， 那么那就可以通过以下任意一种方式来安装它们：<br><code>$ npm install xxx-loader --save</code> 或者是 <code>$ npm install xxx-loader --save-dev</code><br>(其中后者是以生产依赖的方式安装，前者为普通安装。以生产依赖的方式安装会自动改变 webpack 的配置文件中的依赖部分)</p></li></ul><p><strong>用法</strong><br>有很多途径都能在项目中应用 loaders：</p><ul><li>直接通过 <code>require</code> 声明来引用</li><li>通过配置文件来配置</li><li>通过 CLI 来配置</li></ul><p>以下将分别就这三种方式进行说明：  </p><ul><li><p>通过 <code>require</code> 方式  </p><blockquote><p><em>注意：如果你不能确定你的脚本的运行环境，那么就尽可能不要使用这种方式，而是利用配置规则来使用 loaders。</em></p></blockquote><p>利用 <code>require</code>声明（或者 <code>define</code>, <code>require.ensure</code> 声明 ）是可以规范化使用 loader 的，只要通过使用 <code>!</code> 符号将需处理文件和 loader 隔开。如果有多个 loader， 那么将遵循从右到左的顺序依次解析。 具体例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./loader!./dir/file.txt"</span>);</span><br><span class="line"><span class="comment">// uses the file "loader.js" in the current directory to transform</span></span><br><span class="line"><span class="comment">// "file.txt" in the folder "dir".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jade!./template.jade"</span>);</span><br><span class="line"><span class="comment">// uses the "jade-loader" (that is installed from npm to "node_modules")</span></span><br><span class="line"><span class="comment">// to transform the file "template.jade"</span></span><br><span class="line"><span class="comment">// If configuration has some transforms bound to the file,</span></span><br><span class="line"><span class="comment">// they will still be applied.</span></span><br><span class="line"><span class="comment">// 如果此时配置文件中规定了需要处理这个文件，那么这时候会处理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"!style!css!less!bootstrap/less/bootstrap.less"</span>);</span><br><span class="line"><span class="comment">// the file "bootstrap.less" in the folder "less" in the "bootstrap"</span></span><br><span class="line"><span class="comment">// module (that is installed from github to "node_modules") is</span></span><br><span class="line"><span class="comment">// transformed by the "less-loader". The result is transformed by the</span></span><br><span class="line"><span class="comment">// "css-loader" and then by the "style-loader".</span></span><br><span class="line"><span class="comment">// If configuration has some transforms bound to the file,</span></span><br><span class="line"><span class="comment">// they will not be applied.</span></span><br><span class="line"><span class="comment">// 由于此处在规则的最前面加了前缀 “！”， 如果配置文件中规定了需要处理这个文件，</span></span><br><span class="line"><span class="comment">// 那么这时候仍然不会处理。</span></span><br></pre></td></tr></table></figure></li><li><p><a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="noopener">配置文件方式</a><br> 在配置文件中可以通过用正则表达式的方式来绑定 loaders ，如下所示：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.jade$/</span>, <span class="attr">loader</span>: <span class="string">"jade"</span> &#125;,</span><br><span class="line">            <span class="comment">// =&gt; "jade" loader is used for ".jade" files</span></span><br><span class="line"></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">"style!css"</span> &#125;,</span><br><span class="line">            <span class="comment">// =&gt; "style" and "css" loader is used for ".css" files</span></span><br><span class="line">            <span class="comment">// Alternative syntax:</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loaders</span>: [<span class="string">"style"</span>, <span class="string">"css"</span>] &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="http://webpack.github.io/docs/cli.html" target="_blank" rel="noopener">CLI 方式</a><br> 可以通过命令行工具来绑定 loaders， 如下所示：<br>  <code>$ webpack --module-bind jade --module-bind &#39;css=style!css&#39;</code><br>   上面的例子会使得利用 <code>jade-loader</code> 来处理 <code>.jade</code> 文件， 用<code>css-loader &amp; style-loader</code> 来处理 <code>.css</code> 文件。</p></li></ul><p><strong>查询参数</strong><br>  可以通过使用 <code>?</code> 的方式来决定是否使用 loader，比如 <code>url-loader?mimetype=image/png</code> 表示就是，如果媒体文件都是图片格式， <code>mimetype=image/png</code>，那么就使用 <code>url-loader</code>来进行处理。<br>  注意：查询语法根据不同的 loader 可能会不一样，具体情况需要查询相应的文档。但是一般而言，都支持常见的查询语法，如 <code>(?key=value&amp;key2=value2)</code>，或者JSON对象如 <code>(?{&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></p><p>与上面提到的三种方式相对应的，利用查询的写法如下：</p><ul><li>通过 <code>require()</code> 方式：<br><code>require(&quot;url-loader?mimetype=image/png!./file.png&quot;);</code></li><li><p>通过配置文件：<br><code>{ test: /\.png$/, loader: &quot;url-loader?mimetype=image/png&quot; }</code><br>或者写的好看一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.png$/</span>,</span><br><span class="line">loader: <span class="string">"url-loader"</span>,</span><br><span class="line">query: &#123; <span class="attr">mimetype</span>: <span class="string">"image/png"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CLI方式：<br><code>webpack --module-bind &quot;png=url-loader?mimetype=image/png&quot;</code></p></li></ul><hr><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>使用插件能够增强 webpack 的功能，比如，利用 <a href="https://github.com/senotrusov/bell-on-bundler-error-plugin" target="_blank" rel="noopener"> BellOnBundlerErrorPlugin</a> 插件就能提示在打包过程中出现的错误。</p><p><strong>内置插件</strong><br>对于内置插件，如果在 webpack 的配置文件中有用到它们的功能，那么就会将这些插件包含在模块中。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack should be in the node_modules directory, install if not.</span></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.ResolverPlugin([</span><br><span class="line">            <span class="keyword">new</span> webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(<span class="string">"bower.json"</span>, [<span class="string">"main"</span>])</span><br><span class="line">        ], [<span class="string">"normal"</span>, <span class="string">"loader"</span>])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>外部插件</strong><br>外部的插件可以通过 <code>npm</code> 来安装，例如：<br><code>npm install component-webpack-plugin</code><br>安装完之后就可以使用了，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentPlugin = <span class="built_in">require</span>(<span class="string">"component-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ComponentPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用 <code>npm</code> 来安装第三方插件的时候，建议使用这个工具: <a href="https://www.npmjs.com/package/webpack-load-plugins" target="_blank" rel="noopener">https://www.npmjs.com/package/webpack-load-plugins</a> ，它会自动检测依赖中的所有插件，然后在需要的时候懒加载它们。</p><p><strong>更多阅读</strong><br><a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">了解更多，可查看插件列表</a></p><hr><h3 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h3><p><strong>解析过程</strong></p><ul><li>常见故障：<ul><li>利用 <code>--display-error-details</code> 可以得到详细信息</li><li>阅读配置文件，关于故障分析的部分都在 <code>resolve</code></li><li>loaders 的配置文件中有对应的故障分析 <code>resolveLoader</code></li></ul></li></ul><ul><li>npm 链接模块找不到所需依赖<br>&nbsp;&nbsp;&nbsp;&nbsp;node.js 的模块解析算法非常简单：系统寻找模块依赖时，会在所需模块的父文件夹的 <code>node_modules</code> 文件夹中寻找。如果你 npm 链接的带有同级依赖的模块没有放在根目录下，那么系统就无法找到这些模块（你可能会认为带有 <code>npm link</code> 的 <code>peerDependencies</code> 是 node.js 的设计缺陷）。需要注意的是应用的依赖也是一种 <code>peerDependencies</code>， 即使这种依赖并没有在模块的 <code>package.json</code> 文件中列出来。<br> &nbsp;&nbsp;&nbsp;&nbsp;要在 webpack 中分析这个问题其实很简单：只需要将应用的 <code>node_modules</code> 文件夹放在解析路径中，具体的设置例子如下：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123; <span class="attr">fallback</span>: path.join(__dirname, <span class="string">"node_modules"</span>) &#125;,</span><br><span class="line">  resolveLoader: &#123; <span class="attr">fallback</span>: path.join(__dirname, <span class="string">"node_modules"</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>监测过程</strong></p><ul><li><p>监测过程中， webpack 不会在资源有变动时重编译</p></li><li><p>监测到文件变化，但是文件并没有更新<br> &nbsp;&nbsp;&nbsp;&nbsp;可以确定的是，在 webpack 中，如果运行时加上了 <code>-progress</code> 标签，那么资源的变动将不会被监测。如果保存时能看到进展但却没有文件输出，那么就可能是配置上的问题，而不是文件监测问题了。<br>  <code>webpack --watch --progress</code></p></li><li><p>监测器不够<br> &nbsp;&nbsp;&nbsp;&nbsp;首先需要确认你的系统中是否有足够可用的检测器，如果可用数量太少，那么 webpack 中的检测器可能就检测不到变化了：<br>  <code>cat /proc/sys/fs/inotify/max_user_watches</code><br>  对于 Arch 用户，将 <code>fs.inotify.max_user_watches=524288</code> 加到 <code>/etc/sysctl.d/99-sysctl.conf</code> 文件中，然后执行 <code>sysctl --system</code>。对于 Ubutu 用户：<code>echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p.</code></p></li><li><p>OS-X FSevents bug<br> 在 OS-X 系统中，文件夹可能会崩溃，具体可参考下面的文章：<br>  <a href="http://feedback.livereload.com/knowledgebase/articles/86239-os-x-fsevents-bug-may-prevent-monitoring-of-certai" target="_blank" rel="noopener">OS X FSEvents bug may prevent monitoring of certain folders</a></p></li><li><p>Windows 路径<br> &nbsp;&nbsp;&nbsp;&nbsp;在 webpack 中的很多配置选项默认都是绝对路径。 <code>__dirname + &quot;/app/folder&quot;</code> 这种写法是错误的，因为在 Windows 系统中路径的分隔符是 <code>\</code>。这有时候会产生一些问题。建议使用正确的分隔符，比如 <code>path.resolve(__dirname, &quot;app/folder&quot;)</code> 或者 <code>path.join(__dirname, &quot;app&quot;, &quot;folder&quot;).</code></p></li><li><p>Vim<br> &nbsp;&nbsp;&nbsp;&nbsp;有些型号的机器上，Vim 的 <code>backupcopy option</code> 会被默认设置成 <code>auto</code>。这有可能会影响到系统的文件监测机制。所以建议将这个选项设置为 <code>yes</code>，这样的话就会在保存的时候覆盖原文件并保存一份副本。Vim 中的设置如下：<br>  <code>:set backupcopy=yes</code></p></li><li><p>WebStorm<br> &nbsp;&nbsp;&nbsp;&nbsp;当使用 JetBrains 的 WebStorm 的 IDE 的时候，你可能会发现在保存更改过的文件时并没有触发预想中的检测器。这时候就需要设置 <code>safe write</code> 选项了，这个选项决定了是否在保存更改过的文件前保存一份原文件在临时路径中： 取消下列设置<br>  <code>File &gt; Settings... &gt; System Settings &gt; Use &quot;safe write&quot; (save changes to a temporary file first).</code></p></li></ul><hr><h2 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h2><blockquote><p>文档比较混乱，所以先放一放，后面的部分写好再来。</p></blockquote><hr><h2 id="指导文件"><a href="#指导文件" class="headerlink" title="指导文件"></a>指导文件</h2><h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p>为了解决JS中作用域的问题， CommonJS 小组定义了一种模块格式，这可以确保所有的模块都在自己的命名空间执行。<br>怎样能到达到这个目的呢？其一需要在模块中明确的输出那些适用于全局作用域的变量，其二需要定义其他模块需要的变量。<br>为了达到这个效果， CommonJS 给我们提供了两个工具：</p><ul><li>利用 <code>require()</code> 函数可以将一个指定的模块引入到现在的作用域；</li><li>利用 <code>module</code> 对象可以将现在作用域中内容输出；</li></ul><p><strong>简单的例子</strong><br>下面是一个不用 CommonJS 的例子：<br>首先在一个js文件中定义一个变量，这个文件在之后其他的文件中将会被用到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure></p><p>然后在另一个文件中应用这个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">" world!"</span></span><br></pre></td></tr></table></figure></p><p><strong>定义模块</strong><br>上面的例子中将会因为 <code>MySalute</code> 没有被定义而报错，我们应该将这些文件定义为模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = MySalute;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = Result;</span><br></pre></td></tr></table></figure><p>在这两个例子中，我们将变量传入到了一个特殊的变量 <code>module</code> 中，这样一来 CommonJS 的模块系统就知道模块中需要被输出的对象了： <code>salute.js</code> 中输出 <code>MySalute</code> 对象，  <code>world.js</code> 中输出  <code>Result</code> 对象。</p><p><strong>模块依赖</strong><br>上面已经很接近了，但是还差一步：定义依赖。虽然都分别定义了自个为独立的模块，但是 <code>world.js</code> 还是不知道在哪里找到 <code>MySalute</code> 的定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = MySalute;</span><br></pre></td></tr></table></figure></p><p>我们需要做的最后一步就是在 <code>world.js</code> 中引入模块的依赖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="built_in">require</span>(<span class="string">"./salute"</span>);  <span class="comment">// This is it!</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">"world!"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = Result;</span><br></pre></td></tr></table></figure></p><p>需要注意，在我们利用 <code>require</code> 引用的时候，并没有使用 <code>salute.js</code> 的全名，意思就是我们可以省略后缀。 <code>./</code> 符号表示的是相对路径：引用文件和被引用文件在同一个文件夹目录下。</p><p><strong>最后的例子</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> multiplyBy2 = <span class="built_in">require</span>(<span class="string">'./moduleA'</span>);</span><br><span class="line"><span class="keyword">var</span> result = multiplyBy2( <span class="number">4</span> );</span><br></pre></td></tr></table></figure><hr><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD (Asynchronous Module Definition) 的产生是因为有些人认为 CommonJS 的模块系统暂时还不适合浏览器环境，因为从本质上来说 CommonJS 的模块是同步加载的。<br>AMD 指出了一种模块化 JavaScript 的规范， 按照这个规范模块能够异步加载它们的依赖，这就解决了同步加载带来的问题。</p><p><strong>规范说明</strong><br>在 AMD 中，模块是利用<code>define</code> 来定义的。<br><em>define</em><br>在 AMD 规范中利用 <code>define</code> 函数定义模块的形式如下：<br><code>define(id?: String, dependencies?: String[], factory: Function|Object);</code><br><em>id</em><br>模块的名字，为可选项<br><em>dependencies</em><br>这个参数是用来指出正在被定义的这个模块所需要依赖的其他模块，这个参数是个数组，里面包含了依赖模块的标识符。这也是一个可选参数，如果省略不写，默认值则是：<code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code><br><em>factory</em><br>这个参数是用来定义模块的。它可以是个函数（这个函数应该会被调用），或者是个对象。如果这个参数是个函数，那么函数的返回值将会是这个模块的输出值。</p><p><strong>例子</strong><br>简单的来看一些例子。</p><ul><li><p>具名模块<br>定义一个依赖 <code>jquery</code> 的名字为 <code>myModule</code> 的模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'myModule'</span>, [<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ is the export of the jquery module.</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// and use it</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>注意：在 webpack 中一个具名模块只在本地有效，而在 Require.js 中则是全局有效的。</p></li><li><p>匿名模块<br>定义一个匿名模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>复杂模块<br>定义一个具有多重依赖的模块，需要注意的是每个模块的输出都会传到 <code>factory</code> 函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>, <span class="string">'./math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ and math are the exports of the jquery module.</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>输出值<br>定义一个输出自身的模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> HelloWorldize = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</span><br><span class="line">        $(selector).text(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HelloWorldize;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>定义一个利用 <code>require</code> 来加载依赖的模块：</p><blockquote><p>因为没有定义依赖， webpack 将将上面提到的默认值传入后面的函数 ，然后就可以利用这些参数做文章了。</p></blockquote><p>  ​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p></li></ul><hr><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于大型的网页应用而言，把所有的代码放在一个文件中往往会效率低下，特别是当其中有些代码块只需要在特定环境下加载的时候。 webpack 中有一个特性，这个特性能够将代码分割成许多的 <code>chunks</code> ，这些代码块只会在被需要的时候才加载。有些其他的打包机将被分割的代码块称作为 <code>layers</code>, <code>rollups</code> 或者 <code>fragments</code>。这个特性就叫做“代码分割”。<br>&nbsp;&nbsp;&nbsp;&nbsp;这是一个可选的特性。我们可以在代码中定义代码分割点，然后 webpack 内部来处理依赖关系，输出文件和执行环境等事物。<br>&nbsp;&nbsp;&nbsp;&nbsp;在这里需要澄清一个概念：代码分割的功能不仅仅是将普通的代码提取分割成共享的代码块（chunk），它最重要的功能其实是将代码分割成能够 <strong>按需加载</strong> 的代码块。这样就会减少网页应用的初始加载量，并使得其他代码能够按需加载。</p><p><strong>定义分割点</strong><br>AMD 和 CommonJS 通过不同的方式使得代码按需加载。这些方法都是有效的，分别如下所示：</p><ul><li><p>CommonJS： <code>require.ensure</code></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies, callback)</span><br></pre></td></tr></table></figure><p>  <code>require.ensure</code> 方法可以确保当调用回调函数的时候，所有在 <code>dependencies</code> 中的依赖都能够被同步调用。<code>callback</code> 函数再被调用的时候会将 <code>require</code> 函数当做参数传入。<br>  例子如下：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">"module-a"</span>, <span class="string">"module-b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"module-a"</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  注意：<code>require.ensure</code> 函数仅仅是加载模块，并不会执行它们。</p></li><li><p>AMD： <code>require</code><br>AMD 规范中定义了一种异步的 <code>require</code> 方法，如下所示：<br><code>require(dependencies, callback)</code><br>当被调用时，所有的依赖都会被加载，而且加载的依赖的输出将会被传入到回调函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module-a"</span>, <span class="string">"module-b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  注意： AMD 中 <code>require</code> 方法是会加载并执行模块的。在 webpack 中模块式从左到右执行的。<br>  注意：回调函数是可以省略的。</p></li><li><p>ES6 模块<br>webpack 不支持 ES6 模块，需要根据编译器支持哪种格式的模块格式来选择是使用 <code>require</code> 还是 <code>require.ensure</code>.<br>webpack 1.xx（即将到来的2.0.0）版本本身并不支持 ES6 模块。但是可以利用编译器，比如 <code>Babel</code> 来将 ES6 中的 <code>import</code> 语法转换成 CommonJS 或者 AMD 模块，从而达到目的。这种方法很有效，但是动态加载的时候会产生一个警告。<br>模块的语法（<code>import x from &quot;foo&quot;</code>）被故意设计成只能静态分析，所以不能够动态引入模块：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// INVALID!!!!!!!!!</span><br><span class="line">[“lodash”, “backbone”].forEach(name =&gt; import name )</span><br></pre></td></tr></table></figure><p>不过幸运的是，在规范中提到可以利用一个 JavaScript API 中的 <code>loader</code> 来处理动态引入的情况：<code>System.load(or Sytem.import)</code>。这个 API 能起到和上面提到的 <code>require</code> 一样的作用。然而，大部分的编译器并不支持将 <code>System.load</code> 转化成 <code>require.ensure</code>，所以这时候如果想要动态的代码分割的话只能是直接去做了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//static imports</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dynamic imports</span></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contacts = <span class="built_in">require</span>(<span class="string">'./contacts'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Chunk 内容<br>在一个分割点内的所有依赖都会被包括在一个 Chunk 中，它们会被递归的加到这个 chunk 中。<br>如果你将一个函数表达式作为回调函数传入（或者绑定）到一个分割点， Webpack 会自动的将这个函数表达式中所需要的依赖同时打包到这个 chunk 中。</p></li><li><p>Chunk 优化</p><ul><li>如果两个 chunks 包含了同样的模块，那么这两个 chunk 将会合并成一个。这会造成 chunks 会有多重父级；</li><li>如果一个模块在一个 chunk 的所有父级中都出现了，那么这个模块将会从这个 chunk 中移除；</li><li>如果一个 chunk 包含了另一个 chunk 中的所有模块，那么将会形成多重 chunks。</li></ul></li><li><p>Chunk 加载<br> 基于一个叫做 <code>target</code> 的配置选项，关于 chunk 加载的运行环境会被加入到 <code>bundle</code> 文件中，例如：当 <code>target</code> 是 web 时， chunks 将会通过 jsonp 来加载。一个 chunk 只会加载一次， 并行的请求也会合并成一个请求。运行环境会检查已经加载的 chunk 是否形成复合 chunks。</p></li><li><p>Chunk 类型</p><ul><li>入口 chunk<br> 入口代码块包含了运行环境以及一些模块。如果 chunk 中包含了模块 <code>Θ</code>， 那么将在运行环境中执行它。如果不包含这个模块，就会等到包含这个模块的 chunk 然后再执行（每一次遇到包含模块 <code>Θ</code> 的时候都会执行一次）。</li><li>普通 chunk<br> 普通的 chunk 不包含运行环境，只包含一些模块。里面的结构由 chunk 加载算法来决定。例如，对于 jsonp 而言，模块将会被包含在 jsonp 的回调函数中。 chunk 里面也包含了一个由它来完成的 chunk id 的列表。</li><li>初始 chunk（非入口）<br> 初始 chunk 是普通 chunk 的一种。它们之间唯一的区别是在优化的时候，初始 chunk 会更加被重视，因为它会影响到初始加载时间（就像入口 chunk 一样）。这种类型的 chunk 会在结合 <code>CommonChunkPlugin</code> 使用的时候产生。</li></ul></li><li><p>拆解 app 以及分离代码<br> 为了将 app 拆解成两个文件，比如app.js 以及 vendor.js， 我们可以在 vendor.js 中利用 <code>require</code> 来引入 vendor 参数中的文件。然后将这个名字传入到 <code>CommonsChunkPlugin</code>中，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">"./app.js"</span>,</span><br><span class="line">    vendor: [<span class="string">"jquery"</span>, <span class="string">"underscore"</span>, ...],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="comment">/* chunkName= */</span><span class="string">"vendor"</span>, <span class="comment">/* filename= */</span><span class="string">"vendor.bundle.js"</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这会将 vendor chunk 中所包含的所有模块从 app chunk 中移除。 <code>bundle.js</code> 中将只会包含所有的 app 代码，不带有任何的依赖，所有的依赖代码都在 <code>vendor.bundle.js</code> 中。<br>在 HTML 文件中，需要先加载 <code>vendor.bundle.js</code> 然后再加载 <code>bundle.js</code>，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"vendor.bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>多个入口 chunks<br> 通过<a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="noopener">配置</a>可以实现多个入口点，这同时会形成多个入口 chunks。入口 chunk 中包含了运行环境，而一个页面中只能包含一个运行环境（当然也会有例外）。</p></li><li><p>运行多个入口点<br> 通过插件 <code>CommonsChunkPlugin</code> 可以将运行环境转移到 commons chunk 中。入口点这时候在初始 chunk 中。虽然只有一个初始 chunk 可以被加载，但是多个入口 chunk 可以被加载。这就说明了在同一个页面中运行多个入口点是可能的。例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">       entry: &#123; <span class="attr">a</span>: <span class="string">"./a"</span>, <span class="attr">b</span>: <span class="string">"./b"</span> &#125;,</span><br><span class="line">       output: &#123; <span class="attr">filename</span>: <span class="string">"[name].js"</span> &#125;,</span><br><span class="line">       plugins: [ <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">"init.js"</span>) ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入的时候，按如下顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"init.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"a.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"b.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>Commons Chunk<br> 插件 <code>CommonsChunkPlugin</code> 可以将多个入口 chunks 的模块转移到一个新的入口文件（也就是 commons chunk）中。运行环境也被转移到了 commons chunk 中。这意味着原来的入口 chunk 现在变成了初始 chunk。了解更多<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">插件选项。</a></p></li><li><p>优化<br> 有一些用于优化的插件能够根据特别的标准将 chunk 合并起来，参考<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">插件列表</a></p></li><li><p>具名 chunks<br> <code>require.ensure</code> 函数可以接收额外的第三个参数，这个参数必须是字符串类型。如果两个分割点传入了同样的字符串，那么它们将利用同样的 chunk。</p></li><li><p><code>require.include</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.include(request)</span><br></pre></td></tr></table></figure><p><code>require.include</code> 是 Webpack 中一个特殊的函数，它可以将模块加入到现在的 chunk 中，但是不会去执行它（打包的时候会将声明移除）。例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">"./file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./file2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// is equal to</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.include(<span class="string">"./file"</span>);</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./file2"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果模块是在复合子代码块中，那么这个函数将非常有用。在父级代码块中运用这个函数引入模块将会使得这个子代码块中的模块实例都消失。</p></li></ul><hr><h3 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h3><p><strong>内嵌样式表</strong><br>通过利用 <code>style-loader</code> 以及 <code>css-loader</code> 使得将样式表内嵌在 JavaScript 打包文件中变得可能。这种方式下你可以将你的样式表和其他模块一起模块化。引用方式非常简单： <code>require(&quot;./stylesheet.css&quot;)</code>。使用步骤如下：</p><ul><li><p>安装<br>首先从 <code>npm</code> 上下载 <code>loaders</code><br><code>npm install style-loader css-loader --save-dev</code></p></li><li><p>配置<br>下面是一个配置参考：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">"style-loader!css-loader"</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：对于一些需要编译的 css 样式，可以参考相对应的 loader 的配置例子，然后链式调用它们。</p></blockquote><p>需要记住的是我们很难管理模块的执行顺序，所以最好设计好样式表使得顺序无关紧要。（在一个 css 文件中，顺序还是可靠的。）</p></li><li><p>使用<br>使用非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your modules just require the stylesheet</span></span><br><span class="line"><span class="comment">// This has the side effect that a &lt;style&gt;-tag is added to the DOM.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./stylesheet.css"</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>独立的样式打包</strong><br>结合使用 <a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a> 这个插件，可以产生一个本地的 css 输出文件。<br>结合代码分割，我们可以使用两种不同的模式：</p><ul><li>针对每一个初始 chunk 都创建一个 css 文件， 将样式表内嵌至附加的 chunk 中。（推荐做法）</li><li>针对每一个初始 chunk 都创建一个 css 文件，并且这个文件中包含了附加 chunk 的样式。  </li></ul><p>从初始加载速度优化的角度考虑，推荐使用第一种模式。因为缓存和 http 请求头的原因，在一些具有多个入口点的小型应用中，第二种模式可能会更好一些。</p><p>步骤如下：</p><ul><li><p>安装插件<br> <code>npm install extract-text-webpack-plugin --save</code></p></li><li><p>处理初始 chunk 中的样式生成分离的 css 文件输出<br> 下面展示的虽然是多个入口点的例子，但是这种方式也适合单个入口点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// The standard entry point and output config</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        posts: <span class="string">"./posts"</span>,</span><br><span class="line">        post: <span class="string">"./post"</span>,</span><br><span class="line">        about: <span class="string">"./about"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].js"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            <span class="comment">// Extract css files</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// Optionally extract less files</span></span><br><span class="line">            <span class="comment">// or any other compile-to-css language</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(<span class="string">"style-loader"</span>, <span class="string">"css-loader!less-loader"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// You could also use other loaders the same way. I. e. the autoprefixer-loader</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Use the plugin to specify the resulting filename (and add needed behavior to the compiler)</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你会得到如下文件：</p><ul><li><code>posts.js  posts.css</code></li><li><code>post.js  post.css</code></li><li><code>about.js  about.css</code></li><li><code>1.js  2.js</code>（包含内嵌样式）</li></ul></li><li><p>所有样式都具有各自的 css 输出文件<br>利用第二种模式，只需要将 <code>allChunks</code> 选项设置成 <code>true</code> 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"style.css"</span>, &#123;</span><br><span class="line">            allChunks: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将得到如下文件：</p><ul><li><code>posts.js  posts.css</code></li><li><code>post.js  post.css</code></li><li><code>about.js  about.css</code></li><li><code>1.js  2.js</code>（不包含内嵌样式）</li></ul></li><li><p>在 commons chunk 中的样式<br>可以结合利用 <code>CommonsChunkPlugin</code> 及分离的样式文件来为 commons chunk 生成样式文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">"commons"</span>, <span class="string">"commons.js"</span>),</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后将得到如下输出文件：</p><ul><li><code>commons.js  commons.css</code></li><li><code>posts.js  posts.css</code></li><li><code>post.js  post.css</code></li><li><code>about.js  about.css</code></li><li><code>1.js  2.js</code>（包含内嵌样式）<br>  或者设置 <code>allChunks: true</code>，得到</li><li><code>1.js 2.js</code>（不包含内嵌样式）</li></ul><hr><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>压缩</strong><br>为了压缩文件中的 JavaScript（如果用了 css-loader，css 文件也可以），webpack 提供了一个简单的选项：<br><code>--optimize-minimize</code> 对应于：<code>new webpack.optimize.UglifyJsPlugin()</code><br>这是一个简单而有效的优化网页应用的方法。<br>你应该知道（如果你看过之前的文档）在 webpack 中是通过给 chunk 和模块赋予 id 的方式来辨别它们的。通过一个选项， webpack 可以分辨 id 的分布，并将具有较小长度的 id 分配给这些模块或者 chunk：<br><code>--optimize-occurrence-order</code> 对应于：<code>new webpack.optimize.OccurrenceOrderPlugin()</code><br>在对文件体积的影响程度上，入口 chunk 具有更高的优先级。</p><p><strong>去重</strong><br>如果你使用了一些拥有不错的依赖关系的库，那么在打包的过程中就可能会产生一些完全相同的文件。webpack 可以识别这些文件，然后删除重复的。在运行环境下通过利用函数替代重复代码的方式，从而避免打包文件中包含重复代码文件。这对语义化不会有什么影响。可以通过下面的方式来实现这个功能：<br><code>--optimize-dedupe</code> 对应于：<code>new webpack.optimize.DedupePlugin()</code><br>利用这种特性的时候会在入口 chunk 中引入一些额外的代码。</p><p><strong>Chunks</strong><br>在编写代码的时候，为了达到按需加载的目的，你可能已经设定好了一些代码分割点。但是在编译之后，你可能会发现产生了非常多的很小的 chunk，这会导致 HTTP 请求头数据量非常大。不过不用担心，通过以下两项设置，我们可以在 webpack 中利用合并的方式来处理这些 chunks：</p><ul><li>限制允许存在的 chunk 的数量（比如15个）： <code>--optimize-max-chunks 15  new webpack.optimize.LimitChunkPlugin({maxChunks: 15})</code></li><li>限制允许存在的 chunk 的最小体积（比如 10000）：<code>--optimize-min-chunk-size 10000 new webpack.optimize.MinChunkSizePlugin({minChunkSize: 10000})</code><br>webpack 会通过合并的方式来处理这些 chunk（会优先处理具有重复模块的 chunk）。任何 chunk 都不会被合并到入口 chunk 中，这主要是为了避免影响到初始页面加载的时间。</li></ul><p><strong>单页应用</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;单页应用是一种网页应用，webpack 的设计和优化就是为了这种应用。<br>&nbsp;&nbsp;&nbsp;&nbsp;你可能会将应用分解成很多 chunks， 这些 chunks 会在路由中加载。入口 chunk 中包含了路由和一些库，但是没有其他内容。当用户只通过导航来使用应用的时候，这种方式非常好，但是对于初始页面的加载，你需要两个完整的数据来回：一个是路由数据，一个是当前的页面数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你利用 HTML5 History API 来识别 URL 中的当前页面信息，那么服务器可以根据客户端的代码来判断被请求的页面。为了将往返数据保存起来在服务器中，你可以将内容代码包含在响应中：这可以通过增加 <code>script</code> 标签来达到。浏览器将并行加载所有的 chunks。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"entry-chunk.js"</span> type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"3.chunk.js"</span> type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;可以从数据中提取 chunk 的文件名（利用 <a href="https://www.npmjs.com/package/stats-webpack-plugin" target="_blank" rel="noopener">stats-webpack-plugin </a>插件可以输出创建的数据）</p><p><strong>多页应用</strong><br>当你在编译一个（真正的）多页应用时，你会希望不能的页面能共享公用代码。实际上利用 webpack 是非常容易实现的：只需要在编译的时候提供多个入口点：<br><code>webpack p1=./page1 p2=./page2 p3=./page3 [name].entry-chunk.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].entry.chunk.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这会产生多个入口 chunk：<code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> 以及 <code>p3.entry.chunk.js</code>。额外的 chunk 将会被共享。<br>如果你的入口 chunks 中有一些模块是一样的，那么可以使用一个很好的插件：<code>CommonsChunkPlugin</code>，它可以识别这些模块然后将它们生成一个 commons chunk。这时候就需要引用两个 <code>script</code> 标签了，一个用于引入 commons chunk，一个用于引入入口 chunk。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].entry.chunk.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.chunk.js"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这会产生多个入口文件：<code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> 以及 <code>p3.entry.chunk.js</code>，同时还有 <code>commons.chunk.js</code>。加载的时候先加载 <code>commons.chunk.js</code> 然后再加载任一入口 chunk。<br>你可以通过选择不同的入口 chunk 来生成多个 commons chunk，而且也可以将这些 commons chunk 嵌套。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span>,</span><br><span class="line">        ap1: <span class="string">"./admin/page1"</span>,</span><br><span class="line">        ap2: <span class="string">"./admin/page2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"admin-commons.js"</span>, [<span class="string">"ap1"</span>, <span class="string">"ap2"</span>]),</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.js"</span>, [<span class="string">"p1"</span>, <span class="string">"p2"</span>, <span class="string">"admin-commons.js"</span>])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// &lt;script&gt;s required:</span></span><br><span class="line"><span class="comment">// page1.html: commons.js, p1.js</span></span><br><span class="line"><span class="comment">// page2.html: commons.js, p2.js</span></span><br><span class="line"><span class="comment">// page3.html: p3.js</span></span><br><span class="line"><span class="comment">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span></span><br><span class="line"><span class="comment">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span></span><br></pre></td></tr></table></figure></p><p>高级用法：可以在 commons chunk 内部运行代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        commons: <span class="string">"./entry-for-the-commons-chunk"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons"</span>, <span class="string">"commons.js"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>更多阅读： <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-entry-points" target="_blank" rel="noopener">multiple-entry-points example</a> 以及 <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks" target="_blank" rel="noopener">advanced multiple-commons-chunks example</a>。</p><hr><h3 id="长期缓存"><a href="#长期缓存" class="headerlink" title="长期缓存"></a>长期缓存</h3><p>为了有效的缓存你的文件，它们应该在 URL 上有一个哈希值或者版本号。当然了，你可以手动的创建或者移动这些输出文件到一个版本号为 <code>v1.3</code> 的文件夹中。但是这么做有一些缺点：给开发者来带额外的工作，而且未更改的文件不会从缓存加载。<br>webpack 可以为文件的文件名加上哈希值。 那些能够产生输出文件的 Loaders（比如 worker-loader， file-loader）已经在这么做了。对于 chunk 而言，我们必须使它具有这种功能。有两种选择：</p><ul><li>为所有的 chunks 计算出一个哈希值并标记上</li><li>为每一个 chunk 计算一个哈希值并标记上</li></ul><p>下面针对这两种情况说明：</p><ul><li><p>选择一：一次打包一个哈希值<br> 只需要将 <code>[hash]</code> 增加到文件名配置选项：<br>  <code>webpack ./entry output.[hash].bundle.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join( __dirname, <span class="string">"assets"</span>, <span class="string">"[hash]"</span>),</span><br><span class="line">        publicPath: <span class="string">"assets/[hash]"</span>,</span><br><span class="line">        filename: <span class="string">"output.[hash].bundle.js"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].[hash].bundle.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择二：每个 chunk 一个哈希值<br>只需要将 <code>[chunkhash]</code> 增加到 chunk 文件名配置选项中：<br><code>--output-chunk-file [chunkhash].js</code><br><code>output: { chunkFilename: &quot;[chunkhash].bundle.js&quot; }</code><br>需要注意的是，在 HTML 文件中引用入口 chunk 的时候也需要带有哈希值。你应该会希望从数据中直接提取哈希值或者是文件名。如果你结合使用 <code>Hot Code Replacement</code>，你就只能使用第一种方式，并且不包括 <code>publicPath</code> 配置选项。</p></li><li><p>从数据中获取文件名<br>你可能会想获取文件的最终文件名用于插入到 HTML 文件中。通过 webpack 这是可以做到的。如果你在使用 <code>CLI</code>，你可以在运行它的时候加上 <code>--json</code>，从而会输出标准的 JSON 文件。<br>你也可以通过在配置表中增加一个插件，比如 <a href="https://www.npmjs.com/package/assets-webpack-plugin" target="_blank" rel="noopener"> assets-webpack-plugin</a> 来访问数据对象。下面是将具体的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.plugin(<span class="string">"done"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">stats</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">"fs"</span>).writeFileSync(</span><br><span class="line">        path.join(__dirname, <span class="string">".."</span>, <span class="string">"stats.json"</span>),</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(stats.toJson()));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个 JSON 数据包含了一个非常有用的特性：<code>assetsByChunkName</code>， 这是一个对象，这个对像里面的键为 chunk 的名字，键值为文件的名字。</p><blockquote><p>注意：如果每个 chunk 生成的是多个文件，比如一个 JavaScript 文件 一个 SourceMap， 那么这个特性就是个数组。数组中的第一个对应于 JavaScript。</p></blockquote></li></ul><hr><h3 id="编写-loader"><a href="#编写-loader" class="headerlink" title="编写 loader"></a>编写 loader</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Loader 就是输出一个函数的 node 模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;当有资源需要被这个 loader 转化的时候，这个函数就会被调用了。<br>&nbsp;&nbsp;&nbsp;&nbsp;在简单的例子中，当只有一个 loader 作用在待处理资源上的时候，调用 loader 时就只有一个参数：字符串形式的资源文件的内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;loader 可以通过在函数中的 this 格式来访问 <a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">loader API</a>。<br>&nbsp;&nbsp;&nbsp;&nbsp;一个同步的 loader 如果只想得到一个数值，那么直接用 return 返回就行了。除此之外，loader 可以通过 <code>this.callback(err. values...)</code> 函数来返回任意多的数值。错误会被传入到 <code>this.callback</code> 函数中或者被传入到同步的 loader 中。<br>&nbsp;&nbsp;&nbsp;&nbsp;一般来说我们都希望 loader 能够返回一到两个数据。第一个是缓存或者字符串形式的 JavaScript 代码，第二个数据是 JavaScript 对象格式的 SourceMap。<br>&nbsp;&nbsp;&nbsp;&nbsp;在比较附在的情况下，会组合使用到多个 loader，这时候只有最后的 loader 能够接触到源文件，同时也只有最开始的 loader 能够返回一到两个数据（JavaScript 代码及 SourceMap）（注：因为链式调用的时候是从右到左调用的）。其他的 loader 返回的数据都是传入到前一个 loader 中。</p><p><strong>例子</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Identity loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Identity loader with SourceMap support</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, source, map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>提示</strong><br>    loaders 应该（按照优先级排序，第一个应该享有最高的优先级）</p><ul><li>只完成单一任务<br>  loaders 是可以链式调用的，应该每一步都使用一个 loader 而不是让一个 loader 完成所有的事情。<br>  这也意味着如果不是必须的话就不应该转化成 JavaScript。<br>  例如：通过应用查询参数的方式从模板中渲染出 HTML：<br>  我们可以写一个 loader， 它可以从原文件中编译模板，然后执行它并返回一个能够输出带有 HTML 代码的字符串的模块。但这种做法不推荐。<br>  我们应该为每一个任务写一个 loader，然后链式调用它们：<ul><li>jade-loader：将模板转化成一个能返回函数的模块</li><li>apply-loader：接收一个函数并通过应用查询参数返回原生结果</li><li>html-loader： 接收 HTML 并且输出字符串</li></ul></li></ul><ul><li><p>生成的模块应该是模块化的<br>  通过 loader 生产的模块应该遵循和普通模块一样的设计原则。<br>  例如：这是一个不好的设计：（没有模块化，全局声明……）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"any-template-language-loader!./xyz.atl"</span>);</span><br><span class="line"><span class="keyword">var</span> html = anyTemplateLanguage.render(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure></li><li><p>尽量标明是可缓存的<br>  大部分的 loader 都是可缓存的，所以它们应该也标明是可缓存的。<br>  只需要在 loader 中调用 <code>cacheable</code>：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cacheable identity loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注明依赖<br>  如果 loader 需要利用外部资源（比如需要读取文档系统），那么就 <strong>必须</strong> 要注明。这个信息可以用来使可缓存的 loader 无效，也会使得在监控模式下重编译。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loader adding a header</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    <span class="keyword">var</span> headerPath = path.resolve(<span class="string">"header.js"</span>);</span><br><span class="line">    <span class="keyword">this</span>.addDependency(headerPath);</span><br><span class="line">    fs.readFile(headerPath, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, header</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> callback(err);</span><br><span class="line">        callback(<span class="literal">null</span>, header + <span class="string">"\n"</span> + source);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>分解依赖<br>  在很多语言中都有规范依赖的方法，比如在 css 中有 <code>@import</code> 以及 <code>url(...)</code> 的方式。模块系统应该能够分解这些依赖。<br>  有两种选择可达到这种目的：</p><ul><li>将它们转化成 <code>require</code></li><li>利用 <code>this.resolve()</code> 函数来分解路径<br>  举例一：css-loader。 css-loader 将依赖转化成 <code>require</code>，具体方式是利用 <code>require</code> 样式（也会被 css-loader 处理）来替代 <code>@import</code>，同时也利用 <code>require</code> 相关文件来替代 <code>url(...)</code> 引用。<pre><code>如果这个语言只接受相对路径（比如在 css 中： `url(file)` 一般表示 `./file`），那么就可以通过 `~` 符号来将特定的引用传送给模块，如下所示：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(file) -&gt; <span class="built_in">require</span>(<span class="string">"./file"</span>)</span><br><span class="line">url(~<span class="built_in">module</span>) -&gt; <span class="built_in">require</span>(<span class="string">"module"</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>提取公用代码<br>  不要在利用同一个 loader 处理的每个模块中提取太多公用代码。在 loader 中创建一个（运行环境下的）文件，并利用一个 <code>require</code> 来引用公用代码。</p></li><li><p>不要内嵌绝对路径<br>  不要将绝对路径写入到模块代码中，因为如果项目移动位置的话会破坏路径的哈希值。在<a href="https://github.com/webpack/loader-utils#stringifyrequest" target="_blank" rel="noopener">loader-utils</a> 中有一个 <code>stringifyRequest</code> 方法，可以将绝对路径转化为相对路径。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">"loader-utils"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"var runtime = require("</span> +</span><br><span class="line">loaderUtils.stringifyRequest(<span class="keyword">this</span>, <span class="string">"!"</span> + <span class="built_in">require</span>.resolve(<span class="string">"module/runtime"</span>)) +</span><br><span class="line"><span class="string">");"</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用库作为 <code>peerDependencies</code><br>  当使用库作为同级依赖的时候，如果需要，应用的开发者可以在配置文件 <code>package.json</code> 中明确的指出所依赖库的版本。这种依赖应该在不需要重新发布新版本号的 loader 的情况下能升级。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"peerDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"libraay"</span>: <span class="string">"^1.3.5"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更多关于 <a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">loaders</a>.</p></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;webpack 文档也看了好几天了，上面翻译的也只是其中一部分内容，看到后面有点不知所云，翻译起来很吃力，有种以其昏昏使人昭昭的感觉。为了不误人子弟，所以决定暂时不再翻译，日后有了更多的理解了再来继续。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果在阅读的过程中发现翻译不妥，欢迎在下方留言或者给我发邮件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前端工程化已成为趋势，善于使用各种工具无疑能极大的提高工作效率，所以这段时间将陆续会有几篇关于这些工具的介绍文章，文章的内容大多是关于这些工具的文档的翻译。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文所有资料来源都是 webpack 官网，有意看原文的戳链接： &lt;a href=&quot;http://webpack.github.io/docs/.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webpack document&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="工具" scheme="http://detachment.club/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Webpack" scheme="http://detachment.club/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端面试常见问题整理</title>
    <link href="http://detachment.club/2016/08/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://detachment.club/2016/08/31/前端面试常见问题整理/</id>
    <published>2016-08-30T16:00:00.000Z</published>
    <updated>2016-08-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从开始学习前端到现在已经五个月了，在时间上已经到了该找工作的阶段了，但从目前对前端技能的掌握的层面来说，还离社招的水平有较大一段距离。现实和计划之间永远存在在差距。现在也已经开始投简历了，为了有更好的面试状态同时也检验一下前阶段对知识的掌握程度，特地在网上收集了一些面试资料来借鉴参考。</p><a id="more"></a><p>注明：</p><blockquote><p>本文里面的绝大部分问题来自github上<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener">markyun同学的项目</a>，感谢所有为此付出努力的同学们~<br>对于原文中收集的有些问题我看了答案还是不能很理解，或者是有些没有答案的问题，我都做了一些收集并将链接附在了文中，也对这些热爱分享的同学表示感谢~</p></blockquote><h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h3 id="DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？"><a href="#DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？" class="headerlink" title="DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？"></a>DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？</h3><blockquote><p> &lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 <html> 标签之前；它不是 HTML 标签；而是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。其中DTD指的是：document type definition; SGML指的是 Standard Generalized Markup Language;</html></p><p> <a href="https://www.zhihu.com/question/20249139" target="_blank" rel="noopener">然后，为什么HTML5不再基于SGML？</a></p><p> 标准模式及兼容模式：标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p></blockquote><h3 id="行内元素有哪些？块级元素有哪些？空元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？空元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？空元素有哪些？"></a>行内元素有哪些？块级元素有哪些？空元素有哪些？</h3><blockquote><p>行内元素：a b span img input select strong；<br>块级元素有：div ul ol li dl dt dd h1 p;<br>常见的空元素：br hr img input link meta;</p></blockquote><h3 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h3><blockquote><p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;<br>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p><p><a href="http://www.daqianduan.com/2417.html" target="_blank" rel="noopener">更详细的区别戳我~</a></p></blockquote><h3 id="常见的浏览器内核有几种？"><a href="#常见的浏览器内核有几种？" class="headerlink" title="常见的浏览器内核有几种？"></a>常见的浏览器内核有几种？</h3><blockquote><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p><p>补充：浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><p><a href="http://web.jobbole.com/84826/" target="_blank" rel="noopener">想了解浏览器内核历史的，戳我~</a></p></blockquote><h3 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><blockquote><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>      绘画 canvas;<br>      用于媒介回放的 video 和 audio 元素;<br>      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;<br>      sessionStorage 的数据在浏览器关闭后自动删除;<br>      语意化更好的内容元素，比如 article、footer、header、nav、section;<br>      表单控件，calendar、date、time、email、url、search;<br>      新的技术webworker, websocket, Geolocation;</p></blockquote><blockquote><p> 移除的元素：<br>      纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>      对可用性产生负面影响的元素：frame，frameset，noframes；</p></blockquote><blockquote><p>支持HTML5新标签：<br>     IE8/IE7/IE6支持通过document.createElement方法产生的标签，<br>     可以利用这一特性让这些浏览器支持HTML5新标签，<br>     浏览器支持新标签后，还需要添加标签默认的样式。</p></blockquote><blockquote><p> 当然也可以直接使用成熟的框架、比如html5shim;<br>   <code>&lt;script&gt;src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</code></p></blockquote><blockquote><p>如何区分HTML5： DOCTYPE声明或新增的结构元素或功能元素；</p></blockquote><h3 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h3><blockquote><p>总结起来为：用正确的标签做正确的事情。</p><ol><li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li><li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li><li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ol></blockquote><h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><blockquote><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p><ul><li>存储大小：<br>  cookie数据大小不能超过4k。<br>  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li><li>有期时间：<br>  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>  sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul><p><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">更多关于Cooikes信息，戳我~</a></p></blockquote><h3 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h3><blockquote><ul><li>iframe会阻塞主页面的Onload事件；</li><li>搜索引擎的检索程序无法解读这种页面，不利于SEO;</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</li></ul><p><a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">想看使用iframe的好处的，戳我~</a></p></blockquote><h3 id="Label的作用是什么？是怎么用的？"><a href="#Label的作用是什么？是怎么用的？" class="headerlink" title="Label的作用是什么？是怎么用的？"></a>Label的作用是什么？是怎么用的？</h3><blockquote><p>label 元素不会向用户呈现任何特殊的样式。不过，它为鼠标用户改善了可用性，因为如果用户点击 label 元素内的文本，则会切换到控件本身。label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。<br><strong>本题考察的是HTML5新标签的用法，可推广到所有其他标签的常规使用，应举一反三。</strong></p></blockquote><h3 id="页面可见性（Page-Visibility-API）可以有什么用途？"><a href="#页面可见性（Page-Visibility-API）可以有什么用途？" class="headerlink" title="页面可见性（Page Visibility API）可以有什么用途？"></a>页面可见性（Page Visibility API）可以有什么用途？</h3><blockquote><p>可通过检测visibilityState的值检测页面是否可见，以及打开网页的时间等；<br>在页面被切换到后台进程的时候，自动暂停音乐或者视频的播放；</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="noopener">想了解更多信息，戳我~</a></p></blockquote><h3 id="如何在页面实现一个圆形的可点击区域？"><a href="#如何在页面实现一个圆形的可点击区域？" class="headerlink" title="如何在页面实现一个圆形的可点击区域？"></a>如何在页面实现一个圆形的可点击区域？</h3><blockquote><ol><li>map+area或者svg <a href="http://www.w3school.com.cn/tags/att_area_coords.asp" target="_blank" rel="noopener">具体实现方式，戳我~</a></li><li>border-radius</li><li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等；</li></ol></blockquote><h3 id="网页验证码是干嘛的？是为了解决什么安全问题？"><a href="#网页验证码是干嘛的？是为了解决什么安全问题？" class="headerlink" title="网页验证码是干嘛的？是为了解决什么安全问题？"></a>网页验证码是干嘛的？是为了解决什么安全问题？</h3><blockquote><p>是为了区分用户是计算机还是人类的公共自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>也可以有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p><p><a href="https://www.zhihu.com/question/19563610" target="_blank" rel="noopener">据说谷歌还利用验证码来完成古籍文字的识别，戳我~</a></p></blockquote><h3 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h3><blockquote><ul><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li><li>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时strong会重读，而B是展示强调内容。</li><li>i内容展示为斜体，em表示强调的文本；</li><li>Physical Style Elements – 自然样式标签<br>  b, i, u, s, pre</li><li>Semantic Style Elements – 语义样式标签<br> strong, em, ins, del, code<br> 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</li></ul></blockquote><hr><h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><blockquote><p>（1）有两种， IE 盒子模型、W3C 盒子模型；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的content部分把 border 和 padding计算了进去;<br>(其实更准确的说法应该是本来width值指的是内容区域，而在IE5，6版本中，width值包括padding和border。content部分一直都是content部分。)</p><p><a href="http://www.w3school.com.cn/css/css_boxmodel.asp" target="_blank" rel="noopener">想知道详细内容？戳我~</a></p></blockquote><h3 id="CSS选择符有哪些？哪些属性可以继承？"><a href="#CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择符有哪些？哪些属性可以继承？"></a>CSS选择符有哪些？哪些属性可以继承？</h3><blockquote><ol><li>id选择器（ # myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div, h1, p）</li><li>相邻选择器（h1 + p）</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>通配符选择器（ * ）</li><li>属性选择器（a[rel = “external”]）</li><li>伪类（a:hover, li:nth-child）</li><li>伪元素(:before, :after, :first-line, first-letter)</li></ol><ul><li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li><li>不可继承的样式：border padding margin width height ;</li></ul><p><a href="http://www.cnblogs.com/rubylouvre/archive/2009/09/04/1559557.html" target="_blank" rel="noopener">想知道更全面的可继承与不可继承属性？戳我~</a></p></blockquote><h3 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h3><blockquote><p>优先级就近原则，同权重情况下样式定义最近者为准;<br>载入样式以最后载入的定位为准;<br>优先级为：!important &gt;  id &gt; class &gt; tag  其中important比内联样式优先级高。</p></blockquote><h3 id="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h3><blockquote><p>由于本问题涉及较多代码，希望知道详细解释的，<a href="http://www.w3cplus.com/css/elements-horizontally-center-with-css.html" target="_blank" rel="noopener">直接戳我就好了~</a></p></blockquote><h3 id="display有哪些值？他们的作用分别是？"><a href="#display有哪些值？他们的作用分别是？" class="headerlink" title="display有哪些值？他们的作用分别是？"></a>display有哪些值？他们的作用分别是？</h3><blockquote><p>block         象块类型元素一样显示。<br>  none          缺省值。象行内元素类型一样显示。<br>  inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。<br>  list-item     象块类型元素一样显示，并添加样式列表标记。<br>  table         此元素会作为块级表格来显示<br>  inherit       规定应该从父元素继承 display 属性的值</p><p><a href="http://www.w3school.com.cn/cssref/pr_class_display.asp" target="_blank" rel="noopener">更多详细内容，戳我~</a></p></blockquote><h3 id="CSS3中有哪些新特征？"><a href="#CSS3中有哪些新特征？" class="headerlink" title="CSS3中有哪些新特征？"></a>CSS3中有哪些新特征？</h3><blockquote><p>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）<br>  圆角           （border-radius:8px）<br>  多列布局        （multi-column layout）<br>  阴影和反射        （Shadow, Reflect）<br>  文字特效      （text-shadow、）<br>  文字渲染      （Text-decoration）<br>  线性渐变      （gradient）<br>  旋转          （transform）<br>  增加了旋转,缩放,定位,倾斜,动画，多背景<br>  transform:scale(0.85,0.90), translate(0px,-30px), skew(-9deg,0deg), Animation:</p><p><a href="http://www.w3school.com.cn/css3/css3_border.asp" target="_blank" rel="noopener">个人认为上面的分类不够系统，戳我了解更多~</a></p></blockquote><h3 id="用纯CSS创建一个三角形的原理是什么？"><a href="#用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="用纯CSS创建一个三角形的原理是什么？"></a>用纯CSS创建一个三角形的原理是什么？</h3><blockquote><p>原理很简单，就是将一个div的宽高设置成0，然后根据不同的需求设置div的border属性，从而能够得到各种三角形。</p><p><a href="http://www.zhangxinxu.com/wordpress/2010/05/css-border%E4%B8%89%E8%A7%92%E3%80%81%E5%9C%86%E8%A7%92%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">更详细的说明，戳我~</a></p></blockquote><h3 id="解释一下CSS3中Flex-box以及使用场景？"><a href="#解释一下CSS3中Flex-box以及使用场景？" class="headerlink" title="解释一下CSS3中Flex-box以及使用场景？"></a>解释一下CSS3中Flex-box以及使用场景？</h3><blockquote><p>box-flex 属性规定框的子元素是否可伸缩其尺寸。可伸缩元素能够随着框的缩小或扩大而缩写或放大。只要框中有多余的空间，可伸缩元素就会扩展来填充这些空间。目前浏览器使用这个属性时都需要加前缀，比如Firefox 支持替代的 -moz-box-flex 属性，Safari、Opera 以及 Chrome 支持替代的 -webkit-box-flex 属性。</p><p><a href="http://www.w3school.com.cn/cssref/pr_box-flex.asp" target="_blank" rel="noopener">更多详细内容，戳我~</a></p></blockquote><h3 id="常见的浏览器兼容性问题有哪些？原因及解决方法是什么？"><a href="#常见的浏览器兼容性问题有哪些？原因及解决方法是什么？" class="headerlink" title="常见的浏览器兼容性问题有哪些？原因及解决方法是什么？"></a>常见的浏览器兼容性问题有哪些？原因及解决方法是什么？</h3><blockquote><p><a href="http://www.cnblogs.com/jscode/archive/2012/07/10/2583856.html" target="_blank" rel="noopener">问题范围太大了，想详细了解的戳我~</a><br><br><a href="https://www.zhihu.com/question/28954391" target="_blank" rel="noopener">然后，戳我了解更多~</a></p></blockquote><h3 id="为什么要初始化CSS样式？"><a href="#为什么要初始化CSS样式？" class="headerlink" title="为什么要初始化CSS样式？"></a>为什么要初始化CSS样式？</h3><blockquote><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p><p><a href="http://www.cnblogs.com/xiangzi888/archive/2011/09/21/2184442.html" target="_blank" rel="noopener">各大厂详细的初始化方案，戳我~</a></p></blockquote><h3 id="在CSS中position，display和float有什么关系？"><a href="#在CSS中position，display和float有什么关系？" class="headerlink" title="在CSS中position，display和float有什么关系？"></a>在CSS中position，display和float有什么关系？</h3><blockquote><p><a href="http://www.w3cfuns.com/notes/16548/6c7c4a0e6fe54320bfeb26fdc1e08ca1.html" target="_blank" rel="noopener">由于这个问题比较复杂，他们之间的详细的关系可以戳我~</a><br><a href="https://www.zhihu.com/question/19588854" target="_blank" rel="noopener">或者戳我~</a><br><a href="http://detachment.club/2016/06/27/Float,%20position%20and%20display%20in%20CSS/">还有我~</a></p></blockquote><h3 id="CSS声明的权重是怎样的？"><a href="#CSS声明的权重是怎样的？" class="headerlink" title="CSS声明的权重是怎样的？"></a>CSS声明的权重是怎样的？</h3><blockquote><p>CSS声明的权重指的是优先级，由选择器中的每一种选择器类型的数值决定，当数值相等时，css中最后的那个声明将作用到元素上。权重数值如下：<br>0 . 元素(类型)选择器（type selectors）（例如：h1）和 伪元素选择器（pseudo-elements）（例如：:before）<br>1 . 类选择器（class selectors） (例如：.example)，属性选择器（attributes selectors）（例如：[type=”radio”]），伪类选择器（pseudo-classes）（例如：:hover）<br>2 . ID选择器（例如：#example）<br>通用选择器（universal selector）(*),组合符合（combinators） (+, &gt;, ~, ‘ ‘)  和 否定伪类（negation pseudo-class）(:not()) 不会影响优先级（但是，在 :not() 内部声明的选择器是会影响优先级的）。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">详细信息戳我~</a></p></blockquote><h3 id="清除浮动有几种方式？优缺点有哪些？"><a href="#清除浮动有几种方式？优缺点有哪些？" class="headerlink" title="清除浮动有几种方式？优缺点有哪些？"></a>清除浮动有几种方式？优缺点有哪些？</h3><blockquote><ol><li>最后增加一个清除浮动的子元素,缺点是会增加一个DOM节点;</li><li>同样可以在最后增加一个清除浮动的br,语义上比空的div标签稍微好一点，但同样会增加一个DOM节点;</li><li>父元素设置 overflow:hidden（如果你还要兼顾IE6的话，加上*zoom:1;来触发hasLayout）;</li><li>将父元素设置 的overflow:hidden改成auto;</li><li>父元素也设成float;</li><li>父元素设置display:table;</li><li>用:after伪元素，思路是用:after元素在div后面插入一个隐藏文本”.”，隐藏文本用clear来实现闭合浮动：</li></ol><p><a href="http://www.jianshu.com/p/07eb19957991#" target="_blank" rel="noopener">原文链接，戳我~</a></p></blockquote><h3 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h3><blockquote><p>总的来说，浏览器是遵循从右到左的顺序来解析CSS选择器的，这样解析的效率最高。<br><br><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="noopener">想知道详细解释的，戳我</a><br><br><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="noopener">然后也可以戳我~</a></p></blockquote><h3 id="CSS优化、提高性能的方法有哪些？"><a href="#CSS优化、提高性能的方法有哪些？" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h3><blockquote><p><a href="http://www.zhihu.com/question/19886806" target="_blank" rel="noopener">问题比较笼统，较详细的解释可戳我~</a></p></blockquote><h3 id="在网页中较多的使用奇数号字体还是偶数号字体？为什么？"><a href="#在网页中较多的使用奇数号字体还是偶数号字体？为什么？" class="headerlink" title="在网页中较多的使用奇数号字体还是偶数号字体？为什么？"></a>在网页中较多的使用奇数号字体还是偶数号字体？为什么？</h3><blockquote><p>首先答案是较多的使用偶数号字体，具体原因点下面的链接。</p><p><a href="https://www.zhihu.com/question/20440679" target="_blank" rel="noopener">为什么网页多使用偶数号字体？</a></p></blockquote><h3 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h3><blockquote><p>如果是定位元素，则相对的是容器的高度；而如果是内外边距，那么相对的则是容器的宽度。</p></blockquote><h3 id="从输入URL到页面加载完成的过程中都发生了什么事情？"><a href="#从输入URL到页面加载完成的过程中都发生了什么事情？" class="headerlink" title="从输入URL到页面加载完成的过程中都发生了什么事情？"></a>从输入URL到页面加载完成的过程中都发生了什么事情？</h3><blockquote><p><a href="http://yuehu.io/padding-me/406" target="_blank" rel="noopener">这篇文章写得非常详细，戳我阅读~</a></p></blockquote><h3 id="如何修改chrome记住密码后自动填充表单的黄色背景-？"><a href="#如何修改chrome记住密码后自动填充表单的黄色背景-？" class="headerlink" title="如何修改chrome记住密码后自动填充表单的黄色背景 ？"></a>如何修改chrome记住密码后自动填充表单的黄色背景 ？</h3><blockquote><p><em>我觉着这种问题不是太适合面试，没有尝试过的同学估计很难知道具体的修改方式</em></p><p><a href="http://zcoder.cn/2015/01/14/front-end/chrome-autofill/" target="_blank" rel="noopener">想了解具体的修改方式，戳我~</a></p></blockquote><h3 id="什么是CSS-预处理器-后处理器？"><a href="#什么是CSS-预处理器-后处理器？" class="headerlink" title="什么是CSS 预处理器/后处理器？"></a>什么是CSS 预处理器/后处理器？</h3><blockquote><p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，<br>  还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。<br>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p></blockquote><hr><h2 id="JavaScript-部分"><a href="#JavaScript-部分" class="headerlink" title="JavaScript 部分"></a>JavaScript 部分</h2><h3 id="介绍JS中的基本数据类型。"><a href="#介绍JS中的基本数据类型。" class="headerlink" title="介绍JS中的基本数据类型。"></a>介绍JS中的基本数据类型。</h3><blockquote><p>一般来说分为两种，分别为基本类型和对象类型，其中基本类型包括undefined, null, Boolean, Number, String, Symbol，对象类型即为Object。</p></blockquote><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">MDN中关于JS基本数据类型的介绍~</a><br><a href="http://www.cnblogs.com/snandy/archive/2013/01/02/2841899.html" target="_blank" rel="noopener">JS中基本类型之争</a></p></blockquote><h3 id="JS中有哪些内置对象？"><a href="#JS中有哪些内置对象？" class="headerlink" title="JS中有哪些内置对象？"></a>JS中有哪些内置对象？</h3><blockquote><p>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：Object、Array、Boolean、Number 和 String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error</p></blockquote><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">JS中的标准全局对象</a></p></blockquote><h3 id="说几条JS的基本规范"><a href="#说几条JS的基本规范" class="headerlink" title="说几条JS的基本规范"></a>说几条JS的基本规范</h3><blockquote><p>1.不要在同一行声明多个变量。<br>2.请使用 ===/!==来比较true/false或者数值<br>3.使用对象字面量替代new Array这种形式<br>4.不要使用全局函数。<br>5.Switch语句必须带有default分支<br>6.函数不应该有时候有返回值，有时候没有返回值。<br>7.For循环必须使用大括号<br>8.If语句必须使用大括号<br>9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p></blockquote><blockquote><p><a href="https://github.com/lxj/javascript.patterns/blob/master/chapter2.markdown" target="_blank" rel="noopener">需要知道更多的要点？ 戳我~</a></p></blockquote><h3 id="简单解释下JS中的原型及原型链，有什么特点？"><a href="#简单解释下JS中的原型及原型链，有什么特点？" class="headerlink" title="简单解释下JS中的原型及原型链，有什么特点？"></a>简单解释下JS中的原型及原型链，有什么特点？</h3><blockquote><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p></blockquote><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN上关于JS中继承及原型链的解释</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html" target="_blank" rel="noopener">强大的原型及原型链</a></p></blockquote><h3 id="JS中有几种类型的值？它们之间的区别时是什么？"><a href="#JS中有几种类型的值？它们之间的区别时是什么？" class="headerlink" title="JS中有几种类型的值？它们之间的区别时是什么？"></a>JS中有几种类型的值？它们之间的区别时是什么？</h3><blockquote><p>主要有两种，分别为栈和堆；<br>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（对象、数组和函数）</p></blockquote><blockquote><p>两种类型的区别是：存储位置不同；<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p></blockquote><h3 id="常见的内存泄露的方式有？如何避免？"><a href="#常见的内存泄露的方式有？如何避免？" class="headerlink" title="常见的内存泄露的方式有？如何避免？"></a>常见的内存泄露的方式有？如何避免？</h3><blockquote><p>主要有以下几种方式：</p><ol><li>意外的全局变量</li><li>被遗忘的计时器或回调函数</li><li>脱离 DOM 的引用</li><li>闭包</li></ol></blockquote><blockquote><p><a href="http://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener">关于这个问题的答案，具体解释戳我~</a><br><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="noopener">英文原文链接</a></p></blockquote><h3 id="JS中怎么实现继承？"><a href="#JS中怎么实现继承？" class="headerlink" title="JS中怎么实现继承？"></a>JS中怎么实现继承？</h3><blockquote><p>主要有以下几种：<br>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承</p></blockquote><blockquote><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">详细内容戳我~</a></p></blockquote><h3 id="JS中创建对象有几种方式？"><a href="#JS中创建对象有几种方式？" class="headerlink" title="JS中创建对象有几种方式？"></a>JS中创建对象有几种方式？</h3><blockquote><p>常见的创建对象的方式有：</p><ol><li>直接创建对象；</li><li>用构造函数；</li><li>用工厂方式；</li><li>用原型方式；</li><li>用混合方式；</li></ol></blockquote><blockquote><p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener">原文链接，戳我直达~</a><br><a href="http://www.yuanlairc.com/program/jsobject.html" target="_blank" rel="noopener">javascript创建对象的几种模式</a></p></blockquote><h3 id="谈谈对在JS中This的理解"><a href="#谈谈对在JS中This的理解" class="headerlink" title="谈谈对在JS中This的理解"></a>谈谈对在JS中This的理解</h3><blockquote><ul><li>this总是指向函数的直接调用者（而非间接调用者）；</li><li>如果有new关键字，this指向new出来的那个对象；</li><li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</li></ul></blockquote><blockquote><p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">Javascript中this的用法 by 阮一峰</a></p></blockquote><h3 id="null和undefined有什么区别？"><a href="#null和undefined有什么区别？" class="headerlink" title="null和undefined有什么区别？"></a>null和undefined有什么区别？</h3><blockquote><p>null最常见的用法表示一个对象被定义了，但值为空值；<br>undefined最常用的用法表示一个对象未被定义或者需要访问的对象的属性不存在；</p></blockquote><blockquote><p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#core.undefined" target="_blank" rel="noopener">undefined和null——《秘密花园》</a><br><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">undefined和null的区别，阮一峰</a></p></blockquote><h3 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><blockquote><p>答案是[1, NaN, NaN]。<br>map方法中的回调函数可以有三个参数来声明，第一个为数组元素的值，第二个为数组元素的数字索引，但三个为包含该元素的数组对象。<br>在这个例子中，回调函数为parseInt，传入参数为待解析字符串及进制数，其中进制数为可选参数。<br>然后在这个，parseInt函数正好将数组元素的数字索引当做进制数来进行运算，所以最终的结果如上所说。</p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000005956935" target="_blank" rel="noopener">想知道更详细的解释？戳我~</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从开始学习前端到现在已经五个月了，在时间上已经到了该找工作的阶段了，但从目前对前端技能的掌握的层面来说，还离社招的水平有较大一段距离。现实和计划之间永远存在在差距。现在也已经开始投简历了，为了有更好的面试状态同时也检验一下前阶段对知识的掌握程度，特地在网上收集了一些面试资料来借鉴参考。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="http://detachment.club/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="http://detachment.club/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《Bootstrap 初体验》</title>
    <link href="http://detachment.club/2016/08/09/Bootstrap%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://detachment.club/2016/08/09/Bootstrap初体验/</id>
    <published>2016-08-08T16:00:00.000Z</published>
    <updated>2016-08-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;了解了jQuery的基本语法之后，就开始准备学习Bootstrap框架了。在慕课网上看过姜维老师讲述的<a href="http://www.imooc.com/learn/182" target="_blank" rel="noopener">《基于bootstrap的网页开发》</a>后，真正被Bootstrap的强大功能惊艳到。随后又在网易云课堂接触到李炎恢老师是<a href="http://study.163.com/course/courseMain.htm?courseId=1017002" target="_blank" rel="noopener">《Bootstrap视频教程》</a>，再一次被惊艳。在用一通宵的时间看完李老师的基础教程后，跃跃欲试，然后决定跟着老师的步骤做一个自己的网页。</p><a id="more"></a><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;虽说是准备跟着老师做，但也不想完全照搬老师的内容，这时候一转头，正好看到电脑屏幕上电影《Detachment》的截图，瞬间就决定了以此为主题制作网页。<br>&nbsp;&nbsp;&nbsp;&nbsp;由于整体框架和老师是完全一样的，所以制作的过程还算是比较顺利。整个网页大概花费了两天时间，其中有很大一部分时间花在找材料上，而且为了使网页实际体验效果比较好，在需要加链接的地方都尽量贴上了链接。做完以后面临的一个问题就是怎么展示这些网页，自己看的话在本地当然没有问题，但是如果要和别人分享的话，最好还是放在网上。为了达到这个目的，尝试了三个方法：</p><ol><li>购买域名，部署网站；工作量较大，涉及到前后端的知识，稍微尝试了一下后放弃此方案；</li><li>结合博客展示；在博客中新建了一个页面展示，但是文件格式是<code>.md</code>的，而且展示的时候博客的固定框架仍在，影响美观，随放弃；</li><li>利用在线编辑器Codepen；只需将其中一个页面布置到codepen中，另外的几个页面通过外链（七牛云）的方式链接到主页面即可，方法可行且十分方便，以后都可以类似处理；</li></ol><p>最终的效果如下图： <img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut1.JPG" alt=""><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut2.JPG" alt=""><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut3.JPG" alt=""><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut4.JPG" alt=""><br>（想看完整版的可从博客左侧的“关于”栏获取链接）。</p><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这个页面是第一次完整的制作页面，当看到整体呈现在面前的时候，还是有点小激动的。感觉特别冲击的是，居然可以几乎不手写js代码就能做出这样的效果！和对照网站的功能及视觉效果来说，比较突出的两点不足是：</p><ol><li>首页轮播图和背景并没有十分契合；</li><li>首页的整体色调不是很完美；</li><li>最后一个页面的滚动监听功能没有实现，虽然重新看了几遍教程也看过了中文文档，但还是没有找出问题出在哪里，暂时搁置，待对bootsrap的功能了解更全面后再来找出问题所在。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然这个页面已经做完了，但自知整体布局都是老师已经选好的，并没有什么难度。这只是一个开始而已，路还很长，加油。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解了jQuery的基本语法之后，就开始准备学习Bootstrap框架了。在慕课网上看过姜维老师讲述的&lt;a href=&quot;http://www.imooc.com/learn/182&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《基于bootstrap的网页开发》&lt;/a&gt;后，真正被Bootstrap的强大功能惊艳到。随后又在网易云课堂接触到李炎恢老师是&lt;a href=&quot;http://study.163.com/course/courseMain.htm?courseId=1017002&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Bootstrap视频教程》&lt;/a&gt;，再一次被惊艳。在用一通宵的时间看完李老师的基础教程后，跃跃欲试，然后决定跟着老师的步骤做一个自己的网页。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://detachment.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://detachment.club/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Bootstrap" scheme="http://detachment.club/tags/Bootstrap/"/>
    
      <category term="框架" scheme="http://detachment.club/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
