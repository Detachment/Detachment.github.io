<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[聊聊近况]]></title>
      <url>http://detachment.club/2020/04/01/%E8%81%8A%E8%81%8A%E8%BF%91%E5%86%B5/</url>
      <content type="html"><![CDATA[<p><img src="https://detachment-1301739815.cos.ap-shanghai.myqcloud.com/blog/2020-04-01-151316.png" alt></p>
<p style="text-align: center; font-size: 12px">图文无关</p>

<a id="more"></a>
<blockquote>
<p>写在前面：好久没写博客了，想到哪写到哪，不限于工作、学习或者生活。就把这当时一块自留地吧，随便种点东西。</p>
</blockquote>
<hr>
<h4 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h4><p>这两天把图床弄了一下。之前七牛云链接失效导致所有图片都无法查看给我留下了很惨痛的教训，所以这次重新寻找图床方案首要条件就是：稳定可靠。其次考虑到的是安全问题和访问速度。最终采用的方案是直接购买阿里云和腾讯云的对象存储服务（亚马逊云服务也开了，但是好像比较慢）。结合 xnip+iPic+云，简直有点爽。腾讯云比阿里云便宜一些，但是阿里云的链接不能直接访问，直接访问的时候会强制弹窗下载，体验非常不好。所以最终选择了腾讯云，上面的图片就是存在腾讯云上的，体验非常好。在写博客的时候，Typora结合iPic可以直接将本地的图片自动上传到服务器，而不需要先在iPic中上传，然后复制链接到博客中。这两者的结合带来的写博客的体验简让写博客变成了一件很让人享受的事情，特别是在需要用图片的时候。</p>
<h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p>在学习 TypeScript 的路上又停了几天了。在新项目中尽自己目前的水平补充了各种类型，慢慢的体会到了这种类型变成的好处。代码不用运行就能知道是否有错误，有点厉害。不过目前的使用方式还非常基础，稍微复杂一点的类型定义、约束、判断之类的就不会了。还得多看看文档，然后找个比较负责的例子看一下。</p>
<h4 id="工时和总结"><a href="#工时和总结" class="headerlink" title="工时和总结"></a>工时和总结</h4><ul>
<li>工时<br>最近大组内的气氛不太好，一方面是各种要求变多了，一方面是直到现在还没有沟通调薪的事情。简单来说就是又想马儿跑，又不给马儿吃草。而且更让人难以接受的是，居然开始想用工时来衡量一个软件开发人员的工作量。这种做法无疑是管理人员偷懒和无能的体现。我认为最理想的绩效体系是小组推荐+个人汇报。团队大了，上面的领导肯定不会知道底层的员工的工作情况，现在的情况是小领导也可能不知道小组内组员的情况，这就造成了无法往上汇报的局面，大组长衡量底层员工工作量的唯一途径就是月底的总结（其实还有另一个途径，那就是个人总结，这也是我为什么熬夜也要写个人总结的原因）。归根到底就是中间的沟通出现了问题，大领导想一把抓，结果啥也捉不住，弄了个吃力不讨好。工时这个词还让我想起了第一份工作：每个任务都由车间主任给工时，然后分给不同的工人师傅去加工操作，月末统计工时给工资。这套系统运行的关键是管理人员对于整个任务的流程、难度、加工工艺等方面非常熟悉，能给出一个基本合理的时间来。而现在在我们这样的情况下，谁来给这个合理的工时就是个非常大的问题了。所以我觉得毫无意义。哦，想起来了，最近还明确暗示希望每个月的工作时长需要达到 300 小时，再一次刷新了我的认知。人的底线就是在一次次被突破中无限降低，这可不是件好事，内心需要知道。</li>
<li>总结<br>即要求写的通俗易懂，又提倡贵在于精而不在多。操作难度上非常大。根据我有限的经验，这种操作肯定不会持久的进行下去。最重要的是，这么做的收益很难体现出来，而且我是没看出来能够让任何一方有收益。除非真的能在各种非常强的阻力下强行坚持推行下去。我认为最佳的解决办法还是借助新的需求管理系统，自动生成报告，生成溯源关系链路。在这上面花时间也比写那些虚无缥缈的总结强。</li>
</ul>
<h4 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h4><p>这两天工作状态挺不好的，办公室太闷了，啥也不想写。</p>
<hr>
<blockquote>
<p>先睡了，明天再写。 2020-04-01</p>
</blockquote>
<p><em>一晃两周过去了，这两周也发生了挺多事情的。</em></p>
<h4 id="换办公室和组"><a href="#换办公室和组" class="headerlink" title="换办公室和组"></a>换办公室和组</h4><p><img src="https://detachment-1301739815.cos.ap-shanghai.myqcloud.com/blog/2020-04-13-030327.jpg" alt="办公室" style="zoom:50%;"></p>
<p>上周又换办公室了，总的来说这边比之前的地方更舒服些，因为不太闷了。而且现在也是一个靠窗的位置，和当年的位置一模一样，恍惚间有穿越的感觉。除了换办公室之外，这次也把我从之前的组调了出来，也不知道是短时间的还是长时间的。搞不懂为什么前几天谈话的时候为啥不直接告知我，而是通过小组长传达。新组更忙一些，但是参与感更强，所以也更有意思一些。</p>
<h4 id="李自然说"><a href="#李自然说" class="headerlink" title="李自然说"></a>李自然说</h4><p>最近看了一档节目《李自然说》，越听越发现这个人还挺有意思的。他之前做过美股交易员、倒卖过电脑、主讲过日本历史、卖过围棋教学光碟，然后现在在创业的同时搞自媒体。惊讶于一个人居然能有过如果多的经历，并且每一项经历都可以用于谋生。真的是生命在于体验。眼界的开阔以及强执行力往往决定了一个人的高度，这些特质都不是一朝一夕形成的，需要不断的去学习和训练。希望自己也能慢慢的有所提高吧。</p>
<h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><p>最近确实是有点忙了，计划好的技术学习停滞不前。我发现洗澡的时候思维最活跃，会想一些关于技术、产品、团队建设、职业规划等等之类的事情，所以有时候洗澡会洗很久。工作忙导致下班后非常累，累了自然想放松下，然后玩手机或者看会游戏直播，洗完澡继续玩手机。有时候会玩手机到很晚，放下手机又睡不着了。从而没休息好，第二天赖床，然后精神状态不好，提前半小时到公司了也不想学习。就这样循环往复，一天一天飞快的过去了。这其实是个恶性循环，而打破这个循环的关键点就在于好好休息。</p>
<p>好了，不多说了，准备睡觉。每天截图看看睡觉数据。</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2019]]></title>
      <url>http://detachment.club/2019/12/30/2019/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在毫无征兆的前提下公司宣布今天所有的技术都得留在公司跨年。这个消息也算是今年生活的一个写照：社畜，毫无生活的工作着。无奈之余，就寻思那就将今年的总结写一下吧，也算是给今年一个交代吧。</p>
<a id="more"></a>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>工作方面可以从这几个方面来总结：技术、业务和团队合作。这三点基本上也涵盖了工作中所需要的方方面面。</p>
<ul>
<li><p>技术<br>技术的成长速度基本上是衡量这一年工作质量的基本指标。先下结论：除了经验性的获取技术成长之外，今年仍然没有大的突破。<br>单元测试。测试覆盖率一直以来都是用于评价一个系统稳定性的重要指标，但是由于其需要较高的时间和精力投入，导致基本上所有的业务组的覆盖率都不高。在这样的背景下，一边摸索着一边写测试，终于将项目的测试覆盖率提高到超过业务类型项目所要求的数字。需要指出的是，对于测试的理解还处在比较粗浅的程度，自己的大部分的测试解决方案都来自于经验的积累，而非知识原理性的应用。需要加强。<br>Hooks 及重构。重构分为了两部分，前期的重构纯粹的是从组件的结构和组件内的数据流方向来进行，未完全脱离之前的框架，也就是用之前的工作经验来处理当时的工作。之后学习到了 hooks，利用 hooks 中提供的类似于 redux 的数据管理方式来重构之前的组件。重构后的组件结构合理，逻辑清晰，便于维护。重构的后期，由于各种其他业务的打断，并没有很完整的进行下去，导致后期的重构效果不明显，今后需要加强。</p>
</li>
<li><p>业务<br>和以前相比，在业务上有了更大的未知性，也就是说现在对业务的了解越来越片面了，有些时候根本不知道某个需求的来龙去脉，只是在产品同学的解释下一步步的实现逻辑。以前做的每一个需求都是一个完成的产品，现在做的需求，有时候它会是一个产品，有时候它仅仅是一个配件。技术服务于业务，很多最终呈现给用户的并不是技术的好坏，而是业务的本质。在我们绞尽脑汁的将页面优化了零点几秒的时候，我们会发现很多用户连 IE 和 Chrome 都搞不清楚。这时候，这种优化就显得有点讽刺了。作为一个贴近用户的技术人员，精进业务和提高技术同样重要。今年在业务上投入的时间和精力还不够，虽然有了通过分析埋点数据来分析业务的尝试，但是不够系统也不够全面（没有改进后的对比），这是比较遗憾的。需要好好考虑下怎样系统且全面的了解当前的业务。</p>
</li>
<li><p>团队合作<br>作为一个大头兵，这个其实没有太多好写的。团队内紧跟组长的步伐，团队间紧跟负责人的步伐，不卑不亢，团结友善吧。</p>
</li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li>考驾照<br>本来计划是入职之前将驾照考出来，然而人算不如天算，最终科目三整整考了四个月，5 次都挂了，还是没有考出来。之后重新报名，又考了两次，10 月底才终于将驾照拿到手。</li>
<li>拔智齿<br>去年有一次智齿发炎了，然后去医院检查发现有四颗智齿，而且其中有一颗已经蛀掉了，当时就计划着尽快将所有的智齿拔掉。然而由于感觉医院挂号、看诊这些流程太麻烦了，所以就一直拖着，直到今年。考完驾照后，周末有时候挺无聊的，也没啥事，就寻思着去医院看看，把该拔的牙拔了吧。然后就陆陆续续的在 11 月份和 12 月份将四颗智齿全拔完了，也算是去除了一个隐患吧。期间还洗了一次牙，简直疼哭了。</li>
<li>项目检查<br>一直都看到别人说幽门螺旋杆菌，如果有感染的话会对肠胃有很大的负面影响，所以也找了个周末去检查了下，果然是阳性。不过之后一直拖着，也没有去做针对性的治疗。作为明年的一个计划吧。<br>18 年开始出现了鼻炎的症状，在天气变化的时候非常难受，也从来没有重视过。前不久症状更严重了，频繁的出现鼻塞的症状，而且经常会结痂，痒痒的老是想扣。一方面非常的不雅观，另一方面有时候会有血丝，应该是太干燥了导致鼻腔里的毛细血管破裂。然后下定决心要去检查下，之后花 200 多挂了个专家号检查。检查过程不超过 3 分钟，说应该是鼻中隔偏曲，如果要治疗的话，需要先拍 CT，然后预约手术将偏曲的软骨移除。听完有点被吓到了，暂时应该不会去手术治疗，多用盐水洗鼻吧，保持一个干燥湿润的环境，希望能有所好转。吐槽下这次专家门诊的体验：太糟糕了。</li>
<li>买保险<br>在互联网公司工作，听到了太多的意外发生，所以买了个意外险，希望用不上吧。</li>
<li>新体验<br>烫头，哈哈哈。每次去理发，tony 老师都会推荐我做个定型，说我的头发太趴了，贴在头皮上会显得很没精神。我承认老师说的对，但是对于一个学生时代根正苗红的我来说，之前从来没有过这种想法。这一天 tony 老师又来推荐，我就同意了，效果还挺满意的，也没那么明显，每天打理起来还挺方便的。不体验就不知道，一体验感觉还挺好。</li>
<li>居住证<br>真的是一年一个想法，半年一个想法。之前一直认为是肯定不会留在上海的，原因主要是压力太大了，在这种压力下根本没办法好好的体验真正的生活，会处于一种疲于奔命的状态，生活质量将几乎为零。有一次乘地铁，看着熙熙攘攘的路人，突然有了一种参与感，感觉自己也是这个城市的一部分，那一瞬间感觉很难和这个城市分开了。然后开始了解落户、买房的政策。了解下来发现其实也还好，如果这个行业和自己的身体状况没有出现大的变故的话，3 年左右的时间基本上可以首付了，5 年的时候可以落户。时间是会过的飞快的，从转行到现在，已经过去了 3 年。整体来说，我对未来持乐观的态度。了解了政策之后，先是找房东帮忙办居住证，没想到他挺不乐意的（因为去年办过一次，过期了我没去领证，导致现在要重新走流程。房东担心以后会收税，所以挺不愿意的。只要和钱有关的事情，房东就瞬间变得精明起来了）。无奈之下，找朋友老徐和维克多大佬帮忙。最后维克多大佬陪我跑了两趟才终于将居住证办了下来。在这里非常感谢维克多大佬的的帮忙，真的是在家靠父母，在外靠朋友啊。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 2019 </tag>
            
            <tag> 工作 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TypeScript]]></title>
      <url>http://detachment.club/2019/10/20/TypeScript/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TypeScript 基础知识学习，来源为官方文档，用于定期复习巩固。</p>
<a id="more"></a>
<hr>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul>
<li>布尔值</li>
<li>数字</li>
<li>字符串</li>
<li>数组：number[], Array<number></number></li>
<li>元祖：[string, number]，联合类型</li>
<li>枚举：enum Color{Red, Green, Black}</li>
<li>any</li>
<li>void: 只能赋值为 null 或者 undefined</li>
<li>null 和 undefined: 如果不打开 –strictNullChecks，null 和 undefined 为所有类型的子类型</li>
<li>never</li>
<li>object</li>
</ul>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>两种写法，someValue 本身可能不是 string 类型，用户直接断言其为 string 类型：</p>
<ul>
<li><code>let strLength: number = (&lt;string&gt;someValue).length</code></li>
<li><code>let strLength: number = (someValue as string).length</code></li>
</ul>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="变量声明-1"><a href="#变量声明-1" class="headerlink" title="变量声明"></a>变量声明</h4><p>关键词：var, let, const</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><ul>
<li>解构数组</li>
<li>解构对象：默认值、重命名、类型</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><ul>
<li>检查必须存在的属性是否存在</li>
<li>不检查属性顺序</li>
</ul>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><ul>
<li>可选属性</li>
</ul>
<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><ul>
<li>只读属性：只读变量用 const，只读属性用 readonly</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h4><ul>
<li>对象字面量作为参数传递时会经过额外的属性检查，如果对象字面量中包含目标类型中没有的类型则会报错</li>
<li>解决办法：类型断言、字符串索引签名、赋值给一个变量</li>
</ul>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><ul>
<li>形式</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数名不需要匹配，但对应位置的属性需要是兼容的</li>
</ul>
<h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><ul>
<li>索引签名，比如下面的 index</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>索引签名有两种：数字和字符串</li>
<li>可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型，因为 js 会把数字索引转化成字符串索引</li>
</ul>
<h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员</p>
<h4 id="类静态部分与实例部分的区别（？云里雾里）"><a href="#类静态部分与实例部分的区别（？云里雾里）" class="headerlink" title="类静态部分与实例部分的区别（？云里雾里）"></a>类静态部分与实例部分的区别（？云里雾里）</h4><h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><ul>
<li>可继承一个或多个接口</li>
</ul>
<h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span>(<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125;;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="接口继承类（？）"><a href="#接口继承类（？）" class="headerlink" title="接口继承类（？）"></a>接口继承类（？）</h4><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>派生类（子类），基类（超类）</li>
<li>派生类包含了一个构造函数，它必须调用 super()，它会执行基类的构造函数</li>
</ul>
<h4 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h4><ul>
<li>默认为 public: 在 TypeScript 里，成员都默认为 public</li>
<li>理解 private：当成员被标记成 private 时，它就不能在声明它的类的外部访问</li>
<li>当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的</li>
<li>如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则</li>
<li>protected 成员在派生类中仍然可以访问</li>
<li>构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承</li>
</ul>
<h4 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h4><ul>
<li>使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化</li>
<li>参数属性：参数属性通过给构造函数参数前面添加一个访问限定符来声明（public, private, protected)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">  readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">readonly name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用参数属性表述如下，和上面的类是一样的</span></span><br><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>;</span><br><span class="line">  readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">"secret passcode"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"secret passcode"</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  alert(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问</li>
<li>存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3</li>
<li>只带有 get 不带有 set 的存取器自动被推断为 readonly</li>
</ul>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><ul>
<li>存在于类本身上面而不是类的实例上</li>
<li>实例想要访问这个属性的时候，都要在前面加上类名</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节</li>
<li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现</li>
</ul>
<h4 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h4><ul>
<li>构造函数</li>
<li>把类当接口使用</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript 能够根据返回语句自动推断出返回值类型，因此我们通常省略它<br>完整的写法如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  x: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  y: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确</li>
</ul>
<h4 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h4><ul>
<li>在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型。这叫做【按上下文归类】</li>
</ul>
<h4 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h4><ul>
<li>可选参数必须跟在必须参数后面</li>
<li>带默认值的参数不需要放在必须参数的后面</li>
</ul>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="this-需要多复习"><a href="#this-需要多复习" class="headerlink" title="this(?需要多复习)"></a>this(?需要多复习)</h4><ul>
<li>JavaScript 里，this 的值在函数被调用的时候才会指定</li>
<li>箭头函数能保存函数创建时的 this 值，而不是调用时的值</li>
<li>this 参数在回调函数中</li>
</ul>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><ul>
<li>为同一个函数提供多个函数类型定义来进行函数重载</li>
<li>它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面</li>
<li>注意，function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard 会产生错误。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">  <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">    <span class="keyword">return</span> pickedCard;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型之-HelloWorld"><a href="#泛型之-HelloWorld" class="headerlink" title="泛型之 HelloWorld"></a>泛型之 HelloWorld</h4><ul>
<li>类型变量：只用于表示类型而不是值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型函数</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用方法：<ul>
<li>传入所有参数：<code>let output = identity&lt;string&gt;(&quot;myString&quot;)</code></li>
<li>使用类型推论：<code>let output = identity(&quot;myString&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h4><ul>
<li>我们把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性。下面的例子中 T 表示的就是数组中元素的类型而非入参的类型。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><ul>
<li>可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。通用用 T 表示</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用带有调用签名的对象字面量来定义泛型函数:</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123; &lt;T&gt;(arg: T): T &#125; = identity;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以将泛型参数当作整个接口的一个参数，接口里的其它成员也能知道这个参数的类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure>
<ul>
<li>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间（？）</li>
</ul>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><ul>
<li>泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型</li>
</ul>
<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在泛型约束中使用类型参数（？）</li>
<li>在泛型中使用类类型（？有点迷糊）</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h4><ul>
<li>数字枚举：不带初始化器的枚举应该被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串枚举：在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化</li>
<li>异构枚举：枚举可以混合字符串和数字成员，但不建议这样做；</li>
<li>计算的和常量成员</li>
<li>联合枚举与枚举成员的类型<ul>
<li>枚举类型本身变成了每个枚举成员的联合：可以避免一些低级错误</li>
<li>枚举成员成为了类型</li>
</ul>
</li>
<li>运行时的枚举</li>
<li>反向映射：从枚举值到枚举名字。不会为字符串枚举成员生成反向映射</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum &#123;</span><br><span class="line">  A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Enum.A;</span><br><span class="line"><span class="keyword">let</span> nameOfA = Enum[a]; <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cosnt 枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。之所以可以这么做是因为，常量枚举不允许包含计算成员</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>外部枚举</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B,</span><br><span class="line">  C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>TypeScript 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型</li>
<li>这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</li>
</ul>
<h4 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h4><ul>
<li>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型</li>
</ul>
<h4 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h4><h3 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>TypeScript 里的类型兼容性是基于结构子类型的</li>
</ul>
<h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><ul>
<li>基本规则：如果 x 要兼容 y，那么 y 至少具有与 x 相同的属性</li>
</ul>
<h4 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h4><ul>
<li>比较参数和返回值</li>
</ul>
<h4 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h4><h4 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="可选参数及剩余参数"></a>可选参数及剩余参数</h4><h4 id="枚举-2"><a href="#枚举-2" class="headerlink" title="枚举"></a>枚举</h4><ul>
<li>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的</li>
</ul>
<h4 id="类-2"><a href="#类-2" class="headerlink" title="类"></a>类</h4><ul>
<li>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较</li>
<li>类的私有成员和受保护成员会影响兼容性</li>
</ul>
<h4 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h4><h4 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h4><ul>
<li>在 TypeScript 里，有两种兼容性：子类型和赋值。它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和 any 来回赋值，以及 enum 和对应数字值之间的来回赋值。</li>
</ul>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><h4 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h4><ul>
<li>交叉类型是将多个类型合并为一个类型，它包含了所需的所有类型的特性</li>
</ul>
<h4 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h4><ul>
<li>联合类型表示一个值可以是几种类型之一</li>
<li>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员</li>
</ul>
<h4 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h4><ul>
<li>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型</li>
<li>要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词：pet is Fish 就是类型谓词。 谓词为 parameterName is Type 这种形式， parameterName 必须是来自于当前函数签名里的一个参数名</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>typeof 类型保护</li>
<li>instanceof 类型保护</li>
</ul>
<h4 id="可以为-null-的类型"><a href="#可以为-null-的类型" class="headerlink" title="可以为 null 的类型"></a>可以为 null 的类型</h4><ul>
<li>默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型</li>
<li>–strictNullChecks 标记可以解决此错误</li>
<li>可选参数和可选属性：使用了 –strictNullChecks，可选参数会被自动地加上 | undefined（不会加 null 类型）</li>
<li>类型保护和类型断言：如果编译器不能够去除 null 或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀： identifier!从 identifier 的类型里去除了 null 和 undefined</li>
</ul>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><ul>
<li>起别名不会新建一个类型，它创建了一个新名字来引用那个类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类型别名也可以是泛型</li>
<li>可以使用类型别名来在属性里引用自己</li>
<li>类型别名不能出现在声明右侧的任何地方(?)</li>
<li>接口 vs. 类型别名：<ul>
<li>其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名</li>
<li>另一个重要区别是类型别名不能被 extends 和 implements（自己也不能 extends 和 implements 其它类型）</li>
<li>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名（？不太理解）</li>
</ul>
</li>
</ul>
<h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><ul>
<li>在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串</li>
</ul>
<h4 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h4><h4 id="枚举成员类型"><a href="#枚举成员类型" class="headerlink" title="枚举成员类型"></a>枚举成员类型</h4><h4 id="可辨识联合（Discriminated-Unions）"><a href="#可辨识联合（Discriminated-Unions）" class="headerlink" title="可辨识联合（Discriminated Unions）"></a>可辨识联合（Discriminated Unions）</h4><ul>
<li>可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。</li>
</ul>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>symbol 的值是通过 Symbol 构造函数创建的</li>
<li>像字符串一样，symbols 也可以被用做对象属性的键</li>
<li>Symbols 也可以与计算出的属性名声明相结合来声明对象的属性和类成员</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getClassNameSymbol = Symbol();</span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  [getClassNameSymbol]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> className = c[getClassNameSymbol](); <span class="comment">// "C"</span></span><br></pre></td></tr></table></figure>
<h4 id="众所周知的-Symbols"><a href="#众所周知的-Symbols" class="headerlink" title="众所周知的 Symbols"></a>众所周知的 Symbols</h4><p>介绍了一些 Symbols 的通用方法</p>
<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h4 id="可迭代性"><a href="#可迭代性" class="headerlink" title="可迭代性"></a>可迭代性</h4><ul>
<li>当一个对象实现了 Symbol.iterator 属性时，我们认为它是可迭代的</li>
<li>for..of 语句：会遍历可迭代的对象，调用对象上的 Symbol.iterator 方法（for..in 迭代的是对象的键的列表，而 for..of 则迭代对象的键对应的值）</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// "0", "1", "2",</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i of list) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// "4", "5", "6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内置对象 Map 和 Set 已经实现了 Symbol.iterator</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><ul>
<li>导出声明</li>
<li>导出语句</li>
<li>重新导出</li>
</ul>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><ul>
<li>export = 和 import = require()</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018]]></title>
      <url>http://detachment.club/2019/01/07/2018/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;工作之后，越来越少的时间与自己的内心进行交流了。写年终总结是一个为数不多的与内心进行交流的契机，所以每次开始写年终总结都有一点犹豫、期待和兴奋呢。和往常一样，下面会从工作和生活两方面来进行总结。</p>
<a id="more"></a>
<hr>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ol>
<li>聚链数据（技术积累 next.js + mobx.js）</li>
<li>个人版及移动版（技术积累及应用 next.js + mobx.js）</li>
<li>机构版（技术应用：next.js）</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个坑是个深坑，填不了了。之后有时间有契机的话可以说说这段时间发生的事情，大概就是换工作面试之类的。</p>
<blockquote>
<p>本来准备去年年底写完的，一直拖一直拖，这个坑估计是填不上了。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 工作 </tag>
            
            <tag> 计划 </tag>
            
            <tag> 2018 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[个人简历]]></title>
      <url>http://detachment.club/2018/11/20/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
      <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密文章，输入密码后查看</h3><div id="security"> <div> <div class="input-group"> <input type="text" style="padding:6px 2px 7px" class="form-control" aria-label="enter the password" id="pass" placeholder="请输入密码"/> <button type="button" onclick="decryptAES()">芝麻开门</button> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 简历 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Why is setState asynchronous ?]]></title>
      <url>http://detachment.club/2018/11/12/why%20is%20setState%20asynchronous?%20/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/facebook/react/issues/11527" target="_blank" rel="noopener">https://github.com/facebook/react/issues/11527</a><br><a href="https://blog.cloudboost.io/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e" target="_blank" rel="noopener">https://blog.cloudboost.io/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解除各种浏览器跨域]]></title>
      <url>http://detachment.club/2018/09/06/%E8%A7%A3%E9%99%A4%E5%90%84%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;浏览器跨域保护是一种很常见的策略，各大浏览器都会有这种保护机制，但是在本地进行调试的时候我们并不希望这个策略生效，因为生效的话我们就没法正常拿到数据了。</p>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 浏览器兼容 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从点击下载不兼容火狐谈起]]></title>
      <url>http://detachment.club/2018/09/04/%E4%BB%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%81%AB%E7%8B%90%E5%8F%8AEdge%E8%B0%88%E5%88%B0creatObjt/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;最近遇到这样一个问题：点击按钮下载文件的时候，在 Safari 和 Chrome 上都没有问题，在 Firefox 和 Edge 上则无反应。一开始我以为是后者默默的把下载好的文件保存在了浏览器的默认位置导致的，直到昨天产品大佬告诉我默认文件夹并没有对应的文件，这才怀疑可能是在实现过程中有兼容性问题。</p>
<a id="more"></a>
<h2 id="从-window-URL-createObjectURL-blob-说起"><a href="#从-window-URL-createObjectURL-blob-说起" class="headerlink" title="从 window.URL.createObjectURL(blob) 说起"></a>从 window.URL.createObjectURL(blob) 说起</h2><p>点击下载的时候有一段代码是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">a.style = <span class="string">"display: none"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(a)</span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);   </span><br><span class="line"><span class="keyword">let</span> disposition = response.headers.get(<span class="string">'Content-Disposition'</span>);</span><br><span class="line"><span class="keyword">let</span> filename = (disposition &amp;&amp;disposition.replace(<span class="regexp">/attachment;filename=/</span>,<span class="string">''</span>)) || <span class="string">'data.xlsx'</span></span><br><span class="line">filename = <span class="built_in">decodeURI</span>(filename);</span><br><span class="line">a.href = url;</span><br><span class="line">a.download = filename;</span><br><span class="line">a.click();</span><br></pre></td></tr></table></figure></p>
<p>这段代码其实很简单，就是先创建个 Blob 对象，然后点击它下载。由于之前没有接触过这个 API， 所以稍微去了解了下，发现两篇文章：<a href="https://juejin.im/entry/5937c98eac502e0068cf31ae" target="_blank" rel="noopener">JavaScript 中 Blob 对象</a>， <a href="https://www.zhangxinxu.com/wordpress/2017/07/js-text-string-download-as-html-json-file/" target="_blank" rel="noopener">JS前端创建html或json文件并浏览器导出下载</a>，比较通俗易懂的介绍了下 Blob 对象的使用方式。这一步是没有什么问题的。</p>
<p>自然而言的会怀疑到这个API的浏览器兼容性，然后查了一下，结果如下图所示。我是用的 Firefox 是 62 版本的，所以应该也不存在兼容性问题。<br><img src="http://o9ybnkuir.bkt.clouddn.com/UC20180904_224947.png" alt="compatibility"></p>
<h2 id="到事件监听"><a href="#到事件监听" class="headerlink" title="到事件监听"></a>到事件监听</h2><p>然后开始怀疑是不是点击事件没有触发。<br>触发一个点击事件的前提：事件绑定在元素上，那么如何将一个点击事件绑定在元素上呢？</p>
<blockquote>
<p>以下内容引用自 <a href="https://stackoverflow.com/questions/6348494/addeventlistener-vs-onclick" target="_blank" rel="noopener">addEventListener vs onclick</a>         </p>
</blockquote>
<ol>
<li><p>Event Listeners (addEventListener and IE’s attachEvent)<br>在 IE 9 及以前，需要用 <code>attachEvent</code> 方法来绑定点击事件：<br><code>element.attachEvent(&#39;onclick&#39;, function() { /* 具体函数*/})</code><br>在其他绝大多数浏览器中，则可以用 <code>addEventListener</code> 来进行绑定：<br><code>element.addEventListener(&#39;click&#39;, function() { /* 具体函数*/ }, false);</code><br>利用这种方式添加事件绑定的时候，理论上可以在同一个元素绑定无数的事件，唯一需要考虑的就是性能问题以及客户端的内存，这些就都和浏览器有关了。<br>上面的例子中添加的函数都是匿名函数，其实可以先声明一个函数，然后通过函数引用的方式来绑定事件：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunctionReference = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* do stuff here*/</span> &#125;</span><br><span class="line">element.attachEvent(<span class="string">'onclick'</span>, myFunctionReference);</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, myFunctionReference , <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p> 利用  <code>addEventListener</code> 进行绑定的时候需要传第三个参数，这个参数是用来控制事件是否冒泡的。在  <code>attachEvent</code> 方法中没有此参数。     </p>
</li>
<li><p>Inline events (HTML onclick=”” property and element.onclick)<br>在支持 JavaScript 的浏览器中，我们可以在元素上加上事件监听函数，方法如下：<br><code>&lt;a id=&quot;testing&quot; href=&quot;#&quot; onclick=&quot;alert(&#39;did stuff inline&#39;);&quot;&gt;Click me&lt;/a&gt;</code><br>虽然大部分有经验的程序员都很少用这种方式，但这种方式确实也可以达到目的，而且简单直接。这种写法的缺点也显而易见：函数必须要非常简单。<br>另外一种写法是：<br><code>element.onclick = function () { /*do stuff here */ };</code><br>这种写法和上面其实是等价的，不过这样写的话函数的复杂程度就可以大大提高了。<br>利用行间事件的写法有一个很明显的缺点：每一个元素都只能有一个对应的事件，事件是作为元素的属性存储的，这样一来如果有多个同样的事件，那么前者就会被后者覆盖：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'testing'</span>);</span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="string">'did stuff #1'</span>); &#125;;</span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="string">'did stuff #2'</span>); &#125;;</span><br></pre></td></tr></table></figure>
<p> 上面这段代码执行的时候，只有第二个函数会执行，因为第一个事件被覆盖掉了。</p>
</li>
</ol>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>上面两个点都没有解决到实际的问题，最后终于在 stackOverflow 上看到了一个问题: <a href="https://stackoverflow.com/questions/30694453/blob-createobjecturl-download-not-working-in-firefox-but-works-when-debugging" target="_blank" rel="noopener">Blob createObjectURL download not working in Firefox (but works when debugging)</a> 利用里面提到的解决方案顺利解决了这个兼容性问题。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 工作 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 浏览器兼容 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习计划及路线]]></title>
      <url>http://detachment.club/2018/06/14/%E8%BF%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经很久没有制定学习计划了，每次都是心血来潮的看到想学的内容然后开始搜索，搜完相关资料后兴致没有了就放弃了。虽然挺舒服的，但从长远的角度来说，这不是一种良性的状态，所以开始恢复写博客，然后将近段时间的学习计划列出来，一步一个脚印。</p>
<ol>
<li>网络协议学习 （进行中）              </li>
<li>node.js，打开通向后端的大门        </li>
<li>深入学习 React 原理及其生态         </li>
<li>webpack &amp;&amp; git</li>
<li>数据结构和算法</li>
<li>巩固 JS 基础</li>
<li>解读 next.js 项目</li>
</ol>
<a id="more"></a>
<h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><h3 id="1-网络协议"><a href="#1-网络协议" class="headerlink" title="1.  网络协议"></a>1.  网络协议</h3><p>这块知识一直都没有花费时间和精力去学习，每次碰到与这块内容相关的问题都不知所措，所以想拿出时间学习这方案的想法越来越成熟。<br>学习途径：看书《图解 HTTP》</p>
<h3 id="2-node-js-学习路线"><a href="#2-node-js-学习路线" class="headerlink" title="2.  node.js 学习路线"></a>2.  node.js 学习路线</h3><ol>
<li>看书：Node.js in Action 和 SMASHING Node.js: Javascript Everywhere.（改为：Node.js 实战第二版）</li>
<li>跟着书实践</li>
<li>尝试结合生产环境运用</li>
<li>运用到生产环境</li>
</ol>
<h3 id="3-深入学习-React-生态"><a href="#3-深入学习-React-生态" class="headerlink" title="3. 深入学习 React 生态"></a>3. 深入学习 React 生态</h3><h3 id="4-webpack-amp-amp-git"><a href="#4-webpack-amp-amp-git" class="headerlink" title="4. webpack &amp;&amp; git"></a>4. webpack &amp;&amp; git</h3><h3 id="5-数据结构和算法"><a href="#5-数据结构和算法" class="headerlink" title="5. 数据结构和算法"></a>5. 数据结构和算法</h3><h3 id="6-巩固-JS-基础"><a href="#6-巩固-JS-基础" class="headerlink" title="6. 巩固 JS 基础"></a>6. 巩固 JS 基础</h3><h3 id="7-解读-next-js-项目"><a href="#7-解读-next-js-项目" class="headerlink" title="7. 解读 next.js 项目"></a>7. 解读 next.js 项目</h3>]]></content>
      
        <categories>
            
            <category> 计划 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页多语言版本开发]]></title>
      <url>http://detachment.club/2018/06/12/%E7%BD%91%E9%A1%B5%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着互联网时代的到来，为了满足来自世界各地的访客的需求，网站的多语言版本设计显得越来越重要。本篇博客主要用来说明怎样开发多语言版本。<br>技术栈：React.js + Next.js + Mobx.js + i18next</p>
<a id="more"></a>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><p>WIP</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 多语言 </tag>
            
            <tag> i18next </tag>
            
            <tag> next.js </tag>
            
            <tag> React.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开发笔记]]></title>
      <url>http://detachment.club/2018/06/06/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客用来记录在工作中遇到的各种疑难杂症及对应的解决方案，方便遇到同样问题时的检索。<br>问题及解决方案汇总：</p>
<ol>
<li>React.js + Next.js + i18next 报错：Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type.</li>
<li>利用 JSON.parse 进行解析的时候报错 ‘Unexpected token i in JSON at position 1’.</li>
<li>使用 forEach 对数组进行循环改变数组本身的值，然后并没有生效.</li>
<li>React.js + Next.js 跳转页面没问题，使用 safari 前进后退键的时候报错，使用 chrome 没问题.</li>
<li>部分浏览器打开页面时报错：Object.assign is not a function.</li>
<li>发送请求时控制栏报错：TypeError: Failed to execute ‘fetch’ on ‘Window’: Value is not a valid ByteString.</li>
<li>数组为空的时候试用map方法无效.</li>
</ol>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-React-js-Next-js-i18next-报错：Module-parse-failed-Unexpected-token-290-73-You-may-need-an-appropriate-loader-to-handle-this-file-type"><a href="#1-React-js-Next-js-i18next-报错：Module-parse-failed-Unexpected-token-290-73-You-may-need-an-appropriate-loader-to-handle-this-file-type" class="headerlink" title="1.  React.js + Next.js + i18next 报错：Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type."></a>1.  React.js + Next.js + i18next 报错：Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type.</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>官网个人版的数据直接放到重构的机构版时系统报错。由于分工不同，机构版将不同功能分割出来了，把共用部分放在了 common 中，其余不同模块分为了不同的项目，每个项目都是一个单独的 next.js 项目。需要引用项目外的共用文件的时候就利用 bindfs 来进行映射。<br> <img src="http://o9ybnkuir.bkt.clouddn.com/UC20180613_185341.png" alt="errorImg"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--- common</span><br><span class="line">|     - file</span><br><span class="line">|     - file</span><br><span class="line">|--- project A</span><br><span class="line">|     - file</span><br><span class="line">|     - file</span><br><span class="line">|     - next.conf.js</span><br><span class="line">|--- project B</span><br><span class="line">|     - file</span><br><span class="line">|     - file</span><br><span class="line">|     - next.conf.js</span><br></pre></td></tr></table></figure></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>由于和之前的项目相比并没有做过多的改动，但只要一启动就报这种错误，然后用关键词 <strong>Module parse failed: Unexpected token (290:73) You may need an appropriate loader to handle this file type</strong>。搜出来结果很多，基本上都是和 webpack 配置相关，然后我反思了下这两个项目都没有配置过 webpack，所以应该不是这里面出现的问题。左看右看，终于找到一条让我眼前一亮的答案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Next only compiles files inside <span class="keyword">of</span> the next root, which <span class="keyword">in</span> your <span class="keyword">case</span> is root/server. You can probably use something like <span class="number">3732</span> to compile files outside <span class="keyword">of</span> the root.</span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://github.com/zeit/next.js/issues/3819" target="_blank" rel="noopener">Spread Operator not building – Webpack #3819</a><br>看到这个答案后，将所有链接到项目外的路径改成项目内就好了。</p>
<h3 id="2-利用-JSON-parse-进行解析的时候报错-‘Unexpected-token-i-in-JSON-at-position-1’"><a href="#2-利用-JSON-parse-进行解析的时候报错-‘Unexpected-token-i-in-JSON-at-position-1’" class="headerlink" title="2. 利用 JSON.parse 进行解析的时候报错 ‘Unexpected token i in JSON at position 1’"></a>2. 利用 JSON.parse 进行解析的时候报错 ‘Unexpected token i in JSON at position 1’</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>系统有部分数据保存在 mongoDB 中，取出的数据很多时候会是字符串形式，这时候最普遍的得到具体数据的方式是利用 JSON.parse 来进行解析。大部分的时候都能成功解析，也存在有些时候会出现描述中的错误，这时候就需要分析其中的原因了。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>这个问题其实是因为需要解析的不是一个有效的 JSON 对象导致的，以下引用自 <a href="https://stackoverflow.com/questions/18791718/json-parse-unexpected-token-s" target="_blank" rel="noopener">JSON.parse unexpected token s</a> :</p>
<blockquote>
<p>What you are passing to JSON.parse method must be a valid JSON after removing the wrapping quotes for string.<br>so something is not a valid JSON but “something” is.<br>A valid JSON is -<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">JSON</span> = <span class="literal">null</span></span><br><span class="line">&gt;   <span class="comment">/* boolean literal */</span></span><br><span class="line">&gt;   or <span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line">&gt;   <span class="comment">/* A JavaScript Number Leading zeroes are prohibited; a decimal point must be followed by at least one digit.*/</span></span><br><span class="line">&gt;   or JSONNumber</span><br><span class="line">&gt;   <span class="comment">/* Only a limited sets of characters may be escaped; certain control characters are prohibited; the Unicode line separator (U+2028) and paragraph separator (U+2029) characters are permitted; strings must be double-quoted.*/</span></span><br><span class="line">&gt;   or JSONString</span><br><span class="line">    <span class="comment">/* Property names must be double-quoted strings; trailing commas are forbidden. */</span></span><br><span class="line">    or JSONObject</span><br><span class="line">    or JSONArray</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Examples -<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;&#125;'</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'"foo"'</span>); <span class="comment">// "foo"</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'[1, 5, "false"]'</span>); <span class="comment">// [1, 5, "false"]</span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">'null'</span>); <span class="comment">// null </span></span><br><span class="line">   <span class="built_in">JSON</span>.parse(<span class="string">"'foo'"</span>); <span class="comment">// error since string should be wrapped by 		double quotes</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>You may want to look <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON?redirectlocale=en-US&amp;redirectslug=JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="noopener">JavaScript and JSON differences</a></p>
</blockquote>
<p>说了这么多，那我们应该怎么去处理这种情况呢？其实很简单，用 try…catch 就行了。如果是合法的 JSON 对象就解析，如果不是则不进行处理。</p>
<h3 id="3-使用-forEach-对数组进行循环改变数组本身的值，然后并没有生效"><a href="#3-使用-forEach-对数组进行循环改变数组本身的值，然后并没有生效" class="headerlink" title="3. 使用 forEach 对数组进行循环改变数组本身的值，然后并没有生效"></a>3. 使用 forEach 对数组进行循环改变数组本身的值，然后并没有生效</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>利用 forEach 进行循环然后遍历改变原数组的需求非常常见，但稍有使用不当就会造成并没有改变原数据的结果，这主要是因为下面这个原因。</p>
<h3 id="4-React-js-Next-js-跳转页面没问题，使用-safari-前进后退键的时候报错，使用-chrome-没问题"><a href="#4-React-js-Next-js-跳转页面没问题，使用-safari-前进后退键的时候报错，使用-chrome-没问题" class="headerlink" title="4.  React.js + Next.js 跳转页面没问题，使用 safari 前进后退键的时候报错，使用 chrome 没问题"></a>4.  React.js + Next.js 跳转页面没问题，使用 safari 前进后退键的时候报错，使用 chrome 没问题</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>因为在 safari 中没找到简单快捷的操纵 cookie 的方法（在 chrome 中利用扩展 editThisCookie 很方便，在 safari 中可以直接在 console 中加入 cookie，但总归不方便），所以开发的时候一直都是在 chrome 中。项目上线后在 safari 中也测了测，没有发现问题，直到有一天同事告诉我所有的页面在后退的时候都会出现报错页面，而且只会出现在 Safari 中。百思不解，首先想到的是浏览器的兼容性，也找了很多相关的内容来看，有文章提到是因为返回的时候从缓存里面拿数据的原因，并没有提到具体的解决措施。然后想到如果真的是这个原因，那么之前做的个人版应该也会有同样的问题，所以就测了下之前的个人版，发现却并没有这个问题，所以就把思考的重点转移到了分模块打包上。在 next.js 项目的 issue 中找了找也没有找到相关的内容，问题暂时搁置。<br>大概两天后，老板说点击工商页面的时候也出现了报错页面，好像突然就有灵感了！联想到之前也有同事告诉我点击链接的时候会报错，给了我一个新思路：从链接入手！然后在官方文档上看到这么一句话：<code>For the initial page load, getInitialProps will execute on the server only. getInitialProps will only be executed on the client when navigating to a different route via the Link component or using the routing APIs.</code> 到这其实已经心中有数了。之前一直认为 getInitialProps 只会在服务器端执行，所以为了辨识用户身份，将服务器相关的参数传入到了这个函数中，然后在通过 Link 组件或者前进后退的时候，这个函数也会执行，然而此时找不到在函数中使用的参数（如 process 对象），所以系统持之以恒的报错！想到这点，问题便迎刃而解了。</p>
<h3 id="5-部分浏览器打开页面时报错：Object-assign-is-not-a-function"><a href="#5-部分浏览器打开页面时报错：Object-assign-is-not-a-function" class="headerlink" title="5. 部分浏览器打开页面时报错：Object.assign is not a function."></a>5. 部分浏览器打开页面时报错：Object.assign is not a function.</h3><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>有客户在微信打开我们的网页时发现空白页，测试发现在safari，chrome，firefox下都是没问题的。分析发现微信内置的浏览器版本对应于chrome43版本左右，版本过低导致不支持es6语法导致。问题分析到这就迎刃而解了，在next.js项目下搜索browser顺利找到解决方案。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalEntry = newConfig.entry</span><br><span class="line">  newConfig.entry = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> entries = <span class="keyword">await</span> originalEntry()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entries[<span class="string">'main.js'</span>] &amp;&amp; !entries[<span class="string">'main.js'</span>].includes(<span class="string">'./polyfills.js'</span>)) &#123;</span><br><span class="line">      entries[<span class="string">'main.js'</span>].unshift(<span class="string">'./polyfills.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entries</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  polyfills.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint no-extend-native: 0 */</span></span><br><span class="line"><span class="comment">// core-js comes with Next.js. So, you can import it like below</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add your polyfills</span></span><br><span class="line"><span class="comment">// This files runs at the very beginning (even before React and Next.js core)</span></span><br><span class="line"><span class="comment">// console.log('Load your polyfills')</span></span><br></pre></td></tr></table></figure>
<h3 id="6-发送请求时报错-TypeError-Failed-to-execute-‘fetch’-on-‘Window’-Value-is-not-a-valid-ByteString"><a href="#6-发送请求时报错-TypeError-Failed-to-execute-‘fetch’-on-‘Window’-Value-is-not-a-valid-ByteString" class="headerlink" title="6. 发送请求时报错 TypeError: Failed to execute ‘fetch’ on ‘Window’: Value is not a valid ByteString."></a>6. 发送请求时报错 TypeError: Failed to execute ‘fetch’ on ‘Window’: Value is not a valid ByteString.</h3><h4 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h4><p>组内的一个小伙伴在发送请求的时候发生了这种错误，我拉完代码后却什么问题都没有。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>推测有可能导致的原因：本地node版本，项目依赖包的版本，浏览器版本，用户信息等等。在一一排除这些因素后，项目启动还是会出现报错。网上搜索了下，没有找到特别符合的同类错误。因为使用的是 isomorphic-fetch 来请求数据的，所以也把源码稍微打开看了下，并没有找到这种类型的报错。几乎放弃的时候想起来有人提过这种错误可能是在请求中有中文导致的，逐一去检查，终于发现了原来是同事在cookie中添加了未编码的中文名，编码后重新尝试，终于好了。</p>
<h3 id="7-命令行提示本地项目启动，浏览器打开却不行"><a href="#7-命令行提示本地项目启动，浏览器打开却不行" class="headerlink" title="7. 命令行提示本地项目启动，浏览器打开却不行"></a>7. 命令行提示本地项目启动，浏览器打开却不行</h3><h4 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h4><p>尝试进行接口测试，本地部署的时候需要运行node服务，随便填了个端口：6666。</p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>多次重启未果，猜测可能是端口的原因，网上一查还真是。在chrome中6666端口被禁用的，其他被禁用的端口如下：</p>
<blockquote>
<p>1： // tcpmux<br>7： // echo<br>9： // discard<br>11： // systat<br>13： // daytime<br>15： // netstat<br>17： // qotd<br>19： // chargen<br>20： // ftp data<br>21： // ftp access<br>22： // ssh<br>23： // telnet<br>25： // smtp<br>37： // time<br>42： // name<br>43： // nicname<br>53： // domain<br>77： // priv-rjs<br>79： // finger<br>87： // ttylink<br>95： // supdup<br>101： // hostriame<br>102： // iso-tsap<br>103： // gppitnp<br>104： // acr-nema<br>109： // pop2<br>110： // pop3<br>111： // sunrpc<br>113： // auth<br>115： // sftp<br>117： // uucp-path<br>119： // nntp<br>123： // NTP<br>135： // loc-srv /epmap<br>139： // netbios<br>143： // imap2<br>179： // BGP<br>389： // ldap<br>465： // smtp+ssl<br>512： // print / exec<br>513： // login<br>514： // shell<br>515： // printer<br>526： // tempo<br>530： // courier<br>531： // chat<br>532： // netnews<br>540： // uucp<br>556： // remotefs<br>563： // nntp+ssl<br>587： // stmp?<br>601： // ??<br>636： // ldap+ssl<br>993： // ldap+ssl<br>995： // pop3+ssl<br>2049： // nfs<br>3659： // apple-sasl / PasswordServer<br>4045： // lockd<br>6000： // X11<br>6665： // Alternate IRC [Apple addition]<br>6666： // Alternate IRC [Apple addition]<br>6667： // Standard IRC [Apple addition]<br>6668： // Alternate IRC [Apple addition]<br>6669： // Alternate IRC [Apple addition]</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 总结 </tag>
            
            <tag> Node.js </tag>
            
            <tag> iOS </tag>
            
            <tag> webview </tag>
            
            <tag> H5 </tag>
            
            <tag> 兼容 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL 基础知识]]></title>
      <url>http://detachment.club/2018/02/24/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;本博客用于记录与MySQL相关的知识点。</p>
<a id="more"></a>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>显示所有数据库：show databases（注意 databases 是复数形式）；</li>
<li>显示当前数据库中的所有表：show tables；</li>
<li>显示表结构：describe <code>table-name</code>;</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 基础 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[再见了，2017]]></title>
      <url>http://detachment.club/2017/12/27/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密文章，输入密码后查看</h3><div id="security"> <div> <div class="input-group"> <input type="text" style="padding:6px 2px 7px" class="form-control" aria-label="enter the password" id="pass" placeholder="请输入密码"/> <button type="button" onclick="decryptAES()">芝麻开门</button> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 工作 </tag>
            
            <tag> 计划 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[域名迁移]]></title>
      <url>http://detachment.club/2017/06/13/%E5%9F%9F%E5%90%8D%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p> 本域名即将到期（6月22日），之后域名地址更改为：detachment.top。如果你一直在关注我的博客，别忘了更换地址。<br> 同时，在我 github 上的 <a href="https://github.com/Detachment/Detachment.github.io" target="_blank" rel="noopener">https://github.com/Detachment/Detachment.github.io</a> 这个项目里，你也可以找到我的最新博客地址，谢谢关注。</p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 域名 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[漫漫前端路]]></title>
      <url>http://detachment.club/2017/04/19/%E6%BC%AB%E6%BC%AB%E5%89%8D%E7%AB%AF%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从正式辞职到又一次开始上班，我用了整整 13 个月（差一天），时间不饶人。<br>&nbsp;&nbsp;&nbsp;&nbsp;谨以此文记录在前端路上走的每一步。</p>
<a id="more"></a>
<h2 id="路之伊始"><a href="#路之伊始" class="headerlink" title="路之伊始"></a>路之伊始</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;假设我们足够聪明，我们可以在脑海中以时间为横坐标，以对自己的认可程度为纵坐标，作一条曲线。那么这条曲线便是我们的人生之路。很久以前睿智的长辈就告诉我们，有几个时刻对这条曲线的影响会远远大于其他时刻，这些时刻包括：高考、工作和婚姻。目前我已经经历了其中了两个时间点，我认为这么说其实并不恰当。知道自己想干什么 以及 开始追求喜欢的人，在我看来才是最关键的两个点。<br>&nbsp;&nbsp;&nbsp;&nbsp;大学四年在一种不断尝试以及不断失败的模式中度过，结果就是直到毕业也没有确定自己将来到底要走一条怎样的路。毕业后进入一家机械公司，为了更好的了解工艺，选择在制造部门呆了半年，然后转到设计部。这之后在设计部做了近一年半的机械工程师。表面上的一切顺利与躁动不安的年龄格格不入。15 年下半年发生了两件事情，其一是遇到了一个喜欢的女生，其二是家里发生了一些变故。这两件事情就像是两阵风，迎面吹过，平息了内心的躁动，竟考虑安定下来了。然而时间的力量是巨大的，只用了半年，事情发生了很大的变化，此时我又开始寻思改变了。创造所带来的成就感可以让我感觉到自己的存在，在这样的环境下我无法做到这点，不能再这样消极度日了。下定决心要转行了。<br>&nbsp;&nbsp;&nbsp;&nbsp;既然要转，就面临着选择的问题。根据面向工资转行定理，很自然的想两个行业：金融和计算机。在我看来，计算机的趣味性和可创造性胜过金融，所以我用小脑做出了转计算机的决定。然后又面临选择了：做前端还是后端？要想了解一个复杂的事情，大多会选择自己熟悉的点进行切入。最开始接触的是 Python，大学的时候两个室友都选修过这门课。然后通过了解知道这门胶水语言的强大，但也正因为它的强大，我放弃了它。因为如果选择学习它，不可避免的需要在更细分的领域做出选择，而做出选择不仅需要精力还需要智慧。在这样的背景下，机缘巧合接触到了前端。最初对前端的了解是学习路线明确，可快速上手，而且涉及到视觉和交互等方面（后来才知道这部分其实已经细分到 UI 及交互设计师了）。然后就开始了前端的学习之路。<br>&nbsp;&nbsp;&nbsp;&nbsp;学习路线在我的 16 年总结中已经说的比较详细了，总的来说就是一个不断尝试的过程。这篇博客中就另外两个选择说说自己当时的想法吧：其一是为什么不选择参加培训班，其二是为什么在自学半年后放弃工作机会而继续学习。<br>&nbsp;&nbsp;&nbsp;&nbsp;参加培训班从来都没有出现在我的选择范围，细细一想，存在的原因有以下几点。上面也提到过，整个大学阶段我都处于一种比较低落的状态，虽然在不断的尝试，却并没有寻找到自己的一条路。时间虽然能慢慢减弱这种挫败感，但却无论如何也无法消除。这种自我否定的想法让我时而变得非常消极，因此我想再给自己一段思考的时间，而这段时间到底多长，我无从得出结论。基于这样的原因，我希望这段时间能够完全按照自己的想法来生活，不管是学习、玩耍还是作息。而这一点，培训机构是无论如何也满足不了的。所以就此一点，就可以完全将培训机构排除在外了。对于一个从来没有出现在脑子里面的问题作出答案，原因是被问到的次数太多了。<br>&nbsp;&nbsp;&nbsp;&nbsp;为什么不尽早参加工作？ 一部分是因为上面提到的原因：我仍然没有找到自己想要的答案，这段时间尚不能结束。另一部分的原因是当时技术水平太低，很容易限制自己的眼界，从而形成技术天花板。当然了，这只是我的想法，对于是否正确，我现在还无法做出判断。只需要对自己的选择负责就问心无愧了。</p>
<h2 id="上下而求索"><a href="#上下而求索" class="headerlink" title="上下而求索"></a>上下而求索</h2><h3 id="2017-05-21-工作第一个月"><a href="#2017-05-21-工作第一个月" class="headerlink" title="2017-05-21 工作第一个月"></a>2017-05-21 工作第一个月</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;工作还差三天就满一个月了，说一说这一个月来的感受。<br>&nbsp;&nbsp;&nbsp;&nbsp;刚入职的时候，先熟悉公司的整体业务逻辑、技术栈和工具。知道了前端主要用 React 之后，开始跟着官方文档学习。学了差不多一个礼拜，文档还没有完全看完呢，松哥找我说，先写起来吧，这样学不是办法。然后就给了我一个重构页面的小任务练手。从这开始才真正的接触到公司的业务逻辑。这才感受到，看起来非常简单的页面，背后的逻辑竟这么复杂。之前自学的时候所接触和了解的部分和真正工作中的复杂程度根本不在一个量级，我所看到的只是冰山一角罢了。<br>&nbsp;&nbsp;&nbsp;&nbsp;写了两三天，一头雾水，完全不了解里面的数据流，写出来的页面显示不了任何数据。松哥过来看了看，啪啪啪的一顿写，数据就出来了。根据他修改的部分，我又重新去看了看 Reflux 的官方文档，再来对比实际的代码进行理解，终于有了一点感觉。继续写了两三天，数据没啥问题了，但又有了其他问题：关联样式。松哥一直强调代码和样式的复用，表面上我也确实理解，但是在实际的应用过程中却很难取得这样的效果。这个还得建立在对整个系统样式的理解上，否则很难做到游刃有余的复用之前的样式。<br>&nbsp;&nbsp;&nbsp;&nbsp;一个礼拜又过去了，给了我一个真正项目上的简单页面的编写任务。初步了解了下，感觉非常简单，一两天就能做出来。哈哈哈，还是太年轻。我的想法是先从接口获取数据，然后根据数据编写页面。捣鼓了两三天，又是 JQuery 又是 Openresty 的看，想把数据弄到手，结果一无所获。这时候松哥又出现了，告诉我接口先不管，先用静态的数据来模拟，之后再来帮我一起写接口。又是两三天，自认为样式差不多了，给松哥看了看，满以为完成的很好。松哥一看，一脸黑线：你这写的啥样式？这样的样式能复用吗？能自适应吗？有初始化吗？哈哈哈，我被问的一脸懵逼，确实是没有注意这些方面。之前自学的时候，只管在表面上看起来达到效果，哪管得上规范呐。这方面还是得多注意注意。之后开始写接口了，也是一问三不知，被松哥吐槽你咋啥都不知道。看完写好的代码，又学习了新姿势，开心。<br>&nbsp;&nbsp;&nbsp;&nbsp;高中物理老师说的一句话到现在还记得，说的是人对于知识体系的理解程度分为四个阶段：1. 不知道不知道；2. 知道不知道；3. 不知道知道；4. 知道知道。认为很有道理，然后对比分析了下自己，很明显的处于第一个阶段。所以有时候根本不知道自己应该加强哪些方面，因为所有方面都需要加强。这也是目前面临的一个最大的问题。我认为解决问题的最佳途径就是多和松哥以及公司的前辈交流。调整自己的步调，努力做到和公司共振的状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;下个月的目标：一方面加强对公司业务逻辑的理解，另一方面在数据库和网络协议方面要下点心思。其实了解数据库也是为了更好的理解业务逻辑，有机统一。还有一点就是：技术博客还是得定期写一写，鞭策自己不断的学习。给自己定一个小要求，每两周写一篇技术博客，主题不限。每个月写一写总结，就更新一下这篇文章。</p>
<h3 id="2017-06-25-工作第二个月"><a href="#2017-06-25-工作第二个月" class="headerlink" title="2017-06-25 工作第二个月"></a>2017-06-25 工作第二个月</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;到昨天为止，工作满两个月。本来计划好的两周一篇技术博客，一个月一次的总结，现在却并没有做到。应该是时间有点紧，暂时还么有完全适应这种工作节奏吧。<br>&nbsp;&nbsp;&nbsp;&nbsp;这个月大体在忙两件事：1. 学习 redux，为重构后台界面做准备；2. 补充完善现在正在做的 H5 页面。懂得了一个道理：在工作中，快速学习和快速开发能力是非常重要的。以前自己一直走的是系统性学习的路线，现在应该要在快速的经验式学习上有所投入。</p>
]]></content>
      
        <categories>
            
            <category> 人生 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 心得 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【权限】 经验不够，诚意来凑]]></title>
      <url>http://detachment.club/2017/03/30/%E3%80%8A%E7%BB%8F%E9%AA%8C%E4%B8%8D%E5%A4%9F%EF%BC%8C%E8%AF%9A%E6%84%8F%E6%9D%A5%E5%87%91%E3%80%8B/</url>
      <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密文章，输入密码后查看</h3><div id="security"> <div> <div class="input-group"> <input type="text" style="padding:6px 2px 7px" class="form-control" aria-label="enter the password" id="pass" placeholder="请输入密码"/> <button type="button" onclick="decryptAES()">芝麻开门</button> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      
        <categories>
            
            <category> 人生 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 求职 </tag>
            
            <tag> 心得 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 基础知识总结（进行中）]]></title>
      <url>http://detachment.club/2017/03/21/JavaScript%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇博客为 JavaScript 基础知识总结，长期更新。</p>
</blockquote>
<a id="more"></a>
<h2 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><h2 id="在-HTML-中使用-JavaScript"><a href="#在-HTML-中使用-JavaScript" class="headerlink" title="在 HTML 中使用 JavaScript"></a>在 HTML 中使用 JavaScript</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h2><h3 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h3><p>按值访问：<br>按引用访问：  </p>
<h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><p>只能给引用类型值动态添加属性  </p>
<h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><ul>
<li>ECMAScript 中所有函数的参数都是按值传递的  </li>
<li>命名参数：  </li>
</ul>
<h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><ul>
<li>基本类型： typeof</li>
<li>引用类型： instanceof</li>
</ul>
<h3 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h3><ul>
<li>执行环境：  </li>
<li>变量对象：   </li>
<li>作用域链：</li>
<li>活动对象：</li>
</ul>
<h4 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h4><p>两种情况下会延长： with 语句以及 try-catch 语句的 catch 块</p>
<h4 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h4><ul>
<li>声明变量：</li>
<li>查询标识符：</li>
</ul>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>原理：找到不再继续使用的变量，然后释放其占用的内存。</p>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>JavaScript 中最常用的垃圾收集方式</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>不太常见的垃圾收集策略。含义是跟踪记录每个值被引用的次数。</p>
<ul>
<li>循环引用：</li>
<li>将变量设置为 null 意味着切断变量与它之前引用的值之间的连接</li>
</ul>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>讨论的是以怎样的标准来确定是否回收</p>
<h4 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h4><ul>
<li>解除引用：优化内存的最佳方式，就是为执行中的代码只保存必要的数据。一旦不再有用，最好将其值设置为 null 来释放引用。（解除引用并不意味着自动回收所占内存，而是让值脱离执行环境，以便垃圾收集器下次将其回收）</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。常被称为类，但并不妥当。因为尽管 ECMAScript 从技术上讲是一门面向对象的语言，但是不具备面向对象语言所支持的类和接口等基本结构。</p>
<ul>
<li>对象定义：</li>
<li>引用类型有时候也被称为对象定义</li>
<li>实例：</li>
<li>构造函数：</li>
</ul>
<h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul>
<li>创建：构造函数或者对象字面量</li>
<li>表达上下文：</li>
<li>语句上下文：</li>
<li>访问对象属性方式：点或者方括号，方括号会先计算后访问</li>
</ul>
<h3 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h3><ul>
<li>创建：构造函数（可省略 new ）或者数组字面量表示法</li>
<li>用字面量表示法创建时，不会调用相关函数（对象及数组都是这样）</li>
<li>数组的 length 可写</li>
</ul>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><ul>
<li>对于只有一个全局作用域： instanceof</li>
<li>对于网页中包含多个框架： Array.isArray()</li>
</ul>
<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><p>所有对象都有 toLocalString(), toString(), valueOf() 方法，对于数组：</p>
<ul>
<li>toString()：返回由数组每个值的字符串形式拼接而成并且以逗号隔开的字符串（实际上是调用数组每个值的 toString() 方法）</li>
<li>valueOf(): 返回数组</li>
<li>alert() 的参数应该是字符串形式，如果不是则会调用 toString() 方法</li>
<li>toLocalString()：除了是调用每个值的 toLocalString() 方法，其与和 toString() 没有区别</li>
</ul>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><ul>
<li>栈：可以限制插入和删除项的数据结构，是一种 LIFO (last-in-first-out) 的数据结构</li>
<li>push()：参数任意，添加到数组末尾，返回的是 <strong>数字的长度</strong></li>
<li>pop()：移除数组最后一项，返回的是 <strong>被移除的项</strong></li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><ul>
<li>队列：FIFO(First-in-First-Out)</li>
<li>shift(): 移除第一项，并返回该项，数组长度减一</li>
<li>unshift(): 在数组前端添加项，并返回数组长度</li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><ul>
<li>reverse(): 反转数组的顺序</li>
<li>sort(): 默认情况下按照升序排列，其原理是调用每个项的 toString() 方法，然后比较字符串，不适用大多情况，因此常传入比较参数。</li>
</ul>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ul>
<li>concat(): 合并数组</li>
<li>slice(): 取部分数组</li>
<li>splice(): 接收多个参数，第一个为要删除的起始位置，第二个表示要删除的项数，第三个表示要插入的项。返回被删除的项，并且会改变原数组。</li>
</ul>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><ul>
<li>indexOf(): 两参数，分别为要查找项及开始位置。返回在第一个匹配项在数组中的位置，不存在则返回 -1。使用全等比较。</li>
<li>lastIndexOf(): 同上，从数组末尾开始</li>
</ul>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>每个方法接收两个参数：处理函数及作用域（可选）。处理函数接收三个参数：数组项、项的位置及数组对象。都不会改变原数组。</p>
<ul>
<li>every(): 在函数作用后，所有项返回 true 则返回 true</li>
<li>filter(): 返回函数结果为 true 的项组成的数组</li>
<li>forEach(): 无返回值</li>
<li>map(): 返回函数作用后的新数组</li>
<li>some(): 有一项返回 true 则返回 true</li>
</ul>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><p>归并数组所有项，最终返回一个值。每个方法接收两个参数：作用在每一项的函数及归并基础值（可选）。每个函数接收四个参数：前一个值、当前值、项的索引以及数组对象</p>
<ul>
<li>reduce(): 从左往右</li>
<li>reduceRight(): 从右往左</li>
</ul>
<h3 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h3><ul>
<li>日起对象： new Date()，自动获得当前日期和时间</li>
<li>Date.parse(): 根据传入字符串返回对应毫秒数</li>
<li>Date.UTC(): 返回毫秒数，但传入参数不同</li>
<li>Date.now(): 调用该方法时的日期和时间毫秒数</li>
</ul>
<h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><h4 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h4><p>都是日期对象中的属性，书本 P102</p>
<h3 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h3><ul>
<li>创建： 字面量形式 <code>var expression = / pattern(模式) / flags(标志)</code>，或者用 new RegExp() 构造函数</li>
<li>模式：正则表达式，如包含元字符则需转义</li>
<li>标志：匹配行为。有 g，i，m</li>
</ul>
<h4 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h4><p>主要实例属性有：global, ignoreCase, lastIndex, multiline, source。能获取模式的各种信息，但用途不大</p>
<h4 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h4><ul>
<li>exec():</li>
<li>test(): 接收一个字符串参数，匹配则返回 true，不匹配返回 false</li>
</ul>
<h4 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h4><p>主要属性有 input, lastMatch, lastParen, leftContext, multiline, rightContext</p>
<h4 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h4><p>虽比较完备，但还是缺少一些特性，比如：</p>
<ul>
<li>向后查找</li>
<li>交集和并集</li>
<li>原子组</li>
<li>Unicode 支持</li>
<li>条件匹配</li>
<li>等等</li>
</ul>
<h3 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h3><p>函数是一个对象，所以函数名实际上是一个指向函数对象的指针，不会和函数绑定</p>
<h4 id="没有重载（深入理解）"><a href="#没有重载（深入理解）" class="headerlink" title="没有重载（深入理解）"></a>没有重载（深入理解）</h4><p>将函数名想象为指针，有助于理解为什么 ECMAScript 中没有重载的概念</p>
<h4 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h4><p>JavaScript 引擎是怎么确定代码中是否有函数声明的？先得扫描全部代码还是有特定的标记？</p>
<h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>函数可以作为值来使用</p>
<h4 id="函数内部的属性"><a href="#函数内部的属性" class="headerlink" title="函数内部的属性"></a>函数内部的属性</h4><p>函数内部有两个特殊的对象：arguments, this</p>
<ul>
<li>arguments: 类数组对象。有一个特殊属性： callee，用于保存一个指向拥有此 arguments 对象的函数的指针（在阶乘函数中非常有用）</li>
<li>this：引用的是函数执行的环境对象</li>
<li>caller：保存了调用当前函数的函数的引用</li>
</ul>
<h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4><p>每个函数都有两个属性：length 和 prototype</p>
<ul>
<li>length：函数希望接收的参数个数</li>
<li>prototype：对于 ECMAScript 的引用类型而言，prototype 是保存所有实例方法的真正所在。不可枚举   </li>
</ul>
<p>每个函数包含两个非继承而来的方法：apply()，call()。都用于设置函数中的 this 的值。最强大的地方在于扩中函数作用域。<br>还有一个方法： bind()，用于绑定函数实例的 this 的值   </p>
<p>函数继承而来的 toString(), toLocalString(), valueOf() 都会返回函数代码</p>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>三个特殊引用类型：Boolean, Number, String。每当读取一个基本类型时，后台会自动创建一个对应的基本包装类型对象。<br>引用类型及基本包装类型的主要区别在于对象的生存期。</p>
<h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><p>用处不大，容易造成误解</p>
<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4><ul>
<li>toFixed(): 按照指定小数位返回数值字符串表示</li>
<li>toExponential(): 以指数形式返回数字的字符串表示</li>
<li>toPrecision(): 以合适的形式返回数字的字符串表示</li>
</ul>
<h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><ul>
<li>length 属性：表示字符串中包含多少字符</li>
<li>charAt(): 获得指定位置的字符</li>
<li>charCodeAt(): 获得指定位置的字符编码</li>
<li>可以用方括号的方式访问字符</li>
<li>concat()</li>
<li>字符串操作方法：slice(), substr(), substring()。对原始字符串无影响。这三者在传入参数为负数时有很大的差别。</li>
<li>字符串位置方法：indexOf(), lastIndexOf()。第一个参数为需查找字符，第二个为查找开始位置。可通过第二个参数找到字符串中所有字符</li>
<li>trim()：删除字符串前置及后缀的所有空格</li>
<li>大小写转换：toLowerCase(), toLocaleLowerCase(), toUpperCase(), toLocaleUpperCase()</li>
<li>模式匹配方法：match()，参数为正则表达式，返回一个数组；search()，参数也为正则表达式，返回第一个匹配项的索引，没有则返回 -1；replace()，替换字符。第一个参数为正则表达式或者字符串，第二个参数为字符串或者函数，函数有三个参数：模式匹配项、匹配项位置及原始字符串。split() 根据指定的分隔符将字符串分割并返回一个结果的数组。</li>
<li>localCompare(): 比较两个字符串，并返回一个值（0，-1 或者 1）</li>
<li>fromCharCode(): 将接收的字符编码转换成字符串</li>
</ul>
<h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><p>由 ECMAScript 实现提供的，不依赖宿主环境的对象，在程序执行之前已经存在</p>
<h4 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h4><ul>
<li>编码方法：encodeURI(), encodeURIComponent(), decodeURI(), decodeURIComponent()</li>
<li><strong>eval():</strong> 好比一个完整的解析器，参数为要执行的代码。代码中的变量或者函数不会被提升，因为是在 eval() 执行时创建的</li>
<li>属性：undefined, NaN, Infinity 等等</li>
<li>window 对象</li>
</ul>
<h4 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h4><ul>
<li>属性：Math.E, Math.LN10 等等</li>
<li>方法：Math.min(), Math.max()</li>
<li>舍入方法：Math.ceil(), Math.floor(), Math.round()</li>
<li>随机：Math.rondom()</li>
<li>其他方法：Math.abs(), Math.log() 等等</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><hr>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>ECMAScript 中有两种属性：数据属性和访问器属性</p>
<ul>
<li>数据属性：[[Configurable]], [[Enumerable]], [[Writtable]], [[Value]]。如要修改，需要使用 Object.defineProperty() 方法，接收三个参数：属性所在对象、属性名以及一个描述符对象</li>
<li>访问器属性：访问器属性不包含数据值，包含 getter 函数以及 setter 函数。有四个特征：[[Configurable]], [[Enumerable]], [[Get]], [[Set]]</li>
</ul>
<h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>利用 Object.defineProperties() 方法一次定义多个属性</p>
<h4 id="读取属性的特征"><a href="#读取属性的特征" class="headerlink" title="读取属性的特征"></a>读取属性的特征</h4><p>利用 Object.getOwnPropertyDescriptor() 方法，接收两个参数，分别为属性所在对象及要读取描述符的属性名</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>抽象创建具体对象的过程。解决了创建多个相似对象的问题，却没解决对象识别的问题（即怎么知道一个对象的类型）</p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><ul>
<li>与工厂模式三点不同：不显式的创建对象，直接将属性和方法赋给 this 对象，没有 return 语句</li>
<li>constructor 属性：指向构造函数</li>
<li>与工厂模式相比：优点是——可以将自定义的构造函数的实例标识为特定类型；缺点——每个方法都要在每个实例上重新创建一遍</li>
<li>可以将同种方法提取放在全局解决上述缺点，但是又形成另一个缺点：如果对象需要定义的方法太多，则全局函数过多，那么就毫无封装性可言了</li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>prototype 属性是一个指针，指向的对象包含了由特定类型的所有实例共享的属性和方法</p>
<ul>
<li>理解原型对象：prototype 属性。 [[Prototype]]是实例中指向构造函数原型对象的指针，虽无法访问，但可以通过 isPrototypeOf() 来确定这种关系。ES5 中可以通过 Object.getPrototypeOf() 来返回这个指针所指向的对象。不能通过对象实例重写原型对象中的属性，重新创建会屏蔽查找原型对象中的属性。hasOwnProperty() 用于判断属性存在实例中还是原型中。</li>
<li>原型与 in 操作符：单独使用时，只要能访问到的属性（不管是实例中还是原型对象中），都返回 true，因此可结合 hasOwnProperty() 判断属性。在 for-in 循环中使用时略有不同。获得所有可枚举的实例属性：Object.keys()，返回属性字符串数组。如果想获得所有实例属性，用 Object.getOwnPropertyNames() 方法。</li>
<li>更简单的原型语法：用对象字面量重写原型对象，但结果就是 constructor 属性不在指向当前构造函数，而是 Object 构造函数</li>
<li>原型的动态性</li>
<li>原生对象的原型</li>
<li>原型对象的问题：最大的问题是由共享的本性导致的。</li>
</ul>
<h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>构造函数模式定义实例属性，原型模式定义方法和共享属性</p>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>将原型放在构造函数里面，通过 if 判断达到只执行一次的效果</p>
<h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><p>和工厂模式基本一样，区别在于使用 new 操作符。。。</p>
<h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><ul>
<li>稳妥对象：没有公共属性，其方法也不引用 this 的对象</li>
<li>与寄生模式不同之处：不使用 new 操作符，不引用 this</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>OO 语言支持两种继承方式：接口继承及实现继承。前者继承方法签名，后者继承方法本身。由于在 ECMAScript 中函数无签名，所以只能实现继承，主要通过原型链来实现。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>基本思想是利用原型链让一个引用类型继承另一个引用类型的属性和方法。让一个原型对象等于另一个类型的实例</p>
<ul>
<li>别忘记默认简单原型：所有的对象都继承自 Object 对象</li>
<li>确定原型和实例的关系：instanceof —— 只要构造函数在实例的原型链上出现过即返回 true；isPrototypeOf() 同样，只要原型链上出现过的原型都返回 true</li>
<li>谨慎的定义方法：先定义再添加，且添加的时候不能为对象字面量</li>
<li>原型链的问题：其一来自于包含引用类型值的原型；其二不能向超类型的构造函数传参</li>
</ul>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>借用构造函数的基本思想是在子类型构造函数的内部调用超类型构造函数</p>
<ul>
<li>传递参数：可以向超类型构造函数传参</li>
<li>借用构造函数的问题：函数复用性差</li>
</ul>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>有时候也叫作伪经典继承，结合原型链继承和借用构造函数继承。使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。最大的问题是无论什么情况下都会两次调用超类型的构造函数：一次是在创建子类型原型的时候，一次是在子类型构造函数的内部</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型可以基于已有对象创建新对象。 ES5 中的 Object.create() 方法用于规范原型式继承</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>思路与寄生构造函数和工厂模式类似</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>这种方式可以解决在组合继承模式下的问题。寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。普遍认为这种方式是引用类型最理想的继承方式。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><hr>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>定义函数的两种方式：函数声明及函数表达式</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数是一个函数调用自身的情况下构成的。递归的时候，用 arguments.callee 比直接用函数名保险</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另外一个函数作用域的函数。<br>[[Scope]] 属性保存全局变量对象的作用域链<br>作用域链本质上是一个指向变量对象的指针列表，只引用但不包含实际的变量对象<br>闭包会携带包含函数的活动对象，所以比一般函数更占内存，所以使用的时候需要注意</p>
<h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>闭包只能取得包含函数中任何变量的最后一个值</p>
<h4 id="关于-this-对象"><a href="#关于-this-对象" class="headerlink" title="关于 this 对象"></a>关于 this 对象</h4><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>闭包中引用了包含函数的活动对象</p>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。函数声明后面不能加圆括号，函数表达式可以。自执行匿名函数可以减少闭包占用内存的问题，因为执行完即销毁，没有指向匿名函数的引用了</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>任何函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。<br>特权方法：指的是有权访问私有变量和私有函数的公用方法<br>缺点：针对每个实例都会创建同样一组新方法</p>
<h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>在私有作用域中封装构造函数并将公有方法添加到构造函数的原型中。这样每个通过这个构造函数创建的实例都会共享同样的方法。好处是有利于代码复用，坏处是每个实例都没有了自己的私有变量</p>
<h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>模块模式：为单例创建私有变量和特权方法。单例指的是只有一个实例的对象。JavaScript 中一般利用对象字面量的方式创建单例</p>
<h4 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h4><p>（不知所云）</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><hr>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h2 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h2><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h2 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h2><h2 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h2><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>事件流：描述从页面接收事件的顺序。一种是冒泡流（IE），一种是事件捕获流（网景）。</p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>从具体发生的元素到不具体的上层节点。<br>现代浏览器都支持事件冒泡</p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>接收事件的顺序和事件冒泡相反<br>老版本浏览器不支持，建议放心使用事件冒泡，有特殊需要时再使用事件捕获</p>
<h4 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h4><p>“DOM2 级事件” 中规定 的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段</p>
<h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><p>事件是用户或者浏览器自身执行的某种动作，而响应这个动作的函数就叫做事件处理程序   </p>
<h4 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h4><ul>
<li>event 变量</li>
<li>利用 with 扩展作用域</li>
<li>缺点：其一是存在时差问题，其二是这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果，其三是 HTML 代码和 JavaScript 代码紧密耦合</li>
</ul>
<h4 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h4><h4 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h4><p>定义了两个方法：addEventListener() 以及 removeEventListener()，都接收三个参数：要处理的事件名，事件处理函数以及布尔值<br>通过 addEventListener()　添加的事件处理程序只能通过 removeEventListener() 来移除   </p>
<h4 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h4><p>定义了两个方法：attachEvent() 以及 detachEvent()，都接收两个参数：事件处理程序名及处理函数，事件会添加到冒泡阶段<br>和 DOM0 级处理程序的差异：DOM0 级中事件处理程序在元素的作用域作用域中运行，而 IE 则在全局作用域，因此 this 值不同<br>有多个处理程序时，后添加的先执行</p>
<h4 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h4><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>触发 DOM 上的事件时会产生一个事件对象 event，这个对像包含所有与事件相关的信息</p>
<h4 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h4><ul>
<li>在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标  </li>
<li>enent 的 type 属性</li>
<li>阻止特定事件的默认行为，可使用 preventDefault() 方法。注意，只有 cancelable 属性设置为 true 的事件才可以使用此方法来取消其默认行为</li>
<li>stopPropagation() 方法用于立即停止事件处理程序在 DOM 层次中的传播</li>
<li>eventPhase 属性</li>
<li>event 对象只存在于事件处理程序执行期间，执行完后即被销毁</li>
</ul>
<h4 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h4><h4 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h4><p>将所有的情况封装到一个函数中，根据不同的情况判断后执行（其实主要是 IE 和其他浏览器）</p>
<hr>
<blockquote>
<p>后面的内容之后再来复习</p>
</blockquote>
<h2 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h2><h2 id="使用-Canvas-绘图"><a href="#使用-Canvas-绘图" class="headerlink" title="使用 Canvas 绘图"></a>使用 Canvas 绘图</h2><h2 id="HTML5-脚本编程"><a href="#HTML5-脚本编程" class="headerlink" title="HTML5 脚本编程"></a>HTML5 脚本编程</h2><h2 id="错误处理及调试"><a href="#错误处理及调试" class="headerlink" title="错误处理及调试"></a>错误处理及调试</h2><h2 id="JavaScript-和-XML"><a href="#JavaScript-和-XML" class="headerlink" title="JavaScript 和 XML"></a>JavaScript 和 XML</h2><h2 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h2><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h2 id="Ajax-与-Comet"><a href="#Ajax-与-Comet" class="headerlink" title="Ajax 与 Comet"></a>Ajax 与 Comet</h2><p>Ajax 指的是 Asynchronous JavaScript XML，技术的核心是 XMLHttpRequest 对象（简称 XHR）</p>
<h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><h4 id="XHR-的用法"><a href="#XHR-的用法" class="headerlink" title="XHR 的用法"></a>XHR 的用法</h4><ul>
<li>open() 方法</li>
<li>send() 方法</li>
<li>响应后的 XHR 对象属性：responseText, responseXML, status, statusText, readyState(0, 1, 2, 3, 4)(异步请求时的属性)</li>
<li>readystatechange 事件</li>
<li>abort() 方法</li>
</ul>
<h4 id="HTTP-头部信息"><a href="#HTTP-头部信息" class="headerlink" title="HTTP 头部信息"></a>HTTP 头部信息</h4><ul>
<li>setRequestHeader()：设置自定义头部信息，需要在 open() 方法之后，sent() 方法之前调用</li>
<li>getResponseHeader(): 取得特定响应头部信息</li>
<li>getAllResponseHeaders(): 返回多个头部信息</li>
</ul>
<h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>常用于向服务器查询某些信息<br>查询字符串的参数名和值都需要使用 encodeURIComponent() 编码后才能放在 URL 末尾</p>
<h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>向服务器发送应该被保存的数据<br>模仿表单提交来发送数据</p>
<h3 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h3><p>并非所有浏览器都完整的实现了 2 级规范，但所有的浏览器都实现了它规定的部分内容</p>
<h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>FormData 为序列化表单及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利<br>方便之处体现在不需要明确的在 XHR 对象上设置请求头部</p>
<h4 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h4><p>IE8 是唯一支持 timeout 属性的浏览器</p>
<h4 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType() 方法"></a>overrideMimeType() 方法</h4><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><p>6个进度事件：loadstart, progress, error, abort, load, loadend。目前大部分支持前面五个事件，目前还没有浏览器支持 loadend 事件。</p>
<h4 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a>load 事件</h4><h4 id="progress-事件"><a href="#progress-事件" class="headerlink" title="progress 事件"></a>progress 事件</h4><p>三个属性：lengthComputable, position, totalSize<br>可以根据这个属性为用户创建一个进度指示器</p>
<h3 id="跨域源资源共享"><a href="#跨域源资源共享" class="headerlink" title="跨域源资源共享"></a>跨域源资源共享</h3><p>CORS(Cross-Origin Resource Sharing) 跨域源资源共享<br>基本思想：使用自定义的 http 头部让浏览器与服务器进行沟通，从而决定请求或者响应是否成功</p>
<h4 id="IE-对-CORS-的实现"><a href="#IE-对-CORS-的实现" class="headerlink" title="IE 对 CORS 的实现"></a>IE 对 CORS 的实现</h4><p>在 IE8 中引入了 XDR(XDomainRequest) 类型，与 XHR 类似，但能实现安全可靠的跨域通信。<br>所有 XDR 请求都是异步执行的，不能用它来创建同步请求</p>
<h4 id="其他浏览器对-CORS-的实现"><a href="#其他浏览器对-CORS-的实现" class="headerlink" title="其他浏览器对 CORS 的实现"></a>其他浏览器对 CORS 的实现</h4><p>其他浏览器都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持</p>
<h4 id="Preflighted-Reqeusts"><a href="#Preflighted-Reqeusts" class="headerlink" title="Preflighted Reqeusts"></a>Preflighted Reqeusts</h4><h4 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h4><p>withCredentials 属性</p>
<h4 id="跨浏览器的-CORS"><a href="#跨浏览器的-CORS" class="headerlink" title="跨浏览器的 CORS"></a>跨浏览器的 CORS</h4><p>条件判断浏览器，主要区别在于 XDR 和 XHR</p>
<h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h3><h4 id="图像-Ping"><a href="#图像-Ping" class="headerlink" title="图像 Ping"></a>图像 Ping</h4><p>图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式<br>常用于跟踪用户点击页面或动态广告曝光次数。缺点有二：其一是只能发送 GET 请求，其二是无法访问服务器的响应文本。<br>图像 Ping 只能用于浏览器与服务器间的单向通讯</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP 是 JSON with padding 的简写，由回调函数及数据组成。<br>极为流行，因为简单易用。与图像 Ping 相比，优点在于可以直接访问响应文本，而且支持浏览器和服务器之间双通信。两点不足：从其他域加载涉及到安全问题，要确定请求失败并不容易。</p>
<h4 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h4><p>Comet 是一种服务器向页面推送数据的技术。（由 Alex Russell 发明）<br>两种实现 Comet 方式：长轮询和流<br>长轮询是传统轮询（也称为短轮询）的翻版：页面发起一个服务器请求，然后服务器一直保持打开，直到有数据可发送<br>HTTP 流：浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向服务器发送数据</p>
<h4 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h4><p>SSE（服务器发送事件）：围绕只读 Comet 交互推出的 API 或者模式。支持短轮询、长轮询和 HTTP 流，而且在断开时能够自动确定何时重新连接。   </p>
<ul>
<li>EventSource 对象</li>
</ul>
<h4 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h4><p>目标是在一个单独的持久连接上提供双工、双向通信<br>好处：能够在客户端和服务器之间发送非常少的数据，适合移动应用<br>坏处：制定协议的时间比制定 JavaScript API 的时间还要长，而且可能存在一致性和安全性的问题</p>
<h4 id="SSE-与-Web-Sockets"><a href="#SSE-与-Web-Sockets" class="headerlink" title="SSE 与 Web Sockets"></a>SSE 与 Web Sockets</h4><p>考虑两点：其一是否有自由度建立和维护 Web Sockets 服务器；其二是否需要双向通信</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>CSRF(Cross-Site Reqeust Forgery)：跨站点请求伪造</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><hr>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>利用 Object.prototype.toString.call(name) 对变量名为 name 的对象进行检测，返回的结果形式 [object NativeConstructorName] 就显示了其构造函数名。注意这种方法不能检测非原生构造函数的构造函数名。</p>
<h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>惰性载入表示函数执行的分支仅会发生一次。<br>实现方式：其一是在函数被调用时再处理函数，其二是在声明时就指定适当的函数    </p>
<h4 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4><p>主要用于事件处理程序及定时器中</p>
<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>基本方法：使用闭包返回一个函数</p>
<h3 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h3><p>一旦把对象定义为防篡改，就无法撤销了。</p>
<h4 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h4><p>Object.preventExtensions() 以及 Object.isExtensible()<br>不可扩展，但已有成员可以修改和删除</p>
<h4 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h4><p>密封对象不可扩展而且已有成员不能被删除<br>通过 Object.seal() 来密封，也可以通过 Object.isSealed() 来检测是否被密封</p>
<h4 id="冻结的对象"><a href="#冻结的对象" class="headerlink" title="冻结的对象"></a>冻结的对象</h4><p>最严格的防篡改级别是冻结对象，既不可扩展，又是密封的，而且数据属性的 [[Writtable]] 特性会被设置为 false。如果定义 [[Set]] 函数，访问器属性仍然是可写的。<br>Object.freeze()   </p>
<h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><p>关于定时器要记住的最重要的事情是：指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。</p>
<h4 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h4><p>主要的问题是某些间隔可能会被跳过，而且多个定时器的代码执行之间的间隔可能会比预期小。解决办法是链式调用延时定时器。</p>
<hr>
<h2 id="离线应用与客户端存储"><a href="#离线应用与客户端存储" class="headerlink" title="离线应用与客户端存储"></a>离线应用与客户端存储</h2><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="新兴的-API"><a href="#新兴的-API" class="headerlink" title="新兴的 API"></a>新兴的 API</h2><hr>
<h2 id="ECMAScript-6-入门"><a href="#ECMAScript-6-入门" class="headerlink" title="ECMAScript 6 入门"></a>ECMAScript 6 入门</h2><h3 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h3><p>###</p>
]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从零开始搭建 《vue-hackernews-2.0》]]></title>
      <url>http://detachment.club/2017/03/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%20Vue-HackerNews-2.0%20%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>欢迎大家来到我的第一个程序搭建教程: <strong>从零开始搭建 《vue-hackernews-2.0》</strong>。</p>
<blockquote>
<p>项目源码地址: <a href="https://github.com/Detachment/Build-vue-hackernews-2.0-from-scratch" target="_blank" rel="noopener">Bulid vue-hackernews-2.0 from Scratch</a>   </p>
</blockquote>
<p>作为一个前端开发的初学者，在接触学习到 Vue.js 的时候，我发现官方提供并极力推荐的项目《vue-hackernews-2.0》对于新手而言比较难理解。但同时我又被这种高度工业化的项目所吸引，所以我决定花一段时间来弄清楚这个项目到底是怎么运行起来的。 在这个教程中我将会通过利用不同的版本的迭代的方式来逐步重建这个项目。</p>
<a id="more"></a>
<p><strong>这个项目是面向初学者的。</strong> 整个教程中，我逐步实现了这个项目的四个版本，每一个版本之间有一定的递进关系。为了方便理解掌握每个版本的内容，在每个版本的说明中，我会尽量把在相应版本中所需要掌握的知识点列出来。</p>
<blockquote>
<p>注明：简便起见，如未特别说明，在之后的所有章节中我会用 Vue-HN 来代替 vue-hackernews-2.0 项目。 项目运行的系统是 Windows 7，因条件限制未在其他系统上测试，请见谅。</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-Vue-js-Vuex-Vue-router-HN-API-Firebase-ES6"><a href="#0-Vue-js-Vuex-Vue-router-HN-API-Firebase-ES6" class="headerlink" title="0. Vue.js, Vuex, Vue-router, HN API, Firebase, ES6"></a>0. Vue.js, Vuex, Vue-router, HN API, Firebase, ES6</h3><h4 id="章节前言"><a href="#章节前言" class="headerlink" title="章节前言"></a>章节前言</h4><p>作为一个前端初学者，我对最原始的页面构造比较熟悉，也就是页面只由 HTML、CSS 以及 JavaScript 构成。所以自从我开始学习 Vue-HN 这个项目我就想是不是可以用最原始的方法来实现这个项目（当然，不考虑用户体验及性能等方面）。在经过多次失败的尝试之后，我终于只利用 Vue.js 及其生态中的一些库实现了这个版本。下面这两个动图就分别是我这个版本和官方版本。</p>
<p align="center"><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/0-edition/Anthor.gif" width="700px" alt="Origin Website"><br>    [ 我的版本 ]<br>    <br><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/0-edition/Mine.gif" width="700px" alt="Plane Vue.js"><br>    [ 官方版本 ]<br></p>

<p>从上面的动图我们可以清楚的看到，基本上官方给出例子中的所有功能在我这个版本中都被实现出来了，而且仅仅只依赖于 Vue.js 以及其生态中的一些库。在开始搭建这个版本的项目之前，你应该对下面所列的链接中的知识点有所了解。了解完之后开始看代码才会有初步的认识。（了解每个链接对应的知识点即可，链接仅供参考。比如要了解 ES2015 的知识，就很推荐阮一峰老师的教程）</p>
<ul>
<li><a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js 2.0: The Progressive JavaScript Framework</a></li>
<li><a href="https://router.vuejs.org/en/" target="_blank" rel="noopener">Vue-router 2.0: A Simple Router for Vue.js</a></li>
<li><a href="http://vuex.vuejs.org/en/" target="_blank" rel="noopener">Vuex 2.0: State Management Patter and Library for Vue.js Application </a></li>
<li><a href="https://github.com/HackerNews/API" target="_blank" rel="noopener">Hacker News API: HackerNews API Works with Firebase</a></li>
<li><a href="https://babeljs.io/learn-es2015/" target="_blank" rel="noopener">Learn ES2015: A detailed overview of ECMAScript 2015 features</a></li>
<li><a href="https://firebase.google.com/docs/web/setup" target="_blank" rel="noopener">Firebase: App success made simple</a></li>
</ul>
<p>一眨眼看到需要了解这么多资料，你可能会被吓到。其实你不用担心，因为列出来的这些链接中除了 Vue.js 及其生态需要花较多时间来深入了解之外，其与的只需要稍微了解就行。比如 ES6 的内容，你暂时只需要了解箭头函数、 Promise 异步操作、扩展运算符等一些基本知识。另外两个链接则是 API，在用到的时候稍微花一点点时间浏览官方文档就行。</p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>搭建这个版本的时候，有几个关键的技术难点需要解决：</p>
<ul>
<li><p>怎样在不安装 Firebase 包的情况下通过 HackerNews 提供的 API 获取所需要的数据？<br><strong>Answer :</strong> 通过阅读 Firebase 的官方文档，我发现可以通过在文件中通过连接引入的方式来获取 Firebase 包的内容。除此之外，本地只需要针对项目稍加配置就行。下面是通过与不通过安装包的两种本地配置代码：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// without installing firebase package:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">    databaseURL: <span class="string">"https://hacker-news.firebaseio.com"</span></span><br><span class="line">&#125;;</span><br><span class="line">firebase.initializeApp(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> api = firebase.database().ref(<span class="string">'/v0'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// with firebase package:</span></span><br><span class="line"><span class="keyword">import</span> Firebase <span class="keyword">from</span> <span class="string">'firebase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = inBrowser</span><br><span class="line">  ? <span class="keyword">new</span> Firebase(<span class="string">'https://hacker-news.firebaseio.com/v0'</span>)</span><br><span class="line">  : (process.__API__ || (process.__API__ = createServerSideAPI()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServerSideAPI</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> api = <span class="keyword">new</span> Firebase(<span class="string">'https://hacker-news.firebaseio.com/v0'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么实现 vuex 和 router 之间的通讯？<br><strong>Answer :</strong> 保证通讯需要注意以下两点:</p>
<ul>
<li>在同一个 Vue 实例里面注册这两个插件;</li>
<li>通过一个叫做 “vuex-router-sync” 的插件实现通讯.  <blockquote>
<p>注意: 因为我们这个版本中并没有引入包管理工具，所以我们需要手动将这个插件包的 index.js 文件中的代码提取出来，稍作更改后通过链接的形式引入到主页面*    </p>
</blockquote>
</li>
</ul>
</li>
<li><p>怎么转换各个单文件组件（也就是 .vue 文件）？<br><strong>Answer :</strong> 每个单文件组件都包含三个部分： HTML 模板， JavaScript 脚本以及 CSS 样式。模板部分我们通过 “x-template” 来替换， JavaScript 脚本我们通过 “Vue.extend” 来替换， CSS 样式则直接写在样式表中就可以了。如果你想知道详细的信息，那就需要下载源码来瞧瞧了。</p>
</li>
</ul>
<p>在攻克这些难点，又加上对于 Vue.js 及其生态有较深入的了解之后，你应该也能自己完成这个版本的项目搭建过程了！（虽然不能用于生产，没有什么实际意义，但是实现的过程我认为还是很有意思的。）</p>
<blockquote>
<p>注意：因为文件之间的依赖原因，所以浏览器对于主页面文件头中的链接加载顺序直接影响到这个版本的成败。经测试，在 Firefox 和 IE 中都会优先加载本地文件然后加载外链，这并不是我所希望的顺序，所以在这两个浏览器中测试失败（可以通过将本地文件上传云存储，然后替换成外链解决）。在 Chrome 中测试成功。</p>
</blockquote>
<h4 id="后续版本"><a href="#后续版本" class="headerlink" title="后续版本"></a>后续版本</h4><p>目前一切顺利。但是如果我们更耐心些，重新审视这个版本的项目，我们会发现存在一些致命的缺陷。比如所有的文件都很混乱，项目的结构非常的脆弱，而且没有任何措施用于提高访问速度、优化用户体验。这些都会造成很高的维护成本。<br>在下一个版本中，我们将针对这些作出一些改进。  </p>
<hr>
<h3 id="1-Webpack-Vue-js-Vue-router-Vuex-and-Hackernews-API"><a href="#1-Webpack-Vue-js-Vue-router-Vuex-and-Hackernews-API" class="headerlink" title="1. Webpack, Vue.js, Vue-router, Vuex and Hackernews API"></a>1. Webpack, Vue.js, Vue-router, Vuex and Hackernews API</h3><h4 id="章节前言-1"><a href="#章节前言-1" class="headerlink" title="章节前言"></a>章节前言</h4><p>经过第一个版本后，我们对这个项目有了初步的了解。在这个版本中，我们会使用一些工具，使得我们这个项目初步模块化，同时也更加便于维护。在这个版本中我们将会使用到一些基本的插件和包，并通过 webpack 来实现功能。我们只需要简单的配置一下 webpack 就行，不会涉及到服务器端的内容，不会涉及缓存也不会涉及生产模式及开发模式的不同配置。下面的动图就是这个版本的成品，同时这个动图里面还包含了对整个项目的简单解构。</p>
<p align="center"><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/1-edition/first_edition.gif" width="700px" alt="Basic functions and simple deconstruction"><br>    [ 基本功能及简单解构 ]<br></p>

<p>为了更好的理解这个版本的内容，下面会列出一些需要了解的工具、插件和库的链接，你只需要对这些有基本的了解就行。（如果前面版本中已经列出来了，那么本节将不再重复。比如 Vue.js 及其生态、ES6 等等）：</p>
<ul>
<li><a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack 2.0: Moudle Bundler</a></li>
<li><a href="https://www.npmjs.com/package/es6-promise" target="_blank" rel="noopener">Package: es6-promise</a></li>
<li><a href="https://www.npmjs.com/package/firebase" target="_blank" rel="noopener">Package: firebase</a></li>
<li><a href="https://www.npmjs.com/package/vuex-router-sync" target="_blank" rel="noopener">Package: vuex-router-sync </a></li>
<li><a href="https://www.npmjs.com/package/buble" target="_blank" rel="noopener">Package: buble</a></li>
<li><a href="https://www.npmjs.com/package/buble-loader" target="_blank" rel="noopener">Package: buble-loader</a></li>
<li><a href="https://www.npmjs.com/package/css-loader" target="_blank" rel="noopener">Package: css-loader</a></li>
<li><a href="https://www.npmjs.com/package/file-loader" target="_blank" rel="noopener">Package: file-loader</a></li>
<li><a href="https://www.npmjs.com/package/rimraf" target="_blank" rel="noopener">Package: rimraf</a></li>
<li><a href="https://www.npmjs.com/package/stylus" target="_blank" rel="noopener">Package: stylus</a></li>
<li><a href="https://www.npmjs.com/package/autoprefixer" target="_blank" rel="noopener">Package: autoprefixer</a></li>
<li><a href="https://www.npmjs.com/package/stylus-loader" target="_blank" rel="noopener">Package: stylus-loader</a></li>
<li><a href="https://www.npmjs.com/package/url-loader" target="_blank" rel="noopener">Package: url-loader</a></li>
<li><a href="https://www.npmjs.com/package/vue-loader" target="_blank" rel="noopener">Package: vue-loader</a></li>
</ul>
<p>上面的清单好像有点过长，很容易唬到人，不过完全不用担心。因为对于这些工具、插件和库，我们目前所需要了解的仅仅是它们的用途是什么以及怎么正确的使用它们。相信我，这些对于所有人来说都是没有什么难度的。（英语不好的可以借助各种翻译工具，问题也不大）</p>
<h4 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h4><p>搭建这个版本有几个比较重要的步骤，下面将分别对每一步进行简单的介绍。</p>
<h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p><strong>项目结构分析。</strong> 其实这一步应该是写在上一个版本中的，因为每当我们开始做一个新的项目的时候，不可避免的需要先去考虑项目的整体结构、功能、风格以及通过怎样是手段来实现这些。分析完以后再来动手代码搭建整个项目才是正确的方式。这个项目的简单解构在上面的动图中已经展示出来了（解构在动图的后半部分，耐心看完）。<br>简单归纳，项目的结构还是比较简单的，主要由几个不同的页面组成，每个页面又由几个相同或者不同的组件组成。  </p>
<h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p><strong>获取数据。</strong> 把获取数据作为第二步是因为它和项目的整体结构是独立的。在这一步我们需要利用到由 HackerNews 官方提供的 API（这个 API 利用 Firebase 制作）。然后定义一些获取数据的函数，形成 api.js 文件。然后在 Vuex 中调用这些函数，达到数据集中管理的目的。完成这一步后，项目的目录大概是这样子的：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> -- src</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- store</span></span><br><span class="line">|<span class="string">           </span>|<span class="string"> -- api.js    </span></span><br><span class="line">|<span class="string">           </span>|<span class="string"> -- index.js</span></span><br></pre></td></tr></table></figure></p>
<h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p><strong>搭建组件及页面。</strong> 基于第一步中对于项目的结构分析，我们开始编写组件及页面的代码。先编写组件的代码，然后将组件引入到页面中，再来构建页面。组件直接可以通过 <code>components option</code> 来相互引入，父子组件之间的数据传递可以利用 <code>props</code> 特性。完成这一步之后，项目结构大概是这样子的：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> -- src</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- store</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- api.js    </span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- index.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">        </span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- components</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Item.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemList.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Comment.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Spinner.vue</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- views</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- UserView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- CreateListView.js</span></span><br></pre></td></tr></table></figure></p>
<h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><p><strong>完成项目剩下部分。</strong> 在这一步中，我们会引入 Vue.js 的路由系统：Vue-router。引入后，我们就可以将组件中的链接替换成路由中的路径。然后利用前文提到过的 <code>vuex-router-sync</code> 插件来同步路由和数据中心。除此之后，我们还需要定义几个全局筛选函数，并且注册在同一个 Vue 实例中。其他还有一些小的工作，比如引入 logo 图片，新建入口文件（为下一步 webpack 打包做准备）等等。完成这一步之后的项目目录大概如下所示：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">-- public</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- logo-48.png</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">-- src</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- store</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- api.js    </span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- index.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">        </span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- components</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Item.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemList.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Comment.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- Spinner.vue</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- views</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- ItemView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- UserView.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- CreateListView.js</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- filters</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string"> -- index.js</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- router</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">       </span>|<span class="string">-- index.js</span></span><br><span class="line">|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- app.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- App.vue</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- entry.js</span></span><br><span class="line">|<span class="string">    </span>|<span class="string"> -- index.html</span></span><br></pre></td></tr></table></figure></p>
<h5 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h5><p><strong>终于要用上 webpack 啦！</strong> 如果你对于 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> , <a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a> 以及 <a href="https://docs.npmjs.com/getting-started/what-is-npm" target="_blank" rel="noopener">npm</a> 这些内容完全不知道，那么你就需要在开始这一步之前花几个小时的时间来了解一下。 在这个版本中，我们利用包管理工具 <code>npm</code> 来安装或者卸载插件。在初始化我们的项目的时候，我们既可以通过在命令行中输入 <code>npm init</code> （自动新建 node 配置文件，默认文件名为 <code>package.json</code> ）又可以自己手动新建一个名为 <code>package.json</code> 的配置文件。安装完各种插件后，我们可以开始配置 webpack 了。为了方便起见，我们会新建一个配置文件，默认文件名为 <code>webpack.config.js</code> ，在这个文件里面我们将会对项目进行简单配置。具体的配置情况可以去看原文件。   </p>
<blockquote>
<p>注意：在使用 <code>npm</code> 之前，你必须先安装最新版本的 <code>node.js</code>，否则无法运行成功。</p>
</blockquote>
<h4 id="后续版本-1"><a href="#后续版本-1" class="headerlink" title="后续版本"></a>后续版本</h4><p>对比上一个版本，我们在这个版本已经有点取得了一点进步，因为这个版本开始初步模块化了，也更加的易于维护。由于文件依赖及链接加载顺序的的关系，上一个版本只支持在 Chrome 浏览器中运行，而这个版本则不存在这个问题。因为我们在组件化的过程中已将所需要的对应依赖通过模块引入了。<br>然而，这个版本的项目还远远不够完美。在下一个版本中，我们将会将更多的因素考虑在内，而这些因素都会对用户体验产生很重要的影响。</p>
<hr>
<h3 id="2-Server-Packages-and-Plugins-for-Better-Performance"><a href="#2-Server-Packages-and-Plugins-for-Better-Performance" class="headerlink" title="2. Server, Packages and Plugins for Better Performance"></a>2. Server, Packages and Plugins for Better Performance</h3><h4 id="章节前言-2"><a href="#章节前言-2" class="headerlink" title="章节前言"></a>章节前言</h4><p>于我而言，这个版本是整个项目中最难的一个版本。为了优化用户体验，原作者将很多因素考虑在内，这就会带来很多需要了解的新知识，比如 node.js 中的 express 框架以及各种插件。服务器端及客户端、生产模式及调试模式的不同配置是这个版本的重点。在接下来的片段中，我会将我所理解的部分分享给大家。<br>由于这个版本和<a href="https://vue-hn.now.sh/top" target="_blank" rel="noopener">官网</a>的一样，我就不上效果图了。</p>
<h4 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h4><ol>
<li><p><strong>开启 Node server 之路： <code>server.js</code></strong><br><a href="https://vuejs.org/v2/guide/ssr.html" target="_blank" rel="noopener">在一些情况下</a> 你可能会需要在你的项目中使用到 SSR (Server-Side Rendering) ，以此来优化网页。在这个版本中，我们即将这个功能考虑在内。<br>既然是服务器端渲染，那么我们首先需要一个服务器。在这个版本中，我们采用的目前非常流行的运行在 Node.js 环境下的 express 框架。通过阅读官方提供的文档，很快我们就可以对此框架有一个初步的了解，知道其主要的用途及使用方法。（中文教程可参考阮一峰老师的 Node.js 入门。）<br><a href="http://expressjs.com/" target="_blank" rel="noopener">Express: Fast, unopinionated, minimalist web framework for Node.js</a><br>除此之外，我们还需要了解一些 Node.js 相关知识，比如 Path 模块、文件系统、系统变量等等。其实对于目前而言，这些内容也只是需要知道它们代表什么意思，以及怎么使用它们就够了。而这也是非常简单的。下面的链接是一些相关的需要了解的内容：<br><a href="https://nodejs.org/api/" target="_blank" rel="noopener">Node.js v7.7.2 Documentation</a><br>如果你之前不了解 SSR，那么点击下面的链接：<br><a href="https://www.npmjs.com/package/vue-server-renderer#api" target="_blank" rel="noopener">vue-server-renderer</a><br>除了上面的以外，下面这些插件和包能够使项目性能更加优化：<br><a href="https://www.npmjs.com/package/serve-favicon" target="_blank" rel="noopener">serve-favicon: Node.js middleware for serving a favicon</a><br><a href="https://www.npmjs.com/package/compression" target="_blank" rel="noopener">compression: Node.js compression middleware.</a><br><a href="https://www.npmjs.com/package/serialize-javascript" target="_blank" rel="noopener">serialize-javascript: Serialize JavaScript to a superset of JSON</a><br>浏览过上述文档后，我们就具备了理解 <code>server.js</code> 文件的知识储备。这很关键，因为这个文件直通服务器之门。</p>
</li>
<li><p><strong>生产模式及开发模式</strong><br>这两种模式 <strong>最大</strong> 的区别就是是否具有热替换及热更新功能。在生产模式下， webpack 不会监控文件的更新，在开发模式下是会的。相对于生产模式而言，开发模式更复杂一些（因为会使用到一些中间件），所以我们先来讨论一下开发模式吧。<br>正如名字所说，我们只会在开发过程中使用开发模式。所以在这个模式下，我们不是特别关心所加载的文件大小、文件数量以及访问速度等。这些都会导致在两种不同模式下的 webpack 配置文件有部分差异。为了实现热替换及热更新功能，我们可以使用 webpack 提供的 <code>webpack-hot-middleware</code> 和 <code>webpack-dev-middleware</code> 中间件。实现热更新的原理是调用 webpack 的 HMR API 来监测服务器变化。相关文档如下：<br><a href="https://www.npmjs.com/package/webpack-hot-middleware" target="_blank" rel="noopener">webpack-hot-middleware</a><br>除了上面的中间件，还需要了解下面链接中所包含的内容，这会使得我们能更好的的理解开发模式下服务器配置文件，也就是 <code>setup-dev-server.js</code> ：<br><a href="https://webpack.js.org/api/node/" target="_blank" rel="noopener">webpack node API</a><br><a href="https://webpack.js.org/api/node/#stats-object" target="_blank" rel="noopener">webpack API: stats-object</a><br>在生产模式下，服务器端会渲染经过 webpack 打包处理过的打包文件，然后客户端接收相关页面。在这个模式下为了提高访问速度，优化用户体验，我们会会使用一些其他的插件。比如下面列出来的两个插件就只是应用在生产模式下：<br><a href="https://www.npmjs.com/package/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a><br><a href="https://www.npmjs.com/package/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a><br>如果你想知道这两种模式在 webpack 配置上的详细差别，可以去看 <code>webpack.client.config.js</code> 和  <code>webpack.base.config.js</code> 配置文件。</p>
</li>
<li><p><strong>服务器端和客户端</strong><br>在配置 webpack、获取页面数据的时候，我们既需要配置客户端，也需要配置服务器端，并且要保证它们之间不产生冲突。至于在 Vue.js 中使用 SSR 功能时应该怎样在 webpack 中配置，官方文档有详细说明，可以点击下面的链接：<br><a href="https://www.npmjs.com/package/vue-server-renderer" target="_blank" rel="noopener">vue-server-renderer</a>。保证两端协调工作的一个关键点是在加载初始页面时怎样保证初始数据一致，想了解这点可以去阅读 <code>server-entry.js</code> 和 <code>client-entry.js</code> 文件。     </p>
</li>
<li><p><strong>当在命令行中输入 <code>npm run dev</code> 时，具体会发生什么？</strong><br>未完待续。  </p>
</li>
</ol>
<h4 id="后续版本-2"><a href="#后续版本-2" class="headerlink" title="后续版本"></a>后续版本</h4><p>基本上这就是我对这个项目的理解了。有一些不懂的地方没有说明，也有一些懂的地方没有说到。之后对整个项目有更深入、更高层次的理解再来补充这一章。在下一个版本中，我将会根据我自己的喜好对整个项目进行一些改造（主要是外在的页面）。下个版本再见。  </p>
<hr>
<h3 id="3-Change-the-Project-as-I-like"><a href="#3-Change-the-Project-as-I-like" class="headerlink" title="3. Change the Project as I like"></a>3. Change the Project as I like</h3><h4 id="章节前言-3"><a href="#章节前言-3" class="headerlink" title="章节前言"></a>章节前言</h4><p>在这个版本中，我将会根据自己的喜好对整个网页进行一些改造，使得网页整体更具有 Vue.js 风格，至少从视觉上来说更加的 Vue.js。下面的动图可以预览到我这个版本的成品，为了对照官方例子，你可以去<a href="https://vue-hn.now.sh/top" target="_blank" rel="noopener">官网</a>查看原网页。对于所添加及更改的部分，本节的下半部分将会详细介绍。</p>
<p align="center"><br>    <img src="http://o9ybnkuir.bkt.clouddn.com/vue-hackernews/3-edition/last-edition-resize.gif" width="700px" alt="Last Edition of Vue-HackerNews"><br>    [ Vue-HackerNews 最后版本 ]<br></p>

<h4 id="开发过程-1"><a href="#开发过程-1" class="headerlink" title="开发过程"></a>开发过程</h4><ol>
<li><p><strong>使网页更具 Vue.js 风格</strong><br>打开这个版本（或者看上面的动图），一个最明显的变化就是网页的主色调发生了改变。我将页面中所有的橘黄色（<code>#ff6600</code>）都替换成了浅绿色（<code>#41b883</code>）。主色调是一个网站风格的重要组成部分，比如 HackerNews 的橘黄、知乎的深蓝、github 的墨黑以及 Vue.js 的浅绿。<br>至少从视觉上，我觉得这更加的 Vue.js 了，嘿嘿。</p>
</li>
<li><p><strong>增加根据评论数量、时间以及得分排序功能</strong><br>排序功能在很多网站上都能见到，能够方便大家快速找到自己想找的内容。所以我认为在这个项目上加上这个功能会比较酷（虽然不确定在这个网页上有没有实际意义）。为了增加这个功能，我新增了如下代码（部分）：   </p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line">getters: &#123;</span><br><span class="line">    <span class="comment">// Add this function to getters. This function is uesd</span></span><br><span class="line">    <span class="comment">// to change the order of items in activeItems.</span></span><br><span class="line">    activeItemsSort(state, getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getters.activeItems.sort(<span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> A[m] - B[m]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 除此之外在 <code>ItemList.vue</code> 文件中也增加了一些代码，如果你对此感兴趣的话，那么可以把源文件看一下，也挺简单的。 样式上的改动也挺大的，感兴趣也可以去了解下。</p>
</li>
<li><p><strong>保持在不同设备上的自适应</strong><br>为了能和上一个版本一样，仍然能够自适应各种尺寸的设备，我在改变页面布局之后，对相关 CSS 样式进行了设置。从上面的动图可以看到，为了配合排序，主页面的布局发生的变化还是挺大了。在自适应设备的时候，为了使页面看起来更优雅一些，我将部分不太重要的信息给省略了。具体的设置可以看源文件。  </p>
</li>
</ol>
<ol start="4">
<li><strong>在 <code>ItemView.vue</code> 页面增加 <code>toTop</code> 按钮</strong><br>返回顶部按钮也是很多网站的常见功能。由于首页只有20条信息，所以在首页上我没有加上这个。但是在评论页面，动辄上百条，我认为加上这个按钮应该会方便一些。反正都是根据我自己的喜好来加的，有没有实际意义我也不知道，哈哈。</li>
</ol>
<h4 id="章节结尾"><a href="#章节结尾" class="headerlink" title="章节结尾"></a>章节结尾</h4><p>到目前为止，这个项目的所有版本都已经完成了。在完成这些版本的过程中，我感受到了思考和创造带来的乐趣。这就是生活啊，希望大家也能感受到。<br>最后，衷心感谢原作者 <a href="https://github.com/yyx990803" target="_blank" rel="noopener">尤雨溪前辈</a> 给我们提供了一个这么好用的框架以及这么精彩的官方示例！</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>从开始接触这个项目到现在已经过去好几个月了，一直想通过学习这个项目来巩固 Vue.js 的知识点，但很长一段时间都没有什么收获。因为知识储备不够，很多内容都看不懂。碰壁碰多了就知道转弯。然后去学习 ES6 以及 Node.js 相关知识，再来看的时候，很多地方就豁然开朗了。在这之后，对这个项目的理解速度就远超过之前了。    </p>
<p>一天晚上睡不着，就思考着这种情况对于前端新手应该是挺常见的，我为什么不把自己的经验教训分享出来给大家？然后就有了这个项目。<br>项目实现的过程遇到各种困难，特别是第一个版本和第三个版本。第一个版本所遇到的关键点在上面已经说过了，不断的阅读各种文档然后尝试，最后终于在 Chrome 中跑了起来。挫败感是常态，成就感是偶尔才有的。第三个版本是官方完整版，自认为直到现在对其的理解程度都只有十之七八。但也暂时不纠结了，没有工作经验，很多在工程中需要考虑的因素对我而言还比较捉摸不透。很多问题在经验丰富的开发者来看是一种常识，但对于新手而言却会感到无比的困惑。“书读百遍，其义自见” 就是这个意思吧。  </p>
<p>现在项目完成了，再来回顾整个项目，有点感慨。最开始对这个项目的想法是从简到繁一步一步和大家一起重建这个项目，整个过程会非常详细。现在项目完成了，由于精力和知识层次的限制，却并没有完全达到这种效果，还是有点遗憾。不过除此之外，项目覆盖的还是比较全面的。<br>最后，希望看过我这个教程的小伙伴能够有所收获；如果有小伙伴或者前辈发现文中出现错误，也请不吝赐教，先谢谢大家了。</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客构建笔记(更新：增加排序功能)]]></title>
      <url>http://detachment.club/2016/12/28/%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;记录总结学习过程的重要性不言自明。博客正好就是这一过程的体现平台，所以构建并完善这个平台就显得尤为重要了。由于周期性的懒癌发作，所以可惜的是构建此博客的前期并未记录下来，这两天因为开始写年终总结了，所以连续为博客增加了两项功能，至此我认为应该记录一下。</p>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一直都知道很多博客有订阅 rss 的功能，但是从来没有使用过，所以前期构建的时候并没有将这个功能作为博客的核心功能。直到邮件订阅了一些网站之后，只要有更新就会自动推送邮件，并且在邮件中就能看到更新的内容。这才感受到这个功能的便捷性，然后决定我也要给我的博客增加这个功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;经过一番探索，经过以下步骤可以实现 rss 及邮件订阅的功能：</p>
<ol>
<li>利用 npm 下载安装 hexo-generator-feed 插件，命令如下：<br><code>$ npm install --save hexo-generator-feed</code></li>
<li><p>在主题配置文件 <code>_config.yml</code> 中增加以下内容：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#Feed configuration</span></span><br><span class="line"><span class="symbol">plugin:</span></span><br><span class="line">- hexo-generator-feed</span><br><span class="line"></span><br><span class="line"><span class="symbol">feed:</span></span><br><span class="line"><span class="symbol">  type:</span> atom      <span class="comment">// Feed type. (atom/rss2)</span></span><br><span class="line"><span class="symbol">  path:</span> atom.xml  <span class="comment">// Feed path. (Default: atom.xml/rss2.xml)</span></span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">20</span>       <span class="comment">// Maximum number of posts in the feed.</span></span><br><span class="line"><span class="symbol">  hub:</span>            <span class="comment">// URL of the PubSubHubbub hubs (Leave it empty if you don't use it)</span></span><br><span class="line"><span class="symbol">  content:</span> true   <span class="comment">// (optional) set to 'true' to include the contents of the entire post in the feed.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在主题配置文件 <code>_config.yml</code> 中设置 rss 项：<br><code>rss: &quot;/atom.xml&quot;</code></p>
</li>
<li>至此，更新部署博客就能看到有 rss 订阅功能了，需要邮件订阅功能则需要从下面一步开始；</li>
<li>利用 feedbuner 来制作一个feed（如果没有账号可以注册一个或者用谷歌账号登录）：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner1.JPG" alt="第一张图"></li>
<li>在上图中填入你的博客订阅地址，如下所示：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner2.JPG" alt="第二张图"></li>
<li>之后直接点击 next 就成功制作了一个feed：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner3.JPG" alt="第三张图"></li>
<li>制作完之后在种子信息面板开启邮件订阅的功能：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/feedbuner4.JPG" alt="第四张图"></li>
<li>至此，你已经得到了两种形式的代码了，根据自己的需要使用到自己的网站上，我使用的是超链接的形式。</li>
<li>时光荏苒，岁月如梭，一年的时间又飞快的离我们而去。与去年情况不同的是，在引入两个强而有力的产品同事后，今年的工作变得更加复杂和具有挑战性了。为了有条理的总结今年这一年的工作情况，下面就按时间顺序一一道来。</li>
</ol>
<hr>
<h3 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这也是一个一直想要的功能，因为很有可能有些博客的重要性比其他的更高，但是由于默认按照时间来排序导致翻页之后才能看到这些文章。正好这两天在捣鼓博客，索性将这个功能也做出来。最开始的时候准备将博客的源码文件捋清楚后自己修改代码，但是打开hexo文件夹一看，打了个哆嗦就把文件夹关了：我是不是傻，为啥不先去搜索一番？<br>&nbsp;&nbsp;&nbsp;&nbsp;果然，一搜就发现有很多人多有这个需求: <a href="https://github.com/iissnan/hexo-theme-next/issues/415" target="_blank" rel="noopener">如何置顶post？</a>。整个帖子看下来的结论是：各种尝试的结果都或多或少有bug，所以此暂时暂时搁置，日后再来开发。不过里面倒是有个链接指出了通用配置方法，这也是目前我所采用的方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">原文写的比较详细</a>，我也就不再多费口舌了，总的来说就是更改排序规则，并将新的变量（top）增加到post的开头部分。经测试，效果不错。</p>
<hr>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于某些涉及隐私，或者只希望分享给有限人群的博客，加密功能就非常实用了。之前一直没有将这个功能加上来，因为需求没这么迫切。最近准备开始投简历，里面会涉及一些个人信息，但是又希望公司能够通过博客的形式看到简历，这个功能就必不可少了。通过搜索，找到这个一个帖子，基本能满足需求：  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://edolphin.site/2016/05/31/encrypt-post/" target="_blank" rel="noopener">加密博客内容，使用密码访问</a>  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;仔细看了一下这篇博客及对应项目的 GitHub 文档，满足基本需求不成问题，但是有两点不足：第一，官方文档写的不是太好，有些地方不好理解；第二，对于基于 GitHub page 的博客基本无效。然后在 GitHub 上顺藤摸瓜，找出了下面这个项目：   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">hexo-blog-encrypt</a>    </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;文档清晰易懂，开发者响应迅速，最重要的是能够完整加密。如果非要提不足的地方，那就是解密后目录栏不会自动更新。和开发者沟通过，这个需要根据不同的 Hexo 主题进行对应的更改，经过一番尝试后测试失败。由于时间问题，暂时我就不去管它了。<br>&nbsp;&nbsp;&nbsp;&nbsp;所以，如果你也需要为博客设置密码，推荐第二种方式。<br>&nbsp;&nbsp;&nbsp;&nbsp;非常感谢两位开发者做出的探索。</p>
<hr>
<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><pre><code>换电脑后写博客没有以前那么方便了，加上懒癌晚期，一直拖着没有把以前电脑上的资源迁移过来，所以大半年都没有写博客了。昨天晚上不知道哪根筋搭错了，终于决定将很久都没有做的事情完成下。
看了几篇博客，有些挺难理解的，一步一步尝试做下来总会失败。可能是没有理解其中缘由，也可能是时过境迁，以前的方法不再适用。最终成功的方法来自知乎用户@[skycrown](https://www.zhihu.com/people/skycrown)：[使用hexo，如果换了电脑怎么更新博客？](https://www.zhihu.com/question/21193762)
</code></pre><blockquote>
<p>不知道题主是不是换了新电脑，需要在新电脑上进行部署，如果是，可以参考下面的方法：<br>1、从官网<a href="https://link.zhihu.com/?target=https%3A//git-scm.com/" target="_blank" rel="noopener">Git**</a>下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：<br>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ 把其中的邮件地址换成自己的邮件地址，然后一路回车<br>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。<br>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。<br><strong>注意</strong>：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。<br>2、下载<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/" target="_blank" rel="noopener">Node.js**</a>，并安装<br>3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo<br>4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。<br>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。<strong>总结：</strong>_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。<br>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。<strong>总结：</strong>.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。<br>5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。<br>6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：<br>（1）为了使用hexo d来部署到git上，需要安装<br>npm install hexo-deployer-git –save<br>（2）为了建立RSS订阅，需要安装<br>npm install hexo-generator-feed –save<br>（3）为了建立站点地图，需要安装<br>npm install hexo-generator-sitemap –save<br>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明<br>7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！</p>
</blockquote>
<hr>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code>之前已经写过了置顶的功能，逻辑是如果 post 中有 top 字段，那么先比较 top 字段值的大小，然后根据发布时间来进行排序。但是有些文章是在不断修改的，所以我认为按照修改时间来排序是一种更好的策略。对于从来不修改的文章而言，发布时间和更新时间一致，所以都可以满足。
因为 Next 默认主题是不显示修改时间的，所以如果需要按照修改时间排序，首先得显示修改时间，这个需求可以在这个问题下找到答案：[如何将首页和归档页的博文按照更新时间排序？](https://github.com/iissnan/hexo-theme-next/issues/1895) 在将修改时间添加到配置文件之后，每篇博客开始的时候就需要将 updated 字段加进去，这块有个坑：**date 和 updated 的值不能一样，否则不会显示。**
修改的策略其实和置顶一致，只需要把 `node_modules/hexo-generator-index/lib/generator.js` 中以下部分的 date 改成 update 就行：
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码引用自： <a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决Hexo置顶问题</a></p>
</blockquote>
<hr>
<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><p>略</p>
<h3 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h3><p>略</p>
<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>最近又收到七牛云的邮件了，说是之前的测试域名马上就要到期了，到期后会收回。为了避免到时候所有的图片都看不到，开始准备把图片迁移，有两种方案，其一：绑定自己的域名；其二，找其他图床。本来想着绑定就绑定吧，也没啥影响，然后发现绑定之前必须要备案才行，也就是说你所有的实名信息都需要提交到工信部，这我就不开心了。虽说也不准备做什么违法乱纪的事情，但总是不想处于这种监管的状态的。所以开始找第二种方案。然后发现了 sm.ms 图床，有很好的 api 支持，找到一篇文章有相关记录，里面很详细的记录了整个配置的过程：<a href="https://spencerwoo.com/2018/01/28/SM-MS/" target="_blank" rel="noopener">SM.MS: 一名优秀的图床的艺术之旅。</a></p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 置顶 </tag>
            
            <tag> 订阅 </tag>
            
            <tag> 加密 </tag>
            
            <tag> 迁移 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 版权 </tag>
            
            <tag> 打赏 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写在2016年的尾巴]]></title>
      <url>http://detachment.club/2016/12/27/%E5%86%99%E5%9C%A82016%E5%B9%B4%E7%9A%84%E5%B0%BE%E5%B7%B4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一年的时间过得太快，但足以发生很多很多的事情，这也造成了提笔难言的窘境。如果要叙述一个复杂的故事，最简单的办法就是利用时间作为线索，采用顺序的叙述结构。这种结构同样非常适合年终总结。</p>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在前言中，我就简单的以时间为线来简单的流水一遍我这一年：</p>
<ul>
<li>1-3月：设计制作最后三套轮胎自动搬运设备，3月底辞职；</li>
<li>4-5月：在w3school上学习html，css，JavaScript的相关知识；重新使用github；</li>
<li>6-7月：利用视频教程学习JavaScript；搭建博客并将整个学习过程总结到博客上；</li>
<li>8-9月：学习jQuery，BootStrap并利用所学模仿制作了简历；开始投简历、面试、得到offer并放弃；学习《JavaScript编程精解》；初步接触vue.js；</li>
<li>10月：学习vue.js及相关工具（router、vuex、loader）；学习webpack的使用；学习git；投简历被拒；</li>
<li>11月：学习《JavaScript高级程序设计》；尝试利用vue.js制作完整项目遇阻；</li>
<li>12月：重新学习vue.js并准备做完整的项目，遇阻；学习ES6语法；利用xmind总结vue.js；年终总结。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面所提到的虽不全面，但也大体覆盖了这近一年所做的主要努力。下面的正文还将从各个方面来进行总结，从另一个角度来更加全面的回顾这一年所发生的的事情。</p>
<hr>
<script src="https://use.fontawesome.com/e4cb940bf3.js"></script>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;下面将从这两个方面来总结：学习工作与生活娱乐。</p>
<h3 id="学习工作"><a href="#学习工作" class="headerlink" title="学习工作"></a>学习工作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前端学习的内容无外乎语言本身（HTML，CSS 及 JavaScript）的学习及辅助工具应用方面（框架、模块化工具等）的学习，那么就从这两方面来说说目前的情况吧。</p>
<ul>
<li><strong>语言本身</strong><ol>
<li><strong>HTML</strong>：主要从w3s上学习，项目中碰到问题靠搜索解决。对于 HTML5 中新加入的新特征了解但没达到熟悉的程度；   </li>
<li><strong>CSS</strong>：主要从w3s上学习，了解在 CSS3 中新加入的特征但实践不够；</li>
<li><strong>JavaScript</strong>：<ul>
<li><strong>前期</strong>：w3s上学习了一阵子，摸不着头脑。转而到网易云课堂学习了《精通JavaScript开发》，当时自觉已经大概了解了这门语言，现在看来还是 too young，too simple。之后在准备面试的时候看到各种 JavaScript 方面的考题都不会做，然后又开始在网上找资源来学习知识，这时候找到《JavaScript秘密花园》以及汤姆大叔的JS总结博客，如获至宝。又一次 be naive。总结是个升华的过程，而学习基础知识则是升温过程。其实当时也懂得这个道理，只是在希望能尽快找到工作的心态影响下变得浮躁。</li>
<li><strong>中期</strong>：开始看书，第一本看的是 《JavaScript 编程精解》。书如其名，处处体现一个精字，导致看完一遍之后和朋友切磋的时候被暴虐。因为本书中对很多基础性的概念并没有做出详尽的介绍，所以我看了一遍之后对这些都是一知半解。但不可否认的是，这本书里面的编程技巧让我大开眼界。总而言之：新手不推荐这本书。看的第二本书是《JavaScript高级程序设计》，它为我打开了新世界的大门。这本书深入浅出的为初学者介绍了所需要了解的绝大部分关于 JavaScript 的知识点，看完后我受益匪浅，值得反复阅读、总结。在学 vue.js 做项目的时候发现有大量的 ES6 新增的特性在发挥作用，所以后期也学习了 ES6 规范。学习 ES6 的途径是阮一峰老师的博客。总体而言，对于我这种水平的新手来说，教程难度适中，看过一遍之后能够理解大概80%左右的知识点。所以，对于希望能初步掌握 ES6 规范的学习者来说，我还是很推荐这份教程的。</li>
<li><strong>后期</strong>：JS 语言的学习将在很长一段时间处于中期阶段，因为很多知识点都需要通过在实践中慢慢的掌握，而这也是目前我所严重欠缺的方面。虽然此阶段的到来还很遥远，不过总体方针还是有的：关注了解与前端相关的知识如服务器端（node.js）以及网络协议等；关心语言的发展趋势，如果可能的话，甚至去影响趋势。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>框架工具学习</strong></p>
<ol>
<li><strong>jQuery</strong>：主要通过 w3s 来学习，掌握基本用法，未深究；</li>
<li><strong>BootStrap</strong>：通过视频及官方文档来学习。有独立项目，其中个人简历即在此阶段完成的；</li>
<li><p><strong>Vue.js</strong>：仔细看过几遍官方文档并有总结，对基本用法了熟于心。同时也了解关于 Vue.js 的一些辅助插件，如 vuex、vue-router 以及 vue-loader。在很快的一段时间内将会利用这些来完成一个复杂程度较高的完整前端项目。附简单的总结图如下（利用 xMind 制作，如有需要源文件的可以给我发邮件）：<br><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/vuex.png" alt="vue.js"></p>
<p><img src="http://o9ybnkuir.bkt.clouddn.com/imgs/Vue.png" alt="vue.js"></p>
</li>
<li><strong>webpack</strong>：完整的看了一遍文档，并翻译发布了一篇博客，有过少许实践经验。在这个过程中接触到 npm，yarn，gitbook等等；</li>
<li><strong>git</strong>：熟练使用 git 的基本操作，写过一篇相关博客。</li>
<li><strong>其他</strong>：了解（基本能看懂代码） bower、gulp、sass、karma、eslint 等，但都没有实践经验。这也是之后需要加强的方面。</li>
</ol>
</li>
</ul>
<ul>
<li><strong>博客写作</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;自从6月份开通到现在为止，一共发布了10篇博客，除了两篇为翻译文档，其余全为原创。有一篇访问量超过2500pv，对自己来说也是一个鼓励。以此同时，有多位朋友看过博客后通过邮件和我联系并给于肯定，在此对他们表示感谢，也希望大家在前端学习的路上大家都能越走越远。下面附上一些简单的博客流量图：<br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji1.JPG" alt="tongji"><br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji2.JPG" alt="tongji"><br>  <img src="http://o9ybnkuir.bkt.clouddn.com/imgs/tongji3.JPG" alt="tongji"></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;至此，学习工作方面的内容基本上也已经总结的差不多了，接下来继续总结生活娱乐方面。</p>
<h3 id="生活娱乐"><a href="#生活娱乐" class="headerlink" title="生活娱乐"></a>生活娱乐</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;All work and no play makes Jack a dull boy. 从以下两个方面来总结吧：精神建设以及生活质量。</p>
<ul>
<li><p><strong>精神建设</strong></p>
<ol>
<li><p><strong>电影</strong>：看电影是一个终生爱好，可能和小时候的经历有关。按照时间顺序简单的总结下今年看过的影片（包括电影和剧集，数据来自豆瓣记录以及下载记录），根据个人喜好推荐加粗部分的电影：</p>
<ul>
<li>一月份： <strong>《老炮儿》</strong>《黑金》《我的少女时代》《机械姬》<strong>《走到尽头》</strong>《为了N》（剧集）;</li>
<li>二月份：<strong>《守望者》</strong>《美国狙击手》《史蒂夫·乔布斯》<strong>《夜行者》</strong>《暗杀》<strong>《视觉》</strong>；</li>
<li>三月份：《八恶人》《饥饿游戏3：嘲笑鸟》<strong>《聚焦》</strong> <strong>《荒野猎人》</strong>《蝙蝠侠大战超人：正义黎明》<strong>《控方证人》</strong>《功夫熊猫3》；</li>
<li>四月份：<strong>《纸牌屋 第四季》</strong>；</li>
<li>五月份：<strong>《危楼愚夫》《成长系列》《盗梦空间》</strong>，其中<a href="https://movie.douban.com/subject/10748226/" target="_blank" rel="noopener">《成长系列》</a>极力推荐；</li>
<li>六月份：无记录。（可能在 B 站上有看，但是记录不可查）；</li>
<li>七月份：《危机13小时》《奇幻森林》《人间世》《知无涯者》《行尸走肉》；</li>
<li>八月份：<strong>《一个叫欧维的男人决定去死》</strong>《红眼航班》<strong>《云图》</strong>；</li>
<li>九月份：《惊天盗魔团》《寒战2》<strong>《黑客军团2》《心迷宫》</strong>《你眼中的世界》<strong>《杀死一只知更鸟》《阿凡达》</strong>；</li>
<li>十月份：<strong>《荒野生存》</strong>《黑镜3》《西部世界》《冰血暴2》《毕业生》<strong>《追梦赤子心》</strong></li>
<li>十一月份：<strong>《我们这一天》</strong>《斯诺登》<strong>《头脑特工队》</strong>《逃避虽可耻但有用》<strong>《七武士》《双峰 第一季》</strong>《双峰 第二季》</li>
<li>十二月份：<strong>《行星地球2》</strong>《萨利机长》<strong>《梦之安魂曲》《驴得水》《疯狂的麦克斯4》</strong>《豪勇七蛟龙》<strong>《夜班经理》</strong></li>
</ul>
<blockquote>
<p>由于有部分电影在 B 站上看的，导致没有任何记录，所以可能有 10%-20% 左右的电影没有归纳出来。</p>
</blockquote>
</li>
<li><p><strong>书籍</strong>：除了专业书籍之外，还看了一些其他方面的书，以下大概按照时间来排序：</p>
<ul>
<li><p><strong>《无声告白》</strong>：这是一本关于家庭教育的书，我认为每个身为人父（母）的人都应该看一看这本书。文章中的心理描写非常精彩，比如下面这一段：</p>
<blockquote>
<p>多年来对爱的渴望让她变得敏感，她就像一条饥饿的狗，不停的翕动鼻孔，捕捉着哪怕是最微弱的食物的香气。她不会弄错的。她一看到就认出了它。那是爱，是一厢情愿的深切渴慕，只有付出，得不到回报；是小心翼翼而安静的爱恋，却无所畏惧，无论如何，都会执着的进行下去。  </p>
</blockquote>
</li>
<li><p><strong>《黑客与画家》</strong>：讨论了很多关于计算机以及互联网行业的问题，比如编程语言发展趋势。对我影响不大，看完之后很多内容多忘记了。摘取一段作者对于怎么致富的方法的看法：</p>
<blockquote>
<p>要致富，你需要有两样东西：可测量性和可放大性。你的职位产生的业绩，应该是可测量的，否则你做的再多，也不会得到更多的报酬。此外，你还必须有可放大性，也就是说你做的决定能够产生巨大的效应。</p>
</blockquote>
</li>
<li><p><strong>《月亮与六便士》</strong>：什么是信仰？什么又是真正的幸福？</p>
<blockquote>
<p>难道做自己最想做的事，生活在让你感到舒服的环境里，让你的内心得到安宁是糟践自己吗？难道成为年入上万英镑的外科医生、娶得如花美眷就算是成功吗？我想这取决于你如何看待生活的意义，取决于你认为你应该对社会做出什么贡献，应该对自己有什么要求。</p>
</blockquote>
</li>
<li><p><strong>《自控力》</strong>：这本书通过一系列的实验给我们展示了关于自控力种种方面的研究成果。对于有严重拖延症的人来说，值得一看。摘抄部分结论：</p>
<blockquote>
<p>人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学习数学，他就会越来越擅长数学。如果你让他忧虑，他就会越来越忧虑。如果你让他专注，他就会越来越专注。</p>
</blockquote>
</li>
<li><p><strong>《三体全集》</strong>：佩服作者的想象力和知识面，不过不符合个人口味，看了40%左右，弃坑。摘录部分笔记：</p>
<blockquote>
<p>也许，人类和邪恶的关系，就是大洋与漂浮于其上的冰山的关系，它们其实是同一物质组成的巨大水体。冰山之所以被醒目的认出来，只是由于其形态不同而已，而它实质上只不过是这整个巨大水体中较小的一部分……人类真正的道德自觉是不可能的，就像他们不可能自己把着自己的头发离开大陆。</p>
</blockquote>
</li>
<li><p><strong>《一个人的朝圣》</strong>：我只是想安安静静的去拜访个老朋友而已，你们这帮记者除了弄个大新闻还会啥？</p>
<blockquote>
<p>他发现正是这些普通人的渺小与孤独使他诧异，牵动他内心的温柔。在这个世界上有多少人每天做的事就是不断将一只脚放到另一只脚前面，日子久了，生活便显得平淡无奇。哈罗德无法再否认其实一路上见过的每个陌生人虽然是独特的，却又是一样的，这就是人生的两难。</p>
</blockquote>
</li>
<li><p><strong>《阿城精选集》</strong>：阿城先生的《棋王》《树王》以及《孩子王》都写的非常精彩，其中又以《棋王》最为精彩：</p>
<blockquote>
<p>王一生孤身一人坐在大屋子中央，瞪眼看着我们，双手支在膝盖上，铁铸一个细树桩，似无所见，似无所闻。高高的一盏电灯，暗暗地照在他脸上，眼睛深陷进去，黑黑的似俯视大千世界，茫茫宇宙。那生命像聚在一头乱发中，久久不散，又慢慢弥散开来，灼的人脸热。</p>
</blockquote>
</li>
<li><p><strong>《人类简史》</strong>：跳出人类的设定来看人类的发展。不同心态的人看完会有不同的结论，在这个思考的过程会刷新自己的认知。于我而言，这本书让我看问题多了一个角度：上帝视角。摘取《奢侈生活的骗局》中的一段：</p>
<blockquote>
<p>有多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背负着巨额贷款，要支付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且生活里面不能没有高级红酒和国外假期。他们该怎么做？他们会放下一切，回去野外挖树根？当然不可能，而是加倍努力，继续把自己累的半死。</p>
</blockquote>
</li>
<li><p><strong>《杀死一只知更鸟》</strong>：先看的书，再看的电影，足见我很喜欢这部作品。从种族歧视的角度探讨何为正义的作品不少，但这本书有着其独特的味道，比如书中的家庭教育。如果我有一个女儿，那么我希望她能够像斯考特一样纯真、勇敢而又具有独立而思辨的灵魂。</p>
<blockquote>
<p>勇敢是：当你还未开始就已知道自己会输，可你依然要去做，而且无论如何你都要把它坚持到底。你很少能赢，但有时也会。</p>
</blockquote>
</li>
<li><p><strong>《沉默的大多数》</strong>：这是一本王小波的杂文集，讨论的范围非常广，阅读的过程中能感受到一种思辨的快乐。这本书对我最大的影响是它让我相信一个有智慧的实诚人是可爱的。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恕我直言，能够带来思想快乐的东西，只能是人类智慧至高的产物。比这再低一级的东西，只会给人带来痛苦；而这种低档货，就是出于功利的种种想法。  –《思维的乐趣  第二章》<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我现在当然有自己的善恶标准，而且我现在并不比别人表现的坏。我认为低智、偏执、思想贫乏是最大的邪恶。按照这个标准，别人说我最善良，就是我最邪恶时；别人说我最邪恶时，就是我最善良时。当然，我不想把这个标准推荐给别人，但我认为，聪明、达观、多知的人，比之别样的人更堪信任。  –《思维的乐趣 第四章》<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果说贫穷是种生活方式，捡垃圾和挑大粪只是这种方式的契机。生活方式像是一个曲折漫长的故事，或者使人迷失的迷宫。很不幸的是，任何一种负面的生活都能产生很多乱七八糟的细节，使得他变得有趣；人就在这种趣味中沉沦下去，从根本上忘记了这种生活需要改进。用文化人类学的观点来看，这些细节加在一起，就叫做“文化”。  –《有关贫穷》</p>
</blockquote>
</li>
</ul>
<p>上面这些书都是看完了的，现在正在看小波的《黄金时代》、张纯如的《南京大屠杀》，已经购买计划要看的有《情人》《菊与刀》《江村经济》《唐吉坷德》等等。</p>
</li>
</ol>
</li>
<li><p><strong>生活质量</strong></p>
<ul>
<li><strong>做饭水平</strong>：经过一年的锻炼，做饭经验丰富；</li>
<li><strong>健身进展</strong>：对比去年，背阔肌和三头肌有明显进步；最近也加强了对大腿、肩部的锻炼，目前效果不明显；俄式挺身还是没有学会，核心力量太弱；训练的不够系统，整体进步趋于平缓；</li>
<li><strong>摄影水平</strong>：原地踏步；</li>
<li><strong>游戏水平</strong>：效率上涨100点，但是浪费太多时间和精力，已决定afk。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;2016年还有两天就过完了。这一年，我彻底的改变了自己的职业发展方向，一切从头开始。这一年，虽然过得还不够充实，但每一天都是按照自己的意愿来生活。这一年，胜过了很多年。<br>&nbsp;&nbsp;&nbsp;&nbsp;2017年希望自己和周围的人身体都健健康康。除此之外，也希望自己能够找到一份适合自己的工作，实现自己的价值。<br>&nbsp;&nbsp;&nbsp;&nbsp;最后套用一句小波的话来结束整篇文章：虽然人生在世会有种种不如意，但你仍可以在幸福与不幸中做出选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;新年快乐~</p>
]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Vue.js </tag>
            
            <tag> ES6 </tag>
            
            <tag> 2016 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[怎样利用 git 撤销操作]]></title>
      <url>http://detachment.club/2016/10/29/%E6%80%8E%E6%A0%B7%E5%88%A9%E7%94%A8%20git%20%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于版本管理系统而言，最重要的一个特性之一就是能够撤销错误的操作。在 git 中，撤销有很多种可能的意思。<br>&nbsp;&nbsp;&nbsp;&nbsp;每当你做出一个 提交 的时候，git 都会立即在你的 repository 保存一个快照，之后你就可以通过 git 来恢复到这个项目的前一个版本了。<br>&nbsp;&nbsp;&nbsp;&nbsp;这下面这篇文章中，我将会就几种常见的情景来讨论怎样通过 git 来完美的撤销这些操作。</p>
<a id="more"></a>
<h2 id="不同情况"><a href="#不同情况" class="headerlink" title="不同情况"></a>不同情况</h2><h3 id="撤销已发布"><a href="#撤销已发布" class="headerlink" title="撤销已发布"></a>撤销已发布</h3><p><strong>情景</strong>：你刚按下 <code>git push</code> ，将修改推送到了 github ，然后就发现在你的提交中存在一些问题。这时候那就会想撤销操作。</p>
<p><strong>解决</strong>： <code>git revert &lt;SHA&gt;</code></p>
<p><strong>原理</strong>： <code>git revert &lt;SHA&gt;</code> 这个操作会生成一个新的 commit，这个提交和 提供的 SHA 是相反的：如果之前的提交是 “matter”，那么这个提交就是 “anti-matter”，也就是说之前操作中新增的内容将会被删除，之前操作中被删除的内容也将会被增加。</p>
<p>这是 git 中最基础也最安全的撤销操作情景，因为它不会 <em>改动</em> 变更历史——你可以放心的使用 <code>git push</code> “相反的”提交来撤销你错误的操作。</p>
<hr>
<h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><p><strong>情景</strong>：你把提交信息的最后一个字打完：<code>git commit -m &quot;Fxies bug #42</code>，提交之后推送之前，你发现你的提交信息出错了，应该是：<code>Fixes bug #42</code>。这时候你也会想到撤销操作。</p>
<p><strong>解决</strong>：<code>git commit --amend or git commit --amend -m &quot;Fixes bug #42&quot;</code></p>
<p><strong>原理</strong>：<code>git commit --amend</code> 操作会用一个新的提交来更新、替换上一个提交。如果新提交的内容中有已处于可提交状态的修改，那么也会一并提交；如果没有，那么只需要重写上一次的提交信息即可。</p>
<hr>
<h3 id="撤销本地操作"><a href="#撤销本地操作" class="headerlink" title="撤销本地操作"></a>撤销本地操作</h3><p><strong>情景</strong>：一只喵从键盘上走过，不小心保存了修改，然后很巧的是 IDE 此时崩溃退出了。这时候你还没有提交，你希望能够将这个文件中所有的修改都撤销——直到恢复成上一次提交的状态。</p>
<p><strong>解决</strong>：<code>git checkout -- &lt;bad filename&gt;</code></p>
<p><strong>原理</strong>：<code>git checkout</code> 指令会将工作文件夹中的这个文件恢复成在 Git 中上一次保存的状态。你可以提供一个确切的分支名，或者是需要恢复到的 SHA。如果都省略，Git 就默认是恢复到 HEAD ——也就是目前分支的上一次提交状态。</p>
<p><strong>注意</strong>：利用这种方法所做的任何撤销都是真的撤销了。因为没有提交操作，所以 Git 之后也没办法来恢复了。用这种方法的时候一定要确定你所需要撤销的到底是什么！（你可以利用 <code>git diff</code> 来确认提交信息）</p>
<hr>
<h3 id="重置本地操作"><a href="#重置本地操作" class="headerlink" title="重置本地操作"></a>重置本地操作</h3><p><strong>情景</strong>：你在本地提交过几次（但还没有推送），然后你发现这些都是垃圾，然后你想撤销最近三次的提交——就好像它们从来没发生过一样。</p>
<p><strong>解决</strong>：<code>git reset &lt;last good SHA&gt; or git reset --hard &lt;last good SHA&gt;</code></p>
<p><strong>原理</strong>：<code>git reset</code> 操作会让你的项目历史记录回滚到指定的 SHA，就像这些提交从来没有发生过一样。默认状态下，这个操作会将工作目录保存下来，这时候提交虽然没有了，但是这些提交的内容还是存在硬盘上的。这是最安全的做法，但是很多时候，你需要同时撤销提交并同时删除这些文件——这时候就需要加上 <code>--hard</code> 了。</p>
<hr>
<h3 id="重置本地操作后恢复"><a href="#重置本地操作后恢复" class="headerlink" title="重置本地操作后恢复"></a>重置本地操作后恢复</h3><p><strong>情景</strong>：你已经提交了一些修改，然后发现不对，就利用上面的方法撤销了提交。这时候你又发现：我要撤销刚刚的撤销！</p>
<p><strong>解决</strong>：<code>git reflog and git reset or git checkout</code></p>
<p><strong>原理</strong>：<code>git reflog</code> 是一种非常好的用于恢复项目历史记录的办法。通过这个办法，几乎可以恢复任何已经提交过的修改。</p>
<p>你可能对用于显示不同提交的 <code>git log</code> 指令比较熟悉，而 <code>git reflog</code> 也是类似的，区别在于，它显示的是 <code>HEAD</code> 的修改情况列表。</p>
<p>注意点：</p>
<ul>
<li>只有 .HEAD 文件被修改时 HEAD 才会修改，这些情况包括：切换分支、通过 <code>git commit</code> 提交、通过 <code>git-reset</code> 恢复。需要注意的是通过 <code>git checkout --&lt;bad filename&gt;</code> 操作并不会修改 HEAD（上面的方法中提到过这个操作不会被提交），所以 reflog 方法这时候不适用。</li>
<li><code>git reflog</code> 不会被永久保存。Git 内部每隔一段时间就好清理一些无法识别的对象。所以不要指望几个月前的提交记录能够永远在 reflog 中找到。</li>
<li>你的 <code>reflog</code> 仅仅只能你自己使用。你无法通过这个指令来恢复其他开发者尚未推送的提交。</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png" alt></p>
<p>那么，回到正题，怎样通过 <code>git reflog</code> 来达到撤销已撤销的目的呢？这还得根据不同的情况讨论：</p>
<ul>
<li>如果你想将项目历史恢复成特定时候的状态，使用 <code>get reset -hard &lt;SHA&gt;</code></li>
<li>如果你想在你的工作目录下重新创造一些和之前一样的文件，同时不更改项目记录，那么就用 <code>git checkout &lt;SHA&gt; --&lt;filename&gt;</code></li>
<li>如果你想重新提交一个确切的操作到你的项目，那就是用 <code>git cherry-pick &lt;SHA&gt;</code></li>
</ul>
<hr>
<h3 id="修改合并分支"><a href="#修改合并分支" class="headerlink" title="修改合并分支"></a>修改合并分支</h3><p><strong>情景</strong>：你提交了一些修改，然后发现提交到了 master 分支，而你本来是想提交到一个叫做 feature 的分支上。</p>
<p><strong>解决</strong>：<code>git branch feature, git reset --hard origin/master, and git checkout feature</code></p>
<p><strong>原理</strong>：你可能比较习惯使用 <code>git checkout -b &lt;name&gt;</code> 来建立并切换到新建立的分支上——然而，有时候你并不希望立刻切换到新建立的分支。通过 <code>git branck feature</code> 创建了一个叫做 feature 的分支，这也是你将要合并提交的分支，而且这样操作，目前所在的分支还在 master 上（并没有切换到 feature）。<br>然后，通过 <code>git reset --hard</code> 将 master 分支回滚到之前 origi/master 未提交的状态。不过不要担心，在 feature 分支上，这些提交还是有的。<br>最后，通过 <code>git checkout</code> 指令将分支切换至 feature，然后你就可以开心的进行提交了。</p>
<hr>
<h3 id="同步更新分支"><a href="#同步更新分支" class="headerlink" title="同步更新分支"></a>同步更新分支</h3><p><strong>情景</strong>：你在本地分支 master 的基础上新建了一个叫做 feature 的分支，但是这时候的本地分支 master 比远程主机上的 origin/master 分支落后几个版本。然后你将本地 master 分支同步至 origin/master，然后你希望这时候提交到 feature 分支上的修改能够在现在这个状态的基础上，而不是之前落后几个版本的状态。</p>
<p><strong>解决</strong>：<code>git checkout feature and git rebase master</code></p>
<p><strong>原理</strong>：你本来可以这样做：首先利用 <code>git reset</code>（后面故意不加 –hard，这样的话 master 虽然回滚到上个版本但是硬盘上这些可提交的修改并没有删除），然后通过 <code>git checkout &lt;branch name&gt;</code> 切换至 feature 分支，最后在这个分支上重新提交（以达到和之前 master 分支一样的状态）。通过这种办法可以达到目的，但是你会失去提交历史。下面有一个更好的方法。</p>
<p><code>get rebase master</code> 操作会执行很多事情：</p>
<ul>
<li>首先在目前所在分支和本地 master 分支之间确定谁是谁的父级；</li>
<li>然后将目前所在分支的状态重置成父级的状态，并把之后的提交都暂时保存在一个区域；</li>
<li>最后更新升级到和 master 分支最新状态一样，然后重新操作暂时保存区域的提交。</li>
</ul>
<hr>
<h3 id="大量的撤销-恢复操作"><a href="#大量的撤销-恢复操作" class="headerlink" title="大量的撤销/恢复操作"></a>大量的撤销/恢复操作</h3><p><strong>情景</strong>：你从某个方向来开始了一项研究，研究到一半，你发现另一种方法会更好。这时候你已经提交了几次了，而你其实并不完全需要它们。所以你希望其中的一些提交完全消失。</p>
<p><strong>解决</strong>：<code>git rebase -i &lt;earlier SHA&gt;</code></p>
<p><strong>原理</strong>：-i 指令将 rebase 指令转入一种可交互模式。rebase 指令的作用前几步和上面都一样，唯一不一样的是在合并提交的时候，它会暂停然后让你选择需要合并的提交。</p>
<p><code>rebase -i</code> 会打开默认文本编辑器，文本中会列出可合并的提交，如下：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953863/f6b1ab88-d891-11e4-97c1-e0630ac74e74.png" alt></p>
<p>前面两列是包含着关键信息：第一个是用来提交操作的指令，第二个是提交操作的 SHA 的值。利用 <code>rebase -i</code> 合并操作的默认指令是 <code>pick</code>。</p>
<p>对于不想要的提交，你只需要在文本编辑器中删除对应的内容。如上面这张图，如果你不想要错误的提交，那就删除1、3、4这三行。</p>
<p>如果你想保持提交的内容但是想修改提交的提交信息，那你可以使用 <code>reword</code> 命令。只需要在第一列中替代 <code>pick</code>。虽然立即就改写提交信息听起来很爽，但是实际上并没有用，因为 <code>rebase -i</code> 会将 SHA 后面的信息都无视掉。这个文本只是用来提醒我们这个提交的内容是什么，在执行完 <code>rebase -i</code> 命令之后，就可以改写任意的提交信息了。</p>
<p>如果你想将两个提交合并，你可以使用 <code>squash</code> 或者 <code>fixup</code> 指令，如下：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953865/f6b605ca-d891-11e4-98cf-d567ca9f4edc.png" alt></p>
<p>这两个指令都会使得对应的提交和它之前的提交结合成一个提交。在上面的例子中，第一个和第二个会结合成一个提交，然后第三个和第四个也会结合成一个提交。</p>
<p>当使用 <code>squash</code> 时， Git 会让我们给新合并的提交一个新的提交信息；当使用 <code>fixup</code> 的时候，Git 会自动将列表中将合并的提交的最开始的提交信息作为新的提交信息。拿上图为例，前两个合并时需要输入一个新的合并提交的信息，而后两个合并时，会自动将第三个提交信息作为合并后的提交信息。</p>
<p>当你保存然后关闭文本编辑器的时候， Git就会依次执行编辑器中的内容。如果你希望更改合并的顺序，只需要在文本编辑器中改动。拿上图为例，如果你想合并 <code>af67f82</code> 和 <code>0835fe2</code> ，你只需要这样更换顺序：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953864/f6b4a9d2-d891-11e4-9ac9-10039c031d06.png" alt></p>
<hr>
<h3 id="更改早先的提交"><a href="#更改早先的提交" class="headerlink" title="更改早先的提交"></a>更改早先的提交</h3><p><strong>情景</strong>：你突然想起来，如果在之前的一次提交中加入某一个文件效果会更好。这时候你还没有推送这个提交，而这个提交并不是最近的一次，所以不能用 <code>commit --amend</code></p>
<p><strong>解决</strong>：<code>git commit --squash &lt;SHA of the earlier commit&gt; and git rebase --autosquash -i &lt;even earlier SHA&gt;</code></p>
<p><strong>原理</strong>：利用 <code>git commit --squash</code> 可以创建一个新的提交并有类似这样的提交信息 <code>squash! Earlier commit</code>(你可以手动输入像这样的提交信息，但是使用 <code>commit --squash</code> 可以让你少打一些字 。)</p>
<p>你也可以使用 <code>git commit --fixup</code> 指令来操作，利用这个指令不需要手动输入提交信息。这上面这个情境中，利用这个指令更好一些，因为不需要更改提交信息。</p>
<p>利用 <code>rebase --autosquash -i</code> 指令，然后会打开默认的文本编辑器，而且里面已经包含了提交信息，如下图：<br><img src="https://cloud.githubusercontent.com/assets/2077/6953862/f6a7a1d8-d891-11e4-8784-c32262ff54da.png" alt></p>
<p>当你使用 <code>squash</code> 或者 <code>fixup</code> 指令的时候，你可能不知道你需要合并的提交的 SHA —— 你只记得是一次还是五次之前。这时候操作符 <code>^</code> 和 <code>~</code> 就很方便了。<code>HEAD^</code> 表示 HEAD 之前的一次， <code>HEAD~4</code> 表示的是 HEAD 的前四个提交，也就是倒数第五次提交（因为 HEAD 本身是倒数第一次）。</p>
<hr>
<h3 id="停止对已监测文件的监测"><a href="#停止对已监测文件的监测" class="headerlink" title="停止对已监测文件的监测"></a>停止对已监测文件的监测</h3><p><strong>情景</strong>：你最近将 <code>application.log</code> 加入到了仓库中，然后现在每次运行这个程序， Git 就会提示在这个文件中有未处于提交状态的修改。虽然你将 <code>*.log</code> 写入了 <code>.gitignore</code> 文件，但是情况并没有变化。要怎么才能让 git 放弃监测这个文件的变化呢？</p>
<p><strong>解决</strong>：<code>git rm --cached application.log</code></p>
<p><strong>原理</strong>：<code>.gitignore</code> 会使得 Git不去监测文件的变化，对于之前没有检测过的文件，它甚至会无视文件的存在。只要文件被提交了， Git 就会持续监测它的变化。类似的，如果利用 <code>git add -f</code> 或者覆盖 <code>.gitignore</code> 文件，那么 Git 也会监测这些文件的变化。</p>
<p>如果你想使得那些本不应该被监测的文件脱离监测，那么你可以使用 <code>git rm --cached</code> 指令。利用这个指令会停止 Git 对它的监测，同时这个文件在硬盘上不受影响。由于这个文件现在不被监测了，所以利用 <code>git status</code> 不能看到这个文件了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这是一篇译文，原文地址为： <a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="noopener">How to undo (almost) anything with Git</a>。由于自己碰到了这方面的问题，然后搜索过程中发现了这片文章，写的很全面，所以就翻译了一下。翻译的过程中可能会有一些理解上的偏差，欢迎盆友们指正。</p>
<blockquote>
<p><strong>commit：</strong>  在文中被翻译为 提交<br>  <strong>push：</strong> 在文中被译为 推送</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> 工具 </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack学习指南]]></title>
      <url>http://detachment.club/2016/10/17/webpack%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;前端工程化已成为趋势，善于使用各种工具无疑能极大的提高工作效率，所以这段时间将陆续会有几篇关于这些工具的介绍文章，文章的内容大多是关于这些工具的文档的翻译。<br>&nbsp;&nbsp;&nbsp;&nbsp;本文所有资料来源都是 webpack 官网，有意看原文的戳链接： <a href="http://webpack.github.io/docs/.html" target="_blank" rel="noopener">webpack document</a></p>
<a id="more"></a>
<h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>现在的网页应用有以下特点：</p>
<ul>
<li>有越来越多的JavaScript代码；</li>
<li>现代浏览器能提供越来越多的接口；</li>
<li>虽然有越来越多的代码，但很少会一次加载完。  </li>
</ul>
<p>这些代码需要得到有序管理，模块系统随之产生。</p>
<p>在JavaScript中，有许多不同的方式用来引入数据以及定义依赖关系，常见的有以下几种：</p>
<ul>
<li>通过<code>&lt;script&gt;</code>标签引入（没有模块系统）</li>
<li>CommonJS</li>
<li>AMD及其相关</li>
<li>ES6模块</li>
<li>其他……</li>
</ul>
<p><strong> <code>&lt;script&gt;</code> 标签</strong></p>
<p>如果不利用模块系统的话，通过<code>&lt;script&gt;</code>标签引入如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"libraryA.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"module3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这些数据的接口将连接到全局对象中。常见的问题如下：</p>
<ul>
<li>在全局对象中产生冲突；</li>
<li>数据引入顺序非常重要；</li>
<li>开发者需要手动管理引入模块的依赖关系；</li>
<li>在数据较多的情况下会导致引入列表过长，难以管理。</li>
</ul>
<p><strong>CommonJS：同步请求</strong>  </p>
<p>通过利用<code>require</code>方法来加载依赖，同时返回一个接口，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"module"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"../file.js"</span>);</span><br><span class="line">exports.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = someValue;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>服务器端的模块可以重用</li>
<li>有很多已写好的模块（npm）</li>
<li>简单易用</li>
</ul>
<p>缺点：</p>
<ul>
<li>网络的阻塞调用效果不太好，而且网络请求是异步的</li>
<li>复合模块不能并行请求</li>
</ul>
<p>应用：</p>
<ul>
<li>node.js</li>
<li>browerify</li>
<li>modules-webmake</li>
<li>wreq</li>
</ul>
<p><strong>AMD：异步请求</strong>  </p>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">异步的模块的定义</a><br>有一些浏览器在处理同步引入模块时会有一些问题，为此引入了异步加载模块，具体方式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line">define(<span class="string">"mymodule"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ul>
<li>符合异步加载网络请求的模式</li>
<li>并行加载符合模块</li>
</ul>
<p>缺点：  </p>
<ul>
<li>读写难度较大</li>
<li>类似于一种变通方式  </li>
</ul>
<p>应用：  </p>
<ul>
<li>require.js</li>
<li>curl</li>
</ul>
<p>更多关于<a href="http://webpack.github.io/docs/commonjs.html" target="_blank" rel="noopener">CommonJS</a>以及<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a>的内容。</p>
<p><strong>ES6模块</strong></p>
<p>ES6加入了一些JavaScript构造器，这就组成了一种模块系统，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"jquery"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">module</span> <span class="string">"localModule"</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ul>
<li>静态分析变得简单</li>
<li>指明了ES标准的方向</li>
</ul>
<p>缺点：</p>
<ul>
<li>本地浏览器支持还需要时间</li>
<li>已有的模块较少</li>
</ul>
<p><strong>转移</strong></p>
<p>因为模块需要在客户端执行，那么就必须将它们从服务器端转移到浏览器端。<br>有两种极端的转移情况：</p>
<ul>
<li>每个模块一个请求</li>
<li>所有的模块在一个请求</li>
</ul>
<p>这两种情况都是存在的，但都不是最优的：</p>
<ul>
<li>每个模块一个请求：<ul>
<li>优点：按需加载模块</li>
<li>缺点：更多的请求以为着更多的工作量</li>
<li>缺点：应用启动速度慢</li>
</ul>
</li>
<li>所有模块在一个请求：<ul>
<li>优点：请求工作量较少，延迟较低</li>
<li>缺点：不需要（或暂不需要）的模块也会被一并加载</li>
</ul>
</li>
</ul>
<p><strong>Chunked 转移方式</strong></p>
<p>面对上面两种方式所带来的问题，在大多数的案例中，采用折中的方案会取得比较好的效果。</p>
<p>→ 编译所有模块:将模块组合分成较小一些的组（chunks）。<br>这样做能够使得初始化是没有被请求的数据在被请求时再加载，能起到加快启动速度的同时加载比需要更多的代码。</p>
<p>“代码分割点”可以由开发者自己决定。</p>
<p>→  大代码库成为可能！</p>
<p>注：这个构思来自于 <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting" target="_blank" rel="noopener">Google’s GWT.</a></p>
<p>更多关于 <a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="noopener">代码分割。</a></p>
<p><strong>为什么只应用在JavaScript？</strong></p>
<p>为什么模块系统仅仅用于管理JavaScript？还有许多其他资源需要管理：</p>
<ul>
<li>样式</li>
<li>图片</li>
<li>字体</li>
<li>html文件</li>
<li>等等  </li>
</ul>
<p>以及转化过或者处理过的：</p>
<ul>
<li>coffeescript → JavaScript</li>
<li>elm → JavaScript</li>
<li>less stylesheets → css stylesheets</li>
<li>等等</li>
</ul>
<p>这些处理起来非常简单，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./style.css"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./style.less"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./template.jade"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./image.png"</span>);</span><br></pre></td></tr></table></figure></p>
<p>想达到这种效果，需要用到loader，更多阅读 <a href="http://webpack.github.io/docs/using-loaders.html" target="_blank" rel="noopener">loader。</a></p>
<hr>
<h3 id="Webpack及安装"><a href="#Webpack及安装" class="headerlink" title="Webpack及安装"></a>Webpack及安装</h3><p><strong>Webpack介绍</strong></p>
<p><strong>Webpack是一种模块打包机。</strong><br>Webpack用于处理有依赖关系的模块，它会生成一些静态文件来表示这些模块。简单而言，如下图所示：<br><img src="http://webpack.github.io/assets/what-is-webpack.png" alt="Webpack"></p>
<p><strong>为什么还需要模块打包机？</strong><br>简单而言，是因为现在的打包机无法满足大型的单页应用。而真正促使开发新型打包机的原因是代码分割和静态文件在模块化的过程中需要无缝连接。我尝试过拓展现存的打包机，但是都不能达到这些要求（注：Webpack作者）。</p>
<p><strong>目标</strong>  </p>
<ul>
<li>将依赖分割成不同的chunk，按需加载</li>
<li>让初始加载时间较少</li>
<li>每个静态文件都应该是一个模块</li>
<li>能将第三方的库整合成模块</li>
<li>打包机本身可高度定制</li>
<li>适合大型项目</li>
</ul>
<p><strong>Webpack有什么不同？</strong>  </p>
<p><a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="noopener">代码分割</a><br>Webpack的依赖关系有两种类型：同步和异步。<br>异步依赖相当于分割点，会形成一个新的chunk。当chunk之间的关系最优化之后，每个chunk都会有一个相关文件。   </p>
<p><a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">Loaders</a><br> Webpack只能在本地处理JavaScript，而利用loaders能够将其他资源转化成JavaScript，通过这种手段，所有的资源都能形成模块。  </p>
<p><strong>智能解析</strong><br>Webpack的智能解析功能使得它基本上能够处理所有第三方库，甚至允许模块以下面这种方式来表示依赖关系：<code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;).</code>它能兼容常见的模块模式，如 <a href="http://webpack.github.io/docs/commonjs.html" target="_blank" rel="noopener">CommonJS</a> 以及 <a href="http://webpack.github.io/docs/amd.html" target="_blank" rel="noopener">AMD</a>。</p>
<p><a href="http://webpack.github.io/docs/plugins.html" target="_blank" rel="noopener">插件系统</a><br>Webpack的强大离不开其强大的插件系统的支持。这也使得Webpack具有高度定制性，也吸引人们创造更多的开源插件</p>
<p><strong>安装</strong><br><strong>node.js</strong><br>首先安装 <a href="http://nodejs.org/" target="_blank" rel="noopener">node.js</a>，里面包含了一种包管理工具，叫做npm。  </p>
<p><strong>Webpack</strong><br>用npm来全局安装Webpack，全局安装的话就可以在全局环境中直接用 <code>Webpack</code> 命令了，命令行如下：<br><code>$ npm install webpack -g</code>  </p>
<p><strong>在项目中引入</strong><br>做项目的时候最好以项目依赖的方式引入Webpack，那样的话就不会去依赖全局的Webpack了。<br>首先利用npm新建一个package.json配置文件，命令行如下：<br><code>$ npm init</code><br>上面提到的项目依赖的方式安装Webpack可以通过以下命令行实现：<br><code>$ npm install webpack --save-dev</code></p>
<p><strong>版本</strong><br>有两个版本的Webpack可供下载，一个是稳定版本，另一个是测试版本。测试版本有<code>-beta</code>的后缀，这个版本会包含一些带有实验性质的性能，而且也没有经过大量的测试。所以建议对稳定性能要求较高的同志们选择稳定版本，命令行如下：<br><code>$ npm install webpack@1.2.x --save-dev</code></p>
<p><strong>开发者工具</strong><br>如果需要使用开发者工具，就需要安装了，命令行如下：<br><code>$ npm install webpack-dev-server --save-dev</code></p>
<hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>安装</strong><br>上面已经提到可全局安装或者以项目依赖的方式安装。在实际项目中，建议都以项目依赖的方式安装，本文为了方便展示，都是以全局安装为例的。  </p>
<p><strong>开始使用</strong>  </p>
<ul>
<li><p>首先用CommonJS语法创建一个模块化的JavaScript项目，名字为<code>cat.js</code>，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cats.js</span></span><br><span class="line"><span class="keyword">var</span> cats = [<span class="string">'dave'</span>, <span class="string">'henry'</span>, <span class="string">'martha'</span>];</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = cats;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js(Entry Point)</span></span><br><span class="line">cats = <span class="built_in">require</span>(<span class="string">'./cats.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cats);</span><br></pre></td></tr></table></figure>
<p><code>Entry Point</code>是项目接入模块的入口，Webpack也是从这个接口开始检查各个模块之间的依赖关系的。</p>
</li>
<li><p>打包文件：Webpack需要指定入口文件（app.js），同时也需要明确的指定输出文件的名字（app.bundle.js），指令如下：<br><code>webpack ./app.js app.bundle.js</code><br>然后Webpack会解读入口文件同时分析其依赖（以及依赖的依赖），分析完以后，会将所有的依赖绑定输出到输出文件中（本例为app.bundle.js）。<br><img src="https://dtinth.github.io/webpack-docs-images/usage/how-it-works.png" alt="webpack"></p>
</li>
<li><p>然后就可以运行了，在node中运行及结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">app</span>.bundle.js</span><br><span class="line">[<span class="string">"dave"</span>, <span class="string">"henry"</span>, <span class="string">"martha"</span>]</span><br></pre></td></tr></table></figure>
<p>当然了，也可以在浏览器的环境下运行。  </p>
</li>
</ul>
<p><strong>使用进阶</strong><br>webpack具有很多高级功能，很多功能通过命令行工具很难体现出来，这时候我们就需要去创建配置文件了。</p>
<ul>
<li><p>项目结构：在实际的生产环境中，我们会将源文件和输出文件放在不同的文件夹中以便于管理，典型的例子如下图所示：<br><img src="https://raw.githubusercontent.com/dtinth/webpack-docs-images/2459637650502958669ea6b11bf49dc0b3b083ae/usage/project-structure.png" alt="folders"></p>
<blockquote>
<p><em>在实际的生产环境中会有很多类似但并不完全相同的项目结构，比如有些项目会将 src 文件夹命名为 APP ，会将 bin 文件夹命名为 dist 或者是 build ，等等诸如此类，其实都是一样的。</em></p>
</blockquote>
</li>
<li><p>配置文件：当项目变得越来越庞大复杂的时候，手动设置这些就显得不是那么明智了，这时候可以创建一个配置文件，名字叫做<code>webpack.config.js</code>:</p>
<ol>
<li><p>创建一个<code>webpack.config.js</code>的配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    entry: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'./bin'</span>,</span><br><span class="line">        filename: <span class="string">'app.bundle.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置文件放在合适的位置，现在运行webpack只需要以下代码：<br><code>webpack</code><br>然后webpack就会去解析配置文件，并按照配置文件中的配置来解读接入文件以及输出文件到指定位置。</p>
</li>
</ol>
</li>
<li><p>引入loaders：webpack本身只支持JavaScript模块，为了支持其他模块，就需要引入各种loader了。loader能够将其他资源加载成webpack能够识别的JavaScript。典型的例子如 babel-loader，json-loader等，如下图：<br><img src="https://dtinth.github.io/webpack-docs-images/usage/babel-loader.png" alt="babel-loader"><br><img src="https://dtinth.github.io/webpack-docs-images/usage/json-loader.png" alt="json-loader"><br><img src="https://dtinth.github.io/webpack-docs-images/usage/yaml-loader.png" alt="yaml-loader"></p>
</li>
<li><p>以babel-loader为例说明如下：</p>
<ol>
<li>安装Babel：<br><code>npm install --save-dev babel-core babel-preset-es2015</code></li>
<li>安装babel-loader：<br><code>npm install --save-dev babel-loader</code></li>
<li>新建一个.babelrc文件，这个文件用来配置Babel，使其利用预先设置的语法（es2015）来解析。.babelrc的内容如下：<br><code>{ &quot;presets&quot;: [ &quot;es2015&quot; ] }</code></li>
<li><p>更改 webpack.config.js 文件，使的所有的 .js 文件都用 babel-loader 来处理：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">module.exports</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">entry:</span> <span class="string">'./src/app.js'</span><span class="string">,</span></span><br><span class="line">  <span class="attr">output:</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">'./bin'</span><span class="string">,</span></span><br><span class="line">      <span class="attr">filename:</span> <span class="string">'app.bundle.js'</span><span class="string">,</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="attr">module:</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">loaders:</span> <span class="string">[&#123;</span></span><br><span class="line">          <span class="attr">test:</span> <span class="string">/\.js$/,</span></span><br><span class="line">          <span class="attr">exclude:</span> <span class="string">/node_modules/,</span></span><br><span class="line">          <span class="attr">loader:</span> <span class="string">'babel-loader'</span></span><br><span class="line">      <span class="string">&#125;]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注意：这里讲node_modules文件排除在外了，因为不排除的话，这些外部的插件库也会被Babel处理，从而减缓编译速度</em>  </p>
</blockquote>
</li>
<li><p>安装所需要的其他库（以jQuery为例）：<br><code>npm install --save jquery babel-polyfill</code></p>
<blockquote>
<p><em>注意：这里没有用 –save-dev，因为这些库只有在项目运行时才会使用，同时为了能在低版本的浏览器中使用ES6的特性，这里安装了babel-ployfill。</em></p>
</blockquote>
</li>
<li><p>编辑 <code>src/app.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;</span><br><span class="line"><span class="keyword">import</span> cats <span class="keyword">from</span> <span class="string">'./cats'</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'&lt;h1&gt;Cats&lt;/h1&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">const</span> ul = $(<span class="string">'&lt;ul&gt;&lt;/ul&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> cat <span class="keyword">of</span> cats) &#123;</span><br><span class="line">    $(<span class="string">'&lt;li&gt;&lt;/li&gt;'</span>).text(cat).appendTo(ul);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用webpack来打包模块：<br><code>webpack</code></p>
</li>
<li><p>创建一个index.html文件，并将打包好的文件引入，以便于在浏览器中展示出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;script src="bin/</span>app.bundle.js<span class="string">" charset="</span>utf<span class="number">-8</span><span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>当打开index.html时，不出意外的话会看到下图：<br><img src="https://dtinth.github.io/webpack-docs-images/usage/cats.png" alt="cats"></p>
</li>
</ol>
</li>
<li><p>引入插件：在实际生产环境中，我们可能会需要使用一些插件来处理打包好的文件，比如说我们可能会想压缩文件以便于更快的加载速度，这时候就需要使用插件了，以 <code>uglify</code> 插件为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'./bin'</span>,</span><br><span class="line">        filename: <span class="string">'app.bundle.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">            compress: &#123;</span><br><span class="line">                warnings: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            output: &#123;</span><br><span class="line">                comments: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由于webpack本身自带 Uglify 这个插件，所以使用时不需引入，但是如果需要使用其他没有内置的插件的时候，还是需要手动引入的，而且自己也可以写插件。</p>
<hr>
<h3 id="使用-Loaders"><a href="#使用-Loaders" class="headerlink" title="使用 Loaders"></a>使用 Loaders</h3><p><strong>什么是 loaders ？</strong><br>loaders是一些对你的项目中的资源进行转化的工具，它们是一些把源文件的路径作为参数的函数，然后通过函数返回新的路径。<br>例如，webpack中可以通过使用loader来加载CoffeeScript或者是JSX。</p>
<p>loader的特征：</p>
<ul>
<li>loaders 可以链式应用（如上一节提到的.yml文件的解析）。链式应用的中间文件的格式可以是任意的，只要最后输出的格式是JavaScript格式即可</li>
<li>loaders 可以是同步的或者是异步的；</li>
<li>loaders 可以在nodejs环境下运行，也可以实现所有可能实现的功能；</li>
<li>loaders 可接受查询参数，可以利用这个功能来配置loader；</li>
<li>loaders 可以在配置文件中被绑定到正则表达式或者扩展中；</li>
<li>loaders 可以通过npm来发布或者是安装；</li>
<li>一般的模块都可以通过 <code>package.json loader</code> 在输出<code>main</code>之外还输出一个 loader ；</li>
<li>loaders 可以读取配置文件；</li>
<li>插件可以使 loaders 的功能更强大；</li>
<li>loaders 可以生成任意的附加文件；</li>
<li><a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">等等</a></li>
</ul>
<p><strong>解析loaders</strong><br>loaders 的解析方式和模块类似，loader 模块一般会输出一个 nodejs 能够识别的函数。通常情况下我们会用 npm 来管理 loaders ，但是我们也可以以文件的形式直接放在应用文件夹中。</p>
<ul>
<li><p>引用 loaders<br>按照惯例，我们通常将 loaders 命名为<code>xxx-loader</code>其中 xxx 表示的就是具体的名称，比如 <code>json-loader</code>。在引用的时候，既可以用全名，也可以用简写（不包括loader部分）。<br>loader 的命名规则以及搜索优先顺序被定义在 webpack 配置 API 文件 <code>resolveLoader.moduleTemplates</code> 中。<br>loader 的命名规则有时候会派上用场，尤其是利用 <code>require()</code> 来引用它们的时候。</p>
</li>
<li><p>安装 loaders<br>只要 npm 中有你需要的 loaders， 那么那就可以通过以下任意一种方式来安装它们：<br><code>$ npm install xxx-loader --save</code> 或者是 <code>$ npm install xxx-loader --save-dev</code><br>(其中后者是以生产依赖的方式安装，前者为普通安装。以生产依赖的方式安装会自动改变 webpack 的配置文件中的依赖部分)</p>
</li>
</ul>
<p><strong>用法</strong><br>有很多途径都能在项目中应用 loaders：</p>
<ul>
<li>直接通过 <code>require</code> 声明来引用</li>
<li>通过配置文件来配置</li>
<li>通过 CLI 来配置</li>
</ul>
<p>以下将分别就这三种方式进行说明：  </p>
<ul>
<li><p>通过 <code>require</code> 方式  </p>
<blockquote>
<p><em>注意：如果你不能确定你的脚本的运行环境，那么就尽可能不要使用这种方式，而是利用配置规则来使用 loaders。</em></p>
</blockquote>
<p>利用 <code>require</code>声明（或者 <code>define</code>, <code>require.ensure</code> 声明 ）是可以规范化使用 loader 的，只要通过使用 <code>!</code> 符号将需处理文件和 loader 隔开。如果有多个 loader， 那么将遵循从右到左的顺序依次解析。 具体例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./loader!./dir/file.txt"</span>);</span><br><span class="line"><span class="comment">// uses the file "loader.js" in the current directory to transform</span></span><br><span class="line"><span class="comment">// "file.txt" in the folder "dir".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jade!./template.jade"</span>);</span><br><span class="line"><span class="comment">// uses the "jade-loader" (that is installed from npm to "node_modules")</span></span><br><span class="line"><span class="comment">// to transform the file "template.jade"</span></span><br><span class="line"><span class="comment">// If configuration has some transforms bound to the file,</span></span><br><span class="line"><span class="comment">// they will still be applied.</span></span><br><span class="line"><span class="comment">// 如果此时配置文件中规定了需要处理这个文件，那么这时候会处理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"!style!css!less!bootstrap/less/bootstrap.less"</span>);</span><br><span class="line"><span class="comment">// the file "bootstrap.less" in the folder "less" in the "bootstrap"</span></span><br><span class="line"><span class="comment">// module (that is installed from github to "node_modules") is</span></span><br><span class="line"><span class="comment">// transformed by the "less-loader". The result is transformed by the</span></span><br><span class="line"><span class="comment">// "css-loader" and then by the "style-loader".</span></span><br><span class="line"><span class="comment">// If configuration has some transforms bound to the file,</span></span><br><span class="line"><span class="comment">// they will not be applied.</span></span><br><span class="line"><span class="comment">// 由于此处在规则的最前面加了前缀 “！”， 如果配置文件中规定了需要处理这个文件，</span></span><br><span class="line"><span class="comment">// 那么这时候仍然不会处理。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="noopener">配置文件方式</a><br> 在配置文件中可以通过用正则表达式的方式来绑定 loaders ，如下所示：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.jade$/</span>, <span class="attr">loader</span>: <span class="string">"jade"</span> &#125;,</span><br><span class="line">            <span class="comment">// =&gt; "jade" loader is used for ".jade" files</span></span><br><span class="line"></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">"style!css"</span> &#125;,</span><br><span class="line">            <span class="comment">// =&gt; "style" and "css" loader is used for ".css" files</span></span><br><span class="line">            <span class="comment">// Alternative syntax:</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loaders</span>: [<span class="string">"style"</span>, <span class="string">"css"</span>] &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://webpack.github.io/docs/cli.html" target="_blank" rel="noopener">CLI 方式</a><br> 可以通过命令行工具来绑定 loaders， 如下所示：<br>  <code>$ webpack --module-bind jade --module-bind &#39;css=style!css&#39;</code><br>   上面的例子会使得利用 <code>jade-loader</code> 来处理 <code>.jade</code> 文件， 用<code>css-loader &amp; style-loader</code> 来处理 <code>.css</code> 文件。</p>
</li>
</ul>
<p><strong>查询参数</strong><br>  可以通过使用 <code>?</code> 的方式来决定是否使用 loader，比如 <code>url-loader?mimetype=image/png</code> 表示就是，如果媒体文件都是图片格式， <code>mimetype=image/png</code>，那么就使用 <code>url-loader</code>来进行处理。<br>  注意：查询语法根据不同的 loader 可能会不一样，具体情况需要查询相应的文档。但是一般而言，都支持常见的查询语法，如 <code>(?key=value&amp;key2=value2)</code>，或者JSON对象如 <code>(?{&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></p>
<p>与上面提到的三种方式相对应的，利用查询的写法如下：</p>
<ul>
<li>通过 <code>require()</code> 方式：<br><code>require(&quot;url-loader?mimetype=image/png!./file.png&quot;);</code></li>
<li><p>通过配置文件：<br><code>{ test: /\.png$/, loader: &quot;url-loader?mimetype=image/png&quot; }</code><br>或者写的好看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.png$/</span>,</span><br><span class="line">loader: <span class="string">"url-loader"</span>,</span><br><span class="line">query: &#123; <span class="attr">mimetype</span>: <span class="string">"image/png"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLI方式：<br><code>webpack --module-bind &quot;png=url-loader?mimetype=image/png&quot;</code></p>
</li>
</ul>
<hr>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>使用插件能够增强 webpack 的功能，比如，利用 <a href="https://github.com/senotrusov/bell-on-bundler-error-plugin" target="_blank" rel="noopener"> BellOnBundlerErrorPlugin</a> 插件就能提示在打包过程中出现的错误。</p>
<p><strong>内置插件</strong><br>对于内置插件，如果在 webpack 的配置文件中有用到它们的功能，那么就会将这些插件包含在模块中。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack should be in the node_modules directory, install if not.</span></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.ResolverPlugin([</span><br><span class="line">            <span class="keyword">new</span> webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(<span class="string">"bower.json"</span>, [<span class="string">"main"</span>])</span><br><span class="line">        ], [<span class="string">"normal"</span>, <span class="string">"loader"</span>])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>外部插件</strong><br>外部的插件可以通过 <code>npm</code> 来安装，例如：<br><code>npm install component-webpack-plugin</code><br>安装完之后就可以使用了，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentPlugin = <span class="built_in">require</span>(<span class="string">"component-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ComponentPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用 <code>npm</code> 来安装第三方插件的时候，建议使用这个工具: <a href="https://www.npmjs.com/package/webpack-load-plugins" target="_blank" rel="noopener">https://www.npmjs.com/package/webpack-load-plugins</a> ，它会自动检测依赖中的所有插件，然后在需要的时候懒加载它们。</p>
<p><strong>更多阅读</strong><br><a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">了解更多，可查看插件列表</a></p>
<hr>
<h3 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h3><p><strong>解析过程</strong></p>
<ul>
<li>常见故障：<ul>
<li>利用 <code>--display-error-details</code> 可以得到详细信息</li>
<li>阅读配置文件，关于故障分析的部分都在 <code>resolve</code></li>
<li>loaders 的配置文件中有对应的故障分析 <code>resolveLoader</code></li>
</ul>
</li>
</ul>
<ul>
<li>npm 链接模块找不到所需依赖<br>&nbsp;&nbsp;&nbsp;&nbsp;node.js 的模块解析算法非常简单：系统寻找模块依赖时，会在所需模块的父文件夹的 <code>node_modules</code> 文件夹中寻找。如果你 npm 链接的带有同级依赖的模块没有放在根目录下，那么系统就无法找到这些模块（你可能会认为带有 <code>npm link</code> 的 <code>peerDependencies</code> 是 node.js 的设计缺陷）。需要注意的是应用的依赖也是一种 <code>peerDependencies</code>， 即使这种依赖并没有在模块的 <code>package.json</code> 文件中列出来。<br> &nbsp;&nbsp;&nbsp;&nbsp;要在 webpack 中分析这个问题其实很简单：只需要将应用的 <code>node_modules</code> 文件夹放在解析路径中，具体的设置例子如下：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123; <span class="attr">fallback</span>: path.join(__dirname, <span class="string">"node_modules"</span>) &#125;,</span><br><span class="line">  resolveLoader: &#123; <span class="attr">fallback</span>: path.join(__dirname, <span class="string">"node_modules"</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>监测过程</strong></p>
<ul>
<li><p>监测过程中， webpack 不会在资源有变动时重编译</p>
</li>
<li><p>监测到文件变化，但是文件并没有更新<br> &nbsp;&nbsp;&nbsp;&nbsp;可以确定的是，在 webpack 中，如果运行时加上了 <code>-progress</code> 标签，那么资源的变动将不会被监测。如果保存时能看到进展但却没有文件输出，那么就可能是配置上的问题，而不是文件监测问题了。<br>  <code>webpack --watch --progress</code></p>
</li>
<li><p>监测器不够<br> &nbsp;&nbsp;&nbsp;&nbsp;首先需要确认你的系统中是否有足够可用的检测器，如果可用数量太少，那么 webpack 中的检测器可能就检测不到变化了：<br>  <code>cat /proc/sys/fs/inotify/max_user_watches</code><br>  对于 Arch 用户，将 <code>fs.inotify.max_user_watches=524288</code> 加到 <code>/etc/sysctl.d/99-sysctl.conf</code> 文件中，然后执行 <code>sysctl --system</code>。对于 Ubutu 用户：<code>echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p.</code></p>
</li>
<li><p>OS-X FSevents bug<br> 在 OS-X 系统中，文件夹可能会崩溃，具体可参考下面的文章：<br>  <a href="http://feedback.livereload.com/knowledgebase/articles/86239-os-x-fsevents-bug-may-prevent-monitoring-of-certai" target="_blank" rel="noopener">OS X FSEvents bug may prevent monitoring of certain folders</a></p>
</li>
<li><p>Windows 路径<br> &nbsp;&nbsp;&nbsp;&nbsp;在 webpack 中的很多配置选项默认都是绝对路径。 <code>__dirname + &quot;/app/folder&quot;</code> 这种写法是错误的，因为在 Windows 系统中路径的分隔符是 <code>\</code>。这有时候会产生一些问题。建议使用正确的分隔符，比如 <code>path.resolve(__dirname, &quot;app/folder&quot;)</code> 或者 <code>path.join(__dirname, &quot;app&quot;, &quot;folder&quot;).</code></p>
</li>
<li><p>Vim<br> &nbsp;&nbsp;&nbsp;&nbsp;有些型号的机器上，Vim 的 <code>backupcopy option</code> 会被默认设置成 <code>auto</code>。这有可能会影响到系统的文件监测机制。所以建议将这个选项设置为 <code>yes</code>，这样的话就会在保存的时候覆盖原文件并保存一份副本。Vim 中的设置如下：<br>  <code>:set backupcopy=yes</code></p>
</li>
<li><p>WebStorm<br> &nbsp;&nbsp;&nbsp;&nbsp;当使用 JetBrains 的 WebStorm 的 IDE 的时候，你可能会发现在保存更改过的文件时并没有触发预想中的检测器。这时候就需要设置 <code>safe write</code> 选项了，这个选项决定了是否在保存更改过的文件前保存一份原文件在临时路径中： 取消下列设置<br>  <code>File &gt; Settings... &gt; System Settings &gt; Use &quot;safe write&quot; (save changes to a temporary file first).</code></p>
</li>
</ul>
<hr>
<h2 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h2><blockquote>
<p>文档比较混乱，所以先放一放，后面的部分写好再来。</p>
</blockquote>
<hr>
<h2 id="指导文件"><a href="#指导文件" class="headerlink" title="指导文件"></a>指导文件</h2><h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p>为了解决JS中作用域的问题， CommonJS 小组定义了一种模块格式，这可以确保所有的模块都在自己的命名空间执行。<br>怎样能到达到这个目的呢？其一需要在模块中明确的输出那些适用于全局作用域的变量，其二需要定义其他模块需要的变量。<br>为了达到这个效果， CommonJS 给我们提供了两个工具：</p>
<ul>
<li>利用 <code>require()</code> 函数可以将一个指定的模块引入到现在的作用域；</li>
<li>利用 <code>module</code> 对象可以将现在作用域中内容输出；</li>
</ul>
<p><strong>简单的例子</strong><br>下面是一个不用 CommonJS 的例子：<br>首先在一个js文件中定义一个变量，这个文件在之后其他的文件中将会被用到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在另一个文件中应用这个变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">" world!"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>定义模块</strong><br>上面的例子中将会因为 <code>MySalute</code> 没有被定义而报错，我们应该将这些文件定义为模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = MySalute;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = Result;</span><br></pre></td></tr></table></figure>
<p>在这两个例子中，我们将变量传入到了一个特殊的变量 <code>module</code> 中，这样一来 CommonJS 的模块系统就知道模块中需要被输出的对象了： <code>salute.js</code> 中输出 <code>MySalute</code> 对象，  <code>world.js</code> 中输出  <code>Result</code> 对象。</p>
<p><strong>模块依赖</strong><br>上面已经很接近了，但是还差一步：定义依赖。虽然都分别定义了自个为独立的模块，但是 <code>world.js</code> 还是不知道在哪里找到 <code>MySalute</code> 的定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// salute.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = MySalute;</span><br></pre></td></tr></table></figure></p>
<p>我们需要做的最后一步就是在 <code>world.js</code> 中引入模块的依赖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">var</span> MySalute = <span class="built_in">require</span>(<span class="string">"./salute"</span>);  <span class="comment">// This is it!</span></span><br><span class="line"><span class="keyword">var</span> Result = MySalute + <span class="string">"world!"</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = Result;</span><br></pre></td></tr></table></figure></p>
<p>需要注意，在我们利用 <code>require</code> 引用的时候，并没有使用 <code>salute.js</code> 的全名，意思就是我们可以省略后缀。 <code>./</code> 符号表示的是相对路径：引用文件和被引用文件在同一个文件夹目录下。</p>
<p><strong>最后的例子</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> multiplyBy2 = <span class="built_in">require</span>(<span class="string">'./moduleA'</span>);</span><br><span class="line"><span class="keyword">var</span> result = multiplyBy2( <span class="number">4</span> );</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD (Asynchronous Module Definition) 的产生是因为有些人认为 CommonJS 的模块系统暂时还不适合浏览器环境，因为从本质上来说 CommonJS 的模块是同步加载的。<br>AMD 指出了一种模块化 JavaScript 的规范， 按照这个规范模块能够异步加载它们的依赖，这就解决了同步加载带来的问题。</p>
<p><strong>规范说明</strong><br>在 AMD 中，模块是利用<code>define</code> 来定义的。<br><em>define</em><br>在 AMD 规范中利用 <code>define</code> 函数定义模块的形式如下：<br><code>define(id?: String, dependencies?: String[], factory: Function|Object);</code><br><em>id</em><br>模块的名字，为可选项<br><em>dependencies</em><br>这个参数是用来指出正在被定义的这个模块所需要依赖的其他模块，这个参数是个数组，里面包含了依赖模块的标识符。这也是一个可选参数，如果省略不写，默认值则是：<code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code><br><em>factory</em><br>这个参数是用来定义模块的。它可以是个函数（这个函数应该会被调用），或者是个对象。如果这个参数是个函数，那么函数的返回值将会是这个模块的输出值。</p>
<p><strong>例子</strong><br>简单的来看一些例子。</p>
<ul>
<li><p>具名模块<br>定义一个依赖 <code>jquery</code> 的名字为 <code>myModule</code> 的模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'myModule'</span>, [<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ is the export of the jquery module.</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// and use it</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：在 webpack 中一个具名模块只在本地有效，而在 Require.js 中则是全局有效的。</p>
</li>
<li><p>匿名模块<br>定义一个匿名模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂模块<br>定义一个具有多重依赖的模块，需要注意的是每个模块的输出都会传到 <code>factory</code> 函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>, <span class="string">'./math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ and math are the exports of the jquery module.</span></span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出值<br>定义一个输出自身的模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> HelloWorldize = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</span><br><span class="line">        $(selector).text(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HelloWorldize;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个利用 <code>require</code> 来加载依赖的模块：</p>
<blockquote>
<p>因为没有定义依赖， webpack 将将上面提到的默认值传入后面的函数 ，然后就可以利用这些参数做文章了。</p>
</blockquote>
<p>  ​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">    $(<span class="string">'body'</span>).text(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<hr>
<h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于大型的网页应用而言，把所有的代码放在一个文件中往往会效率低下，特别是当其中有些代码块只需要在特定环境下加载的时候。 webpack 中有一个特性，这个特性能够将代码分割成许多的 <code>chunks</code> ，这些代码块只会在被需要的时候才加载。有些其他的打包机将被分割的代码块称作为 <code>layers</code>, <code>rollups</code> 或者 <code>fragments</code>。这个特性就叫做“代码分割”。<br>&nbsp;&nbsp;&nbsp;&nbsp;这是一个可选的特性。我们可以在代码中定义代码分割点，然后 webpack 内部来处理依赖关系，输出文件和执行环境等事物。<br>&nbsp;&nbsp;&nbsp;&nbsp;在这里需要澄清一个概念：代码分割的功能不仅仅是将普通的代码提取分割成共享的代码块（chunk），它最重要的功能其实是将代码分割成能够 <strong>按需加载</strong> 的代码块。这样就会减少网页应用的初始加载量，并使得其他代码能够按需加载。</p>
<p><strong>定义分割点</strong><br>AMD 和 CommonJS 通过不同的方式使得代码按需加载。这些方法都是有效的，分别如下所示：</p>
<ul>
<li><p>CommonJS： <code>require.ensure</code></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies, callback)</span><br></pre></td></tr></table></figure>
<p>  <code>require.ensure</code> 方法可以确保当调用回调函数的时候，所有在 <code>dependencies</code> 中的依赖都能够被同步调用。<code>callback</code> 函数再被调用的时候会将 <code>require</code> 函数当做参数传入。<br>  例子如下：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">"module-a"</span>, <span class="string">"module-b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"module-a"</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  注意：<code>require.ensure</code> 函数仅仅是加载模块，并不会执行它们。</p>
</li>
<li><p>AMD： <code>require</code><br>AMD 规范中定义了一种异步的 <code>require</code> 方法，如下所示：<br><code>require(dependencies, callback)</code><br>当被调用时，所有的依赖都会被加载，而且加载的依赖的输出将会被传入到回调函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"module-a"</span>, <span class="string">"module-b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  注意： AMD 中 <code>require</code> 方法是会加载并执行模块的。在 webpack 中模块式从左到右执行的。<br>  注意：回调函数是可以省略的。</p>
</li>
<li><p>ES6 模块<br>webpack 不支持 ES6 模块，需要根据编译器支持哪种格式的模块格式来选择是使用 <code>require</code> 还是 <code>require.ensure</code>.<br>webpack 1.xx（即将到来的2.0.0）版本本身并不支持 ES6 模块。但是可以利用编译器，比如 <code>Babel</code> 来将 ES6 中的 <code>import</code> 语法转换成 CommonJS 或者 AMD 模块，从而达到目的。这种方法很有效，但是动态加载的时候会产生一个警告。<br>模块的语法（<code>import x from &quot;foo&quot;</code>）被故意设计成只能静态分析，所以不能够动态引入模块：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// INVALID!!!!!!!!!</span><br><span class="line">[“lodash”, “backbone”].forEach(name =&gt; import name )</span><br></pre></td></tr></table></figure>
<p>不过幸运的是，在规范中提到可以利用一个 JavaScript API 中的 <code>loader</code> 来处理动态引入的情况：<code>System.load(or Sytem.import)</code>。这个 API 能起到和上面提到的 <code>require</code> 一样的作用。然而，大部分的编译器并不支持将 <code>System.load</code> 转化成 <code>require.ensure</code>，所以这时候如果想要动态的代码分割的话只能是直接去做了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//static imports</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dynamic imports</span></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contacts = <span class="built_in">require</span>(<span class="string">'./contacts'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Chunk 内容<br>在一个分割点内的所有依赖都会被包括在一个 Chunk 中，它们会被递归的加到这个 chunk 中。<br>如果你将一个函数表达式作为回调函数传入（或者绑定）到一个分割点， Webpack 会自动的将这个函数表达式中所需要的依赖同时打包到这个 chunk 中。</p>
</li>
<li><p>Chunk 优化</p>
<ul>
<li>如果两个 chunks 包含了同样的模块，那么这两个 chunk 将会合并成一个。这会造成 chunks 会有多重父级；</li>
<li>如果一个模块在一个 chunk 的所有父级中都出现了，那么这个模块将会从这个 chunk 中移除；</li>
<li>如果一个 chunk 包含了另一个 chunk 中的所有模块，那么将会形成多重 chunks。</li>
</ul>
</li>
<li><p>Chunk 加载<br> 基于一个叫做 <code>target</code> 的配置选项，关于 chunk 加载的运行环境会被加入到 <code>bundle</code> 文件中，例如：当 <code>target</code> 是 web 时， chunks 将会通过 jsonp 来加载。一个 chunk 只会加载一次， 并行的请求也会合并成一个请求。运行环境会检查已经加载的 chunk 是否形成复合 chunks。</p>
</li>
<li><p>Chunk 类型</p>
<ul>
<li>入口 chunk<br> 入口代码块包含了运行环境以及一些模块。如果 chunk 中包含了模块 <code>Θ</code>， 那么将在运行环境中执行它。如果不包含这个模块，就会等到包含这个模块的 chunk 然后再执行（每一次遇到包含模块 <code>Θ</code> 的时候都会执行一次）。</li>
<li>普通 chunk<br> 普通的 chunk 不包含运行环境，只包含一些模块。里面的结构由 chunk 加载算法来决定。例如，对于 jsonp 而言，模块将会被包含在 jsonp 的回调函数中。 chunk 里面也包含了一个由它来完成的 chunk id 的列表。</li>
<li>初始 chunk（非入口）<br> 初始 chunk 是普通 chunk 的一种。它们之间唯一的区别是在优化的时候，初始 chunk 会更加被重视，因为它会影响到初始加载时间（就像入口 chunk 一样）。这种类型的 chunk 会在结合 <code>CommonChunkPlugin</code> 使用的时候产生。</li>
</ul>
</li>
<li><p>拆解 app 以及分离代码<br> 为了将 app 拆解成两个文件，比如app.js 以及 vendor.js， 我们可以在 vendor.js 中利用 <code>require</code> 来引入 vendor 参数中的文件。然后将这个名字传入到 <code>CommonsChunkPlugin</code>中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">"./app.js"</span>,</span><br><span class="line">    vendor: [<span class="string">"jquery"</span>, <span class="string">"underscore"</span>, ...],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="comment">/* chunkName= */</span><span class="string">"vendor"</span>, <span class="comment">/* filename= */</span><span class="string">"vendor.bundle.js"</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这会将 vendor chunk 中所包含的所有模块从 app chunk 中移除。 <code>bundle.js</code> 中将只会包含所有的 app 代码，不带有任何的依赖，所有的依赖代码都在 <code>vendor.bundle.js</code> 中。<br>在 HTML 文件中，需要先加载 <code>vendor.bundle.js</code> 然后再加载 <code>bundle.js</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"vendor.bundle.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="bundle.js"&gt;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个入口 chunks<br> 通过<a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="noopener">配置</a>可以实现多个入口点，这同时会形成多个入口 chunks。入口 chunk 中包含了运行环境，而一个页面中只能包含一个运行环境（当然也会有例外）。</p>
</li>
<li><p>运行多个入口点<br> 通过插件 <code>CommonsChunkPlugin</code> 可以将运行环境转移到 commons chunk 中。入口点这时候在初始 chunk 中。虽然只有一个初始 chunk 可以被加载，但是多个入口 chunk 可以被加载。这就说明了在同一个页面中运行多个入口点是可能的。例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">       entry: &#123; <span class="attr">a</span>: <span class="string">"./a"</span>, <span class="attr">b</span>: <span class="string">"./b"</span> &#125;,</span><br><span class="line">       output: &#123; <span class="attr">filename</span>: <span class="string">"[name].js"</span> &#125;,</span><br><span class="line">       plugins: [ <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">"init.js"</span>) ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入的时候，按如下顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"init.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="a.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"b.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Commons Chunk<br> 插件 <code>CommonsChunkPlugin</code> 可以将多个入口 chunks 的模块转移到一个新的入口文件（也就是 commons chunk）中。运行环境也被转移到了 commons chunk 中。这意味着原来的入口 chunk 现在变成了初始 chunk。了解更多<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">插件选项。</a></p>
</li>
<li><p>优化<br> 有一些用于优化的插件能够根据特别的标准将 chunk 合并起来，参考<a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="noopener">插件列表</a></p>
</li>
<li><p>具名 chunks<br> <code>require.ensure</code> 函数可以接收额外的第三个参数，这个参数必须是字符串类型。如果两个分割点传入了同样的字符串，那么它们将利用同样的 chunk。</p>
</li>
<li><p><code>require.include</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.include(request)</span><br></pre></td></tr></table></figure>
<p><code>require.include</code> 是 Webpack 中一个特殊的函数，它可以将模块加入到现在的 chunk 中，但是不会去执行它（打包的时候会将声明移除）。例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">"./file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./file2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// is equal to</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.include(<span class="string">"./file"</span>);</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./file2"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果模块是在复合子代码块中，那么这个函数将非常有用。在父级代码块中运用这个函数引入模块将会使得这个子代码块中的模块实例都消失。</p>
</li>
</ul>
<hr>
<h3 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h3><p><strong>内嵌样式表</strong><br>通过利用 <code>style-loader</code> 以及 <code>css-loader</code> 使得将样式表内嵌在 JavaScript 打包文件中变得可能。这种方式下你可以将你的样式表和其他模块一起模块化。引用方式非常简单： <code>require(&quot;./stylesheet.css&quot;)</code>。使用步骤如下：</p>
<ul>
<li><p>安装<br>首先从 <code>npm</code> 上下载 <code>loaders</code><br><code>npm install style-loader css-loader --save-dev</code></p>
</li>
<li><p>配置<br>下面是一个配置参考：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">"style-loader!css-loader"</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对于一些需要编译的 css 样式，可以参考相对应的 loader 的配置例子，然后链式调用它们。</p>
</blockquote>
<p>需要记住的是我们很难管理模块的执行顺序，所以最好设计好样式表使得顺序无关紧要。（在一个 css 文件中，顺序还是可靠的。）</p>
</li>
<li><p>使用<br>使用非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your modules just require the stylesheet</span></span><br><span class="line"><span class="comment">// This has the side effect that a &lt;style&gt;-tag is added to the DOM.</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./stylesheet.css"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>独立的样式打包</strong><br>结合使用 <a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a> 这个插件，可以产生一个本地的 css 输出文件。<br>结合代码分割，我们可以使用两种不同的模式：</p>
<ul>
<li>针对每一个初始 chunk 都创建一个 css 文件， 将样式表内嵌至附加的 chunk 中。（推荐做法）</li>
<li>针对每一个初始 chunk 都创建一个 css 文件，并且这个文件中包含了附加 chunk 的样式。  </li>
</ul>
<p>从初始加载速度优化的角度考虑，推荐使用第一种模式。因为缓存和 http 请求头的原因，在一些具有多个入口点的小型应用中，第二种模式可能会更好一些。</p>
<p>步骤如下：</p>
<ul>
<li><p>安装插件<br> <code>npm install extract-text-webpack-plugin --save</code></p>
</li>
<li><p>处理初始 chunk 中的样式生成分离的 css 文件输出<br> 下面展示的虽然是多个入口点的例子，但是这种方式也适合单个入口点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// The standard entry point and output config</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        posts: <span class="string">"./posts"</span>,</span><br><span class="line">        post: <span class="string">"./post"</span>,</span><br><span class="line">        about: <span class="string">"./about"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].js"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            <span class="comment">// Extract css files</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// Optionally extract less files</span></span><br><span class="line">            <span class="comment">// or any other compile-to-css language</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(<span class="string">"style-loader"</span>, <span class="string">"css-loader!less-loader"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// You could also use other loaders the same way. I. e. the autoprefixer-loader</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Use the plugin to specify the resulting filename (and add needed behavior to the compiler)</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你会得到如下文件：</p>
<ul>
<li><code>posts.js  posts.css</code></li>
<li><code>post.js  post.css</code></li>
<li><code>about.js  about.css</code></li>
<li><code>1.js  2.js</code>（包含内嵌样式）</li>
</ul>
</li>
<li><p>所有样式都具有各自的 css 输出文件<br>利用第二种模式，只需要将 <code>allChunks</code> 选项设置成 <code>true</code> 即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"style.css"</span>, &#123;</span><br><span class="line">            allChunks: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将得到如下文件：</p>
<ul>
<li><code>posts.js  posts.css</code></li>
<li><code>post.js  post.css</code></li>
<li><code>about.js  about.css</code></li>
<li><code>1.js  2.js</code>（不包含内嵌样式）</li>
</ul>
</li>
<li><p>在 commons chunk 中的样式<br>可以结合利用 <code>CommonsChunkPlugin</code> 及分离的样式文件来为 commons chunk 生成样式文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">"commons"</span>, <span class="string">"commons.js"</span>),</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后将得到如下输出文件：</p>
<ul>
<li><code>commons.js  commons.css</code></li>
<li><code>posts.js  posts.css</code></li>
<li><code>post.js  post.css</code></li>
<li><code>about.js  about.css</code></li>
<li><code>1.js  2.js</code>（包含内嵌样式）<br>  或者设置 <code>allChunks: true</code>，得到</li>
<li><code>1.js 2.js</code>（不包含内嵌样式）</li>
</ul>
<hr>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>压缩</strong><br>为了压缩文件中的 JavaScript（如果用了 css-loader，css 文件也可以），webpack 提供了一个简单的选项：<br><code>--optimize-minimize</code> 对应于：<code>new webpack.optimize.UglifyJsPlugin()</code><br>这是一个简单而有效的优化网页应用的方法。<br>你应该知道（如果你看过之前的文档）在 webpack 中是通过给 chunk 和模块赋予 id 的方式来辨别它们的。通过一个选项， webpack 可以分辨 id 的分布，并将具有较小长度的 id 分配给这些模块或者 chunk：<br><code>--optimize-occurrence-order</code> 对应于：<code>new webpack.optimize.OccurrenceOrderPlugin()</code><br>在对文件体积的影响程度上，入口 chunk 具有更高的优先级。</p>
<p><strong>去重</strong><br>如果你使用了一些拥有不错的依赖关系的库，那么在打包的过程中就可能会产生一些完全相同的文件。webpack 可以识别这些文件，然后删除重复的。在运行环境下通过利用函数替代重复代码的方式，从而避免打包文件中包含重复代码文件。这对语义化不会有什么影响。可以通过下面的方式来实现这个功能：<br><code>--optimize-dedupe</code> 对应于：<code>new webpack.optimize.DedupePlugin()</code><br>利用这种特性的时候会在入口 chunk 中引入一些额外的代码。</p>
<p><strong>Chunks</strong><br>在编写代码的时候，为了达到按需加载的目的，你可能已经设定好了一些代码分割点。但是在编译之后，你可能会发现产生了非常多的很小的 chunk，这会导致 HTTP 请求头数据量非常大。不过不用担心，通过以下两项设置，我们可以在 webpack 中利用合并的方式来处理这些 chunks：</p>
<ul>
<li>限制允许存在的 chunk 的数量（比如15个）： <code>--optimize-max-chunks 15  new webpack.optimize.LimitChunkPlugin({maxChunks: 15})</code></li>
<li>限制允许存在的 chunk 的最小体积（比如 10000）：<code>--optimize-min-chunk-size 10000 new webpack.optimize.MinChunkSizePlugin({minChunkSize: 10000})</code><br>webpack 会通过合并的方式来处理这些 chunk（会优先处理具有重复模块的 chunk）。任何 chunk 都不会被合并到入口 chunk 中，这主要是为了避免影响到初始页面加载的时间。</li>
</ul>
<p><strong>单页应用</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;单页应用是一种网页应用，webpack 的设计和优化就是为了这种应用。<br>&nbsp;&nbsp;&nbsp;&nbsp;你可能会将应用分解成很多 chunks， 这些 chunks 会在路由中加载。入口 chunk 中包含了路由和一些库，但是没有其他内容。当用户只通过导航来使用应用的时候，这种方式非常好，但是对于初始页面的加载，你需要两个完整的数据来回：一个是路由数据，一个是当前的页面数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你利用 HTML5 History API 来识别 URL 中的当前页面信息，那么服务器可以根据客户端的代码来判断被请求的页面。为了将往返数据保存起来在服务器中，你可以将内容代码包含在响应中：这可以通过增加 <code>script</code> 标签来达到。浏览器将并行加载所有的 chunks。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"entry-chunk.js"</span> type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="3.chunk.js" type="text/</span>javascript<span class="string">" charset="</span>utf<span class="number">-8</span><span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可以从数据中提取 chunk 的文件名（利用 <a href="https://www.npmjs.com/package/stats-webpack-plugin" target="_blank" rel="noopener">stats-webpack-plugin </a>插件可以输出创建的数据）</p>
<p><strong>多页应用</strong><br>当你在编译一个（真正的）多页应用时，你会希望不能的页面能共享公用代码。实际上利用 webpack 是非常容易实现的：只需要在编译的时候提供多个入口点：<br><code>webpack p1=./page1 p2=./page2 p3=./page3 [name].entry-chunk.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].entry.chunk.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会产生多个入口 chunk：<code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> 以及 <code>p3.entry.chunk.js</code>。额外的 chunk 将会被共享。<br>如果你的入口 chunks 中有一些模块是一样的，那么可以使用一个很好的插件：<code>CommonsChunkPlugin</code>，它可以识别这些模块然后将它们生成一个 commons chunk。这时候就需要引用两个 <code>script</code> 标签了，一个用于引入 commons chunk，一个用于引入入口 chunk。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].entry.chunk.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.chunk.js"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会产生多个入口文件：<code>p1.entry.chunk.js</code>, <code>p2.entry.chunk.js</code> 以及 <code>p3.entry.chunk.js</code>，同时还有 <code>commons.chunk.js</code>。加载的时候先加载 <code>commons.chunk.js</code> 然后再加载任一入口 chunk。<br>你可以通过选择不同的入口 chunk 来生成多个 commons chunk，而且也可以将这些 commons chunk 嵌套。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        p3: <span class="string">"./page3"</span>,</span><br><span class="line">        ap1: <span class="string">"./admin/page1"</span>,</span><br><span class="line">        ap2: <span class="string">"./admin/page2"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"admin-commons.js"</span>, [<span class="string">"ap1"</span>, <span class="string">"ap2"</span>]),</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons.js"</span>, [<span class="string">"p1"</span>, <span class="string">"p2"</span>, <span class="string">"admin-commons.js"</span>])</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// &lt;script&gt;s required:</span></span><br><span class="line"><span class="comment">// page1.html: commons.js, p1.js</span></span><br><span class="line"><span class="comment">// page2.html: commons.js, p2.js</span></span><br><span class="line"><span class="comment">// page3.html: p3.js</span></span><br><span class="line"><span class="comment">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span></span><br><span class="line"><span class="comment">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span></span><br></pre></td></tr></table></figure></p>
<p>高级用法：可以在 commons chunk 内部运行代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonsChunkPlugin = <span class="built_in">require</span>(<span class="string">"webpack/lib/optimize/CommonsChunkPlugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        p1: <span class="string">"./page1"</span>,</span><br><span class="line">        p2: <span class="string">"./page2"</span>,</span><br><span class="line">        commons: <span class="string">"./entry-for-the-commons-chunk"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CommonsChunkPlugin(<span class="string">"commons"</span>, <span class="string">"commons.js"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更多阅读： <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-entry-points" target="_blank" rel="noopener">multiple-entry-points example</a> 以及 <a href="https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks" target="_blank" rel="noopener">advanced multiple-commons-chunks example</a>。</p>
<hr>
<h3 id="长期缓存"><a href="#长期缓存" class="headerlink" title="长期缓存"></a>长期缓存</h3><p>为了有效的缓存你的文件，它们应该在 URL 上有一个哈希值或者版本号。当然了，你可以手动的创建或者移动这些输出文件到一个版本号为 <code>v1.3</code> 的文件夹中。但是这么做有一些缺点：给开发者来带额外的工作，而且未更改的文件不会从缓存加载。<br>webpack 可以为文件的文件名加上哈希值。 那些能够产生输出文件的 Loaders（比如 worker-loader， file-loader）已经在这么做了。对于 chunk 而言，我们必须使它具有这种功能。有两种选择：</p>
<ul>
<li>为所有的 chunks 计算出一个哈希值并标记上</li>
<li>为每一个 chunk 计算一个哈希值并标记上</li>
</ul>
<p>下面针对这两种情况说明：</p>
<ul>
<li><p>选择一：一次打包一个哈希值<br> 只需要将 <code>[hash]</code> 增加到文件名配置选项：<br>  <code>webpack ./entry output.[hash].bundle.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join( __dirname, <span class="string">"assets"</span>, <span class="string">"[hash]"</span>),</span><br><span class="line">        publicPath: <span class="string">"assets/[hash]"</span>,</span><br><span class="line">        filename: <span class="string">"output.[hash].bundle.js"</span>,</span><br><span class="line">        chunkFilename: <span class="string">"[id].[hash].bundle.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择二：每个 chunk 一个哈希值<br>只需要将 <code>[chunkhash]</code> 增加到 chunk 文件名配置选项中：<br><code>--output-chunk-file [chunkhash].js</code><br><code>output: { chunkFilename: &quot;[chunkhash].bundle.js&quot; }</code><br>需要注意的是，在 HTML 文件中引用入口 chunk 的时候也需要带有哈希值。你应该会希望从数据中直接提取哈希值或者是文件名。如果你结合使用 <code>Hot Code Replacement</code>，你就只能使用第一种方式，并且不包括 <code>publicPath</code> 配置选项。</p>
</li>
<li><p>从数据中获取文件名<br>你可能会想获取文件的最终文件名用于插入到 HTML 文件中。通过 webpack 这是可以做到的。如果你在使用 <code>CLI</code>，你可以在运行它的时候加上 <code>--json</code>，从而会输出标准的 JSON 文件。<br>你也可以通过在配置表中增加一个插件，比如 <a href="https://www.npmjs.com/package/assets-webpack-plugin" target="_blank" rel="noopener"> assets-webpack-plugin</a> 来访问数据对象。下面是将具体的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.plugin(<span class="string">"done"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">stats</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">require</span>(<span class="string">"fs"</span>).writeFileSync(</span><br><span class="line">        path.join(__dirname, <span class="string">".."</span>, <span class="string">"stats.json"</span>),</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(stats.toJson()));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这个 JSON 数据包含了一个非常有用的特性：<code>assetsByChunkName</code>， 这是一个对象，这个对像里面的键为 chunk 的名字，键值为文件的名字。</p>
<blockquote>
<p>注意：如果每个 chunk 生成的是多个文件，比如一个 JavaScript 文件 一个 SourceMap， 那么这个特性就是个数组。数组中的第一个对应于 JavaScript。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="编写-loader"><a href="#编写-loader" class="headerlink" title="编写 loader"></a>编写 loader</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Loader 就是输出一个函数的 node 模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;当有资源需要被这个 loader 转化的时候，这个函数就会被调用了。<br>&nbsp;&nbsp;&nbsp;&nbsp;在简单的例子中，当只有一个 loader 作用在待处理资源上的时候，调用 loader 时就只有一个参数：字符串形式的资源文件的内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;loader 可以通过在函数中的 this 格式来访问 <a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">loader API</a>。<br>&nbsp;&nbsp;&nbsp;&nbsp;一个同步的 loader 如果只想得到一个数值，那么直接用 return 返回就行了。除此之外，loader 可以通过 <code>this.callback(err. values...)</code> 函数来返回任意多的数值。错误会被传入到 <code>this.callback</code> 函数中或者被传入到同步的 loader 中。<br>&nbsp;&nbsp;&nbsp;&nbsp;一般来说我们都希望 loader 能够返回一到两个数据。第一个是缓存或者字符串形式的 JavaScript 代码，第二个数据是 JavaScript 对象格式的 SourceMap。<br>&nbsp;&nbsp;&nbsp;&nbsp;在比较附在的情况下，会组合使用到多个 loader，这时候只有最后的 loader 能够接触到源文件，同时也只有最开始的 loader 能够返回一到两个数据（JavaScript 代码及 SourceMap）（注：因为链式调用的时候是从右到左调用的）。其他的 loader 返回的数据都是传入到前一个 loader 中。</p>
<p><strong>例子</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Identity loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Identity loader with SourceMap support</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, source, map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong><br>    loaders 应该（按照优先级排序，第一个应该享有最高的优先级）</p>
<ul>
<li>只完成单一任务<br>  loaders 是可以链式调用的，应该每一步都使用一个 loader 而不是让一个 loader 完成所有的事情。<br>  这也意味着如果不是必须的话就不应该转化成 JavaScript。<br>  例如：通过应用查询参数的方式从模板中渲染出 HTML：<br>  我们可以写一个 loader， 它可以从原文件中编译模板，然后执行它并返回一个能够输出带有 HTML 代码的字符串的模块。但这种做法不推荐。<br>  我们应该为每一个任务写一个 loader，然后链式调用它们：<ul>
<li>jade-loader：将模板转化成一个能返回函数的模块</li>
<li>apply-loader：接收一个函数并通过应用查询参数返回原生结果</li>
<li>html-loader： 接收 HTML 并且输出字符串</li>
</ul>
</li>
</ul>
<ul>
<li><p>生成的模块应该是模块化的<br>  通过 loader 生产的模块应该遵循和普通模块一样的设计原则。<br>  例如：这是一个不好的设计：（没有模块化，全局声明……）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"any-template-language-loader!./xyz.atl"</span>);</span><br><span class="line"><span class="keyword">var</span> html = anyTemplateLanguage.render(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量标明是可缓存的<br>  大部分的 loader 都是可缓存的，所以它们应该也标明是可缓存的。<br>  只需要在 loader 中调用 <code>cacheable</code>：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cacheable identity loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注明依赖<br>  如果 loader 需要利用外部资源（比如需要读取文档系统），那么就 <strong>必须</strong> 要注明。这个信息可以用来使可缓存的 loader 无效，也会使得在监控模式下重编译。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loader adding a header</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">    <span class="keyword">var</span> headerPath = path.resolve(<span class="string">"header.js"</span>);</span><br><span class="line">    <span class="keyword">this</span>.addDependency(headerPath);</span><br><span class="line">    fs.readFile(headerPath, <span class="string">"utf-8"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, header</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> callback(err);</span><br><span class="line">        callback(<span class="literal">null</span>, header + <span class="string">"\n"</span> + source);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分解依赖<br>  在很多语言中都有规范依赖的方法，比如在 css 中有 <code>@import</code> 以及 <code>url(...)</code> 的方式。模块系统应该能够分解这些依赖。<br>  有两种选择可达到这种目的：</p>
<ul>
<li>将它们转化成 <code>require</code></li>
<li>利用 <code>this.resolve()</code> 函数来分解路径<br>  举例一：css-loader。 css-loader 将依赖转化成 <code>require</code>，具体方式是利用 <code>require</code> 样式（也会被 css-loader 处理）来替代 <code>@import</code>，同时也利用 <code>require</code> 相关文件来替代 <code>url(...)</code> 引用。<pre><code>如果这个语言只接受相对路径（比如在 css 中： `url(file)` 一般表示 `./file`），那么就可以通过 `~` 符号来将特定的引用传送给模块，如下所示：
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(file) -&gt; <span class="built_in">require</span>(<span class="string">"./file"</span>)</span><br><span class="line">url(~<span class="built_in">module</span>) -&gt; <span class="built_in">require</span>(<span class="string">"module"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>提取公用代码<br>  不要在利用同一个 loader 处理的每个模块中提取太多公用代码。在 loader 中创建一个（运行环境下的）文件，并利用一个 <code>require</code> 来引用公用代码。</p>
</li>
<li><p>不要内嵌绝对路径<br>  不要将绝对路径写入到模块代码中，因为如果项目移动位置的话会破坏路径的哈希值。在<a href="https://github.com/webpack/loader-utils#stringifyrequest" target="_blank" rel="noopener">loader-utils</a> 中有一个 <code>stringifyRequest</code> 方法，可以将绝对路径转化为相对路径。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">"loader-utils"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"var runtime = require("</span> +</span><br><span class="line">loaderUtils.stringifyRequest(<span class="keyword">this</span>, <span class="string">"!"</span> + <span class="built_in">require</span>.resolve(<span class="string">"module/runtime"</span>)) +</span><br><span class="line"><span class="string">");"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用库作为 <code>peerDependencies</code><br>  当使用库作为同级依赖的时候，如果需要，应用的开发者可以在配置文件 <code>package.json</code> 中明确的指出所依赖库的版本。这种依赖应该在不需要重新发布新版本号的 loader 的情况下能升级。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"peerDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"libraay"</span>: <span class="string">"^1.3.5"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多关于 <a href="http://webpack.github.io/docs/loaders.html" target="_blank" rel="noopener">loaders</a>.</p>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;webpack 文档也看了好几天了，上面翻译的也只是其中一部分内容，看到后面有点不知所云，翻译起来很吃力，有种以其昏昏使人昭昭的感觉。为了不误人子弟，所以决定暂时不再翻译，日后有了更多的理解了再来继续。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果在阅读的过程中发现翻译不妥，欢迎在下方留言或者给我发邮件。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工具 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端面试常见问题整理]]></title>
      <url>http://detachment.club/2016/08/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从开始学习前端到现在已经五个月了，在时间上已经到了该找工作的阶段了，但从目前对前端技能的掌握的层面来说，还离社招的水平有较大一段距离。现实和计划之间永远存在在差距。现在也已经开始投简历了，为了有更好的面试状态同时也检验一下前阶段对知识的掌握程度，特地在网上收集了一些面试资料来借鉴参考。</p>
<a id="more"></a>
<p>注明：</p>
<blockquote>
<p>本文里面的绝大部分问题来自github上<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener">markyun同学的项目</a>，感谢所有为此付出努力的同学们~<br>对于原文中收集的有些问题我看了答案还是不能很理解，或者是有些没有答案的问题，我都做了一些收集并将链接附在了文中，也对这些热爱分享的同学表示感谢~</p>
</blockquote>
<h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h3 id="DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？"><a href="#DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？" class="headerlink" title="DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？"></a>DOCTYPE的作用是什么？兼容模式与标准模式各有什么区别？</h3><blockquote>
<p> &lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 <html> 标签之前；它不是 HTML 标签；而是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。其中DTD指的是：document type definition; SGML指的是 Standard Generalized Markup Language;</html></p>
<p> <a href="https://www.zhihu.com/question/20249139" target="_blank" rel="noopener">然后，为什么HTML5不再基于SGML？</a></p>
<p> 标准模式及兼容模式：标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p>
</blockquote>
<h3 id="行内元素有哪些？块级元素有哪些？空元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？空元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？空元素有哪些？"></a>行内元素有哪些？块级元素有哪些？空元素有哪些？</h3><blockquote>
<p>行内元素：a b span img input select strong；<br>块级元素有：div ul ol li dl dt dd h1 p;<br>常见的空元素：br hr img input link meta;</p>
</blockquote>
<h3 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h3><blockquote>
<p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;<br>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p>
<p><a href="http://www.daqianduan.com/2417.html" target="_blank" rel="noopener">更详细的区别戳我~</a></p>
</blockquote>
<h3 id="常见的浏览器内核有几种？"><a href="#常见的浏览器内核有几种？" class="headerlink" title="常见的浏览器内核有几种？"></a>常见的浏览器内核有几种？</h3><blockquote>
<p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p>
<p>补充：浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<p><a href="http://web.jobbole.com/84826/" target="_blank" rel="noopener">想了解浏览器内核历史的，戳我~</a></p>
</blockquote>
<h3 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><blockquote>
<p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>      绘画 canvas;<br>      用于媒介回放的 video 和 audio 元素;<br>      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;<br>      sessionStorage 的数据在浏览器关闭后自动删除;<br>      语意化更好的内容元素，比如 article、footer、header、nav、section;<br>      表单控件，calendar、date、time、email、url、search;<br>      新的技术webworker, websocket, Geolocation;</p>
</blockquote>
<blockquote>
<p> 移除的元素：<br>      纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>      对可用性产生负面影响的元素：frame，frameset，noframes；</p>
</blockquote>
<blockquote>
<p>支持HTML5新标签：<br>     IE8/IE7/IE6支持通过document.createElement方法产生的标签，<br>     可以利用这一特性让这些浏览器支持HTML5新标签，<br>     浏览器支持新标签后，还需要添加标签默认的样式。</p>
</blockquote>
<blockquote>
<p> 当然也可以直接使用成熟的框架、比如html5shim;<br>   <code>&lt;script&gt;src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</code></p>
</blockquote>
<blockquote>
<p>如何区分HTML5： DOCTYPE声明或新增的结构元素或功能元素；</p>
</blockquote>
<h3 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h3><blockquote>
<p>总结起来为：用正确的标签做正确的事情。</p>
<ol>
<li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li>
<li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li>
<li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
</ol>
</blockquote>
<h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><blockquote>
<p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<ul>
<li>存储大小：<br>  cookie数据大小不能超过4k。<br>  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
<li>有期时间：<br>  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>  sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
<p><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">更多关于Cooikes信息，戳我~</a></p>
</blockquote>
<h3 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h3><blockquote>
<ul>
<li>iframe会阻塞主页面的Onload事件；</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO;</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
<li>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</li>
</ul>
<p><a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">想看使用iframe的好处的，戳我~</a></p>
</blockquote>
<h3 id="Label的作用是什么？是怎么用的？"><a href="#Label的作用是什么？是怎么用的？" class="headerlink" title="Label的作用是什么？是怎么用的？"></a>Label的作用是什么？是怎么用的？</h3><blockquote>
<p>label 元素不会向用户呈现任何特殊的样式。不过，它为鼠标用户改善了可用性，因为如果用户点击 label 元素内的文本，则会切换到控件本身。label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。<br><strong>本题考察的是HTML5新标签的用法，可推广到所有其他标签的常规使用，应举一反三。</strong></p>
</blockquote>
<h3 id="页面可见性（Page-Visibility-API）可以有什么用途？"><a href="#页面可见性（Page-Visibility-API）可以有什么用途？" class="headerlink" title="页面可见性（Page Visibility API）可以有什么用途？"></a>页面可见性（Page Visibility API）可以有什么用途？</h3><blockquote>
<p>可通过检测visibilityState的值检测页面是否可见，以及打开网页的时间等；<br>在页面被切换到后台进程的时候，自动暂停音乐或者视频的播放；</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="noopener">想了解更多信息，戳我~</a></p>
</blockquote>
<h3 id="如何在页面实现一个圆形的可点击区域？"><a href="#如何在页面实现一个圆形的可点击区域？" class="headerlink" title="如何在页面实现一个圆形的可点击区域？"></a>如何在页面实现一个圆形的可点击区域？</h3><blockquote>
<ol>
<li>map+area或者svg <a href="http://www.w3school.com.cn/tags/att_area_coords.asp" target="_blank" rel="noopener">具体实现方式，戳我~</a></li>
<li>border-radius</li>
<li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等；</li>
</ol>
</blockquote>
<h3 id="网页验证码是干嘛的？是为了解决什么安全问题？"><a href="#网页验证码是干嘛的？是为了解决什么安全问题？" class="headerlink" title="网页验证码是干嘛的？是为了解决什么安全问题？"></a>网页验证码是干嘛的？是为了解决什么安全问题？</h3><blockquote>
<p>是为了区分用户是计算机还是人类的公共自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>也可以有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p>
<p><a href="https://www.zhihu.com/question/19563610" target="_blank" rel="noopener">据说谷歌还利用验证码来完成古籍文字的识别，戳我~</a></p>
</blockquote>
<h3 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h3><blockquote>
<ul>
<li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li>
<li>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时strong会重读，而B是展示强调内容。</li>
<li>i内容展示为斜体，em表示强调的文本；</li>
<li>Physical Style Elements – 自然样式标签<br>  b, i, u, s, pre</li>
<li>Semantic Style Elements – 语义样式标签<br> strong, em, ins, del, code<br> 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</li>
</ul>
</blockquote>
<hr>
<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><blockquote>
<p>（1）有两种， IE 盒子模型、W3C 盒子模型；<br>（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>（3）区  别： IE的content部分把 border 和 padding计算了进去;<br>(其实更准确的说法应该是本来width值指的是内容区域，而在IE5，6版本中，width值包括padding和border。content部分一直都是content部分。)</p>
<p><a href="http://www.w3school.com.cn/css/css_boxmodel.asp" target="_blank" rel="noopener">想知道详细内容？戳我~</a></p>
</blockquote>
<h3 id="CSS选择符有哪些？哪些属性可以继承？"><a href="#CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择符有哪些？哪些属性可以继承？"></a>CSS选择符有哪些？哪些属性可以继承？</h3><blockquote>
<ol>
<li>id选择器（ # myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div, h1, p）</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（ * ）</li>
<li>属性选择器（a[rel = “external”]）</li>
<li>伪类（a:hover, li:nth-child）</li>
<li>伪元素(:before, :after, :first-line, first-letter)</li>
</ol>
<ul>
<li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li>
<li>不可继承的样式：border padding margin width height ;</li>
</ul>
<p><a href="http://www.cnblogs.com/rubylouvre/archive/2009/09/04/1559557.html" target="_blank" rel="noopener">想知道更全面的可继承与不可继承属性？戳我~</a></p>
</blockquote>
<h3 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h3><blockquote>
<p>优先级就近原则，同权重情况下样式定义最近者为准;<br>载入样式以最后载入的定位为准;<br>优先级为：!important &gt;  id &gt; class &gt; tag  其中important比内联样式优先级高。</p>
</blockquote>
<h3 id="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h3><blockquote>
<p>由于本问题涉及较多代码，希望知道详细解释的，<a href="http://www.w3cplus.com/css/elements-horizontally-center-with-css.html" target="_blank" rel="noopener">直接戳我就好了~</a></p>
</blockquote>
<h3 id="display有哪些值？他们的作用分别是？"><a href="#display有哪些值？他们的作用分别是？" class="headerlink" title="display有哪些值？他们的作用分别是？"></a>display有哪些值？他们的作用分别是？</h3><blockquote>
<p>block         象块类型元素一样显示。<br>  none          缺省值。象行内元素类型一样显示。<br>  inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。<br>  list-item     象块类型元素一样显示，并添加样式列表标记。<br>  table         此元素会作为块级表格来显示<br>  inherit       规定应该从父元素继承 display 属性的值</p>
<p><a href="http://www.w3school.com.cn/cssref/pr_class_display.asp" target="_blank" rel="noopener">更多详细内容，戳我~</a></p>
</blockquote>
<h3 id="CSS3中有哪些新特征？"><a href="#CSS3中有哪些新特征？" class="headerlink" title="CSS3中有哪些新特征？"></a>CSS3中有哪些新特征？</h3><blockquote>
<p>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）<br>  圆角           （border-radius:8px）<br>  多列布局        （multi-column layout）<br>  阴影和反射        （Shadow, Reflect）<br>  文字特效      （text-shadow、）<br>  文字渲染      （Text-decoration）<br>  线性渐变      （gradient）<br>  旋转          （transform）<br>  增加了旋转,缩放,定位,倾斜,动画，多背景<br>  transform:scale(0.85,0.90), translate(0px,-30px), skew(-9deg,0deg), Animation:</p>
<p><a href="http://www.w3school.com.cn/css3/css3_border.asp" target="_blank" rel="noopener">个人认为上面的分类不够系统，戳我了解更多~</a></p>
</blockquote>
<h3 id="用纯CSS创建一个三角形的原理是什么？"><a href="#用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="用纯CSS创建一个三角形的原理是什么？"></a>用纯CSS创建一个三角形的原理是什么？</h3><blockquote>
<p>原理很简单，就是将一个div的宽高设置成0，然后根据不同的需求设置div的border属性，从而能够得到各种三角形。</p>
<p><a href="http://www.zhangxinxu.com/wordpress/2010/05/css-border%E4%B8%89%E8%A7%92%E3%80%81%E5%9C%86%E8%A7%92%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">更详细的说明，戳我~</a></p>
</blockquote>
<h3 id="解释一下CSS3中Flex-box以及使用场景？"><a href="#解释一下CSS3中Flex-box以及使用场景？" class="headerlink" title="解释一下CSS3中Flex-box以及使用场景？"></a>解释一下CSS3中Flex-box以及使用场景？</h3><blockquote>
<p>box-flex 属性规定框的子元素是否可伸缩其尺寸。可伸缩元素能够随着框的缩小或扩大而缩写或放大。只要框中有多余的空间，可伸缩元素就会扩展来填充这些空间。目前浏览器使用这个属性时都需要加前缀，比如Firefox 支持替代的 -moz-box-flex 属性，Safari、Opera 以及 Chrome 支持替代的 -webkit-box-flex 属性。</p>
<p><a href="http://www.w3school.com.cn/cssref/pr_box-flex.asp" target="_blank" rel="noopener">更多详细内容，戳我~</a></p>
</blockquote>
<h3 id="常见的浏览器兼容性问题有哪些？原因及解决方法是什么？"><a href="#常见的浏览器兼容性问题有哪些？原因及解决方法是什么？" class="headerlink" title="常见的浏览器兼容性问题有哪些？原因及解决方法是什么？"></a>常见的浏览器兼容性问题有哪些？原因及解决方法是什么？</h3><blockquote>
<p><a href="http://www.cnblogs.com/jscode/archive/2012/07/10/2583856.html" target="_blank" rel="noopener">问题范围太大了，想详细了解的戳我~</a><br><br><a href="https://www.zhihu.com/question/28954391" target="_blank" rel="noopener">然后，戳我了解更多~</a></p>
</blockquote>
<h3 id="为什么要初始化CSS样式？"><a href="#为什么要初始化CSS样式？" class="headerlink" title="为什么要初始化CSS样式？"></a>为什么要初始化CSS样式？</h3><blockquote>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
<p><a href="http://www.cnblogs.com/xiangzi888/archive/2011/09/21/2184442.html" target="_blank" rel="noopener">各大厂详细的初始化方案，戳我~</a></p>
</blockquote>
<h3 id="在CSS中position，display和float有什么关系？"><a href="#在CSS中position，display和float有什么关系？" class="headerlink" title="在CSS中position，display和float有什么关系？"></a>在CSS中position，display和float有什么关系？</h3><blockquote>
<p><a href="http://www.w3cfuns.com/notes/16548/6c7c4a0e6fe54320bfeb26fdc1e08ca1.html" target="_blank" rel="noopener">由于这个问题比较复杂，他们之间的详细的关系可以戳我~</a><br><a href="https://www.zhihu.com/question/19588854" target="_blank" rel="noopener">或者戳我~</a><br><a href="http://detachment.club/2016/06/27/Float,%20position%20and%20display%20in%20CSS/">还有我~</a></p>
</blockquote>
<h3 id="CSS声明的权重是怎样的？"><a href="#CSS声明的权重是怎样的？" class="headerlink" title="CSS声明的权重是怎样的？"></a>CSS声明的权重是怎样的？</h3><blockquote>
<p>CSS声明的权重指的是优先级，由选择器中的每一种选择器类型的数值决定，当数值相等时，css中最后的那个声明将作用到元素上。权重数值如下：<br>0 . 元素(类型)选择器（type selectors）（例如：h1）和 伪元素选择器（pseudo-elements）（例如：:before）<br>1 . 类选择器（class selectors） (例如：.example)，属性选择器（attributes selectors）（例如：[type=”radio”]），伪类选择器（pseudo-classes）（例如：:hover）<br>2 . ID选择器（例如：#example）<br>通用选择器（universal selector）(*),组合符合（combinators） (+, &gt;, ~, ‘ ‘)  和 否定伪类（negation pseudo-class）(:not()) 不会影响优先级（但是，在 :not() 内部声明的选择器是会影响优先级的）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">详细信息戳我~</a></p>
</blockquote>
<h3 id="清除浮动有几种方式？优缺点有哪些？"><a href="#清除浮动有几种方式？优缺点有哪些？" class="headerlink" title="清除浮动有几种方式？优缺点有哪些？"></a>清除浮动有几种方式？优缺点有哪些？</h3><blockquote>
<ol>
<li>最后增加一个清除浮动的子元素,缺点是会增加一个DOM节点;</li>
<li>同样可以在最后增加一个清除浮动的br,语义上比空的div标签稍微好一点，但同样会增加一个DOM节点;</li>
<li>父元素设置 overflow:hidden（如果你还要兼顾IE6的话，加上*zoom:1;来触发hasLayout）;</li>
<li>将父元素设置 的overflow:hidden改成auto;</li>
<li>父元素也设成float;</li>
<li>父元素设置display:table;</li>
<li>用:after伪元素，思路是用:after元素在div后面插入一个隐藏文本”.”，隐藏文本用clear来实现闭合浮动：</li>
</ol>
<p><a href="http://www.jianshu.com/p/07eb19957991#" target="_blank" rel="noopener">原文链接，戳我~</a></p>
</blockquote>
<h3 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h3><blockquote>
<p>总的来说，浏览器是遵循从右到左的顺序来解析CSS选择器的，这样解析的效率最高。<br><br><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="noopener">想知道详细解释的，戳我</a><br><br><a href="https://segmentfault.com/q/1010000000713509" target="_blank" rel="noopener">然后也可以戳我~</a></p>
</blockquote>
<h3 id="CSS优化、提高性能的方法有哪些？"><a href="#CSS优化、提高性能的方法有哪些？" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h3><blockquote>
<p><a href="http://www.zhihu.com/question/19886806" target="_blank" rel="noopener">问题比较笼统，较详细的解释可戳我~</a></p>
</blockquote>
<h3 id="在网页中较多的使用奇数号字体还是偶数号字体？为什么？"><a href="#在网页中较多的使用奇数号字体还是偶数号字体？为什么？" class="headerlink" title="在网页中较多的使用奇数号字体还是偶数号字体？为什么？"></a>在网页中较多的使用奇数号字体还是偶数号字体？为什么？</h3><blockquote>
<p>首先答案是较多的使用偶数号字体，具体原因点下面的链接。</p>
<p><a href="https://www.zhihu.com/question/20440679" target="_blank" rel="noopener">为什么网页多使用偶数号字体？</a></p>
</blockquote>
<h3 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h3><blockquote>
<p>如果是定位元素，则相对的是容器的高度；而如果是内外边距，那么相对的则是容器的宽度。</p>
</blockquote>
<h3 id="从输入URL到页面加载完成的过程中都发生了什么事情？"><a href="#从输入URL到页面加载完成的过程中都发生了什么事情？" class="headerlink" title="从输入URL到页面加载完成的过程中都发生了什么事情？"></a>从输入URL到页面加载完成的过程中都发生了什么事情？</h3><blockquote>
<p><a href="http://yuehu.io/padding-me/406" target="_blank" rel="noopener">这篇文章写得非常详细，戳我阅读~</a></p>
</blockquote>
<h3 id="如何修改chrome记住密码后自动填充表单的黄色背景-？"><a href="#如何修改chrome记住密码后自动填充表单的黄色背景-？" class="headerlink" title="如何修改chrome记住密码后自动填充表单的黄色背景 ？"></a>如何修改chrome记住密码后自动填充表单的黄色背景 ？</h3><blockquote>
<p><em>我觉着这种问题不是太适合面试，没有尝试过的同学估计很难知道具体的修改方式</em></p>
<p><a href="http://zcoder.cn/2015/01/14/front-end/chrome-autofill/" target="_blank" rel="noopener">想了解具体的修改方式，戳我~</a></p>
</blockquote>
<h3 id="什么是CSS-预处理器-后处理器？"><a href="#什么是CSS-预处理器-后处理器？" class="headerlink" title="什么是CSS 预处理器/后处理器？"></a>什么是CSS 预处理器/后处理器？</h3><blockquote>
<p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，<br>  还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。<br>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
</blockquote>
<hr>
<h2 id="JavaScript-部分"><a href="#JavaScript-部分" class="headerlink" title="JavaScript 部分"></a>JavaScript 部分</h2><h3 id="介绍JS中的基本数据类型。"><a href="#介绍JS中的基本数据类型。" class="headerlink" title="介绍JS中的基本数据类型。"></a>介绍JS中的基本数据类型。</h3><blockquote>
<p>一般来说分为两种，分别为基本类型和对象类型，其中基本类型包括undefined, null, Boolean, Number, String, Symbol，对象类型即为Object。</p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">MDN中关于JS基本数据类型的介绍~</a><br><a href="http://www.cnblogs.com/snandy/archive/2013/01/02/2841899.html" target="_blank" rel="noopener">JS中基本类型之争</a></p>
</blockquote>
<h3 id="JS中有哪些内置对象？"><a href="#JS中有哪些内置对象？" class="headerlink" title="JS中有哪些内置对象？"></a>JS中有哪些内置对象？</h3><blockquote>
<p>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：Object、Array、Boolean、Number 和 String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error</p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">JS中的标准全局对象</a></p>
</blockquote>
<h3 id="说几条JS的基本规范"><a href="#说几条JS的基本规范" class="headerlink" title="说几条JS的基本规范"></a>说几条JS的基本规范</h3><blockquote>
<p>1.不要在同一行声明多个变量。<br>2.请使用 ===/!==来比较true/false或者数值<br>3.使用对象字面量替代new Array这种形式<br>4.不要使用全局函数。<br>5.Switch语句必须带有default分支<br>6.函数不应该有时候有返回值，有时候没有返回值。<br>7.For循环必须使用大括号<br>8.If语句必须使用大括号<br>9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/lxj/javascript.patterns/blob/master/chapter2.markdown" target="_blank" rel="noopener">需要知道更多的要点？ 戳我~</a></p>
</blockquote>
<h3 id="简单解释下JS中的原型及原型链，有什么特点？"><a href="#简单解释下JS中的原型及原型链，有什么特点？" class="headerlink" title="简单解释下JS中的原型及原型链，有什么特点？"></a>简单解释下JS中的原型及原型链，有什么特点？</h3><blockquote>
<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN上关于JS中继承及原型链的解释</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html" target="_blank" rel="noopener">强大的原型及原型链</a></p>
</blockquote>
<h3 id="JS中有几种类型的值？它们之间的区别时是什么？"><a href="#JS中有几种类型的值？它们之间的区别时是什么？" class="headerlink" title="JS中有几种类型的值？它们之间的区别时是什么？"></a>JS中有几种类型的值？它们之间的区别时是什么？</h3><blockquote>
<p>主要有两种，分别为栈和堆；<br>栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br>堆：引用数据类型（对象、数组和函数）</p>
</blockquote>
<blockquote>
<p>两种类型的区别是：存储位置不同；<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
</blockquote>
<h3 id="常见的内存泄露的方式有？如何避免？"><a href="#常见的内存泄露的方式有？如何避免？" class="headerlink" title="常见的内存泄露的方式有？如何避免？"></a>常见的内存泄露的方式有？如何避免？</h3><blockquote>
<p>主要有以下几种方式：</p>
<ol>
<li>意外的全局变量</li>
<li>被遗忘的计时器或回调函数</li>
<li>脱离 DOM 的引用</li>
<li>闭包</li>
</ol>
</blockquote>
<blockquote>
<p><a href="http://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener">关于这个问题的答案，具体解释戳我~</a><br><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="noopener">英文原文链接</a></p>
</blockquote>
<h3 id="JS中怎么实现继承？"><a href="#JS中怎么实现继承？" class="headerlink" title="JS中怎么实现继承？"></a>JS中怎么实现继承？</h3><blockquote>
<p>主要有以下几种：<br>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承</p>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">详细内容戳我~</a></p>
</blockquote>
<h3 id="JS中创建对象有几种方式？"><a href="#JS中创建对象有几种方式？" class="headerlink" title="JS中创建对象有几种方式？"></a>JS中创建对象有几种方式？</h3><blockquote>
<p>常见的创建对象的方式有：</p>
<ol>
<li>直接创建对象；</li>
<li>用构造函数；</li>
<li>用工厂方式；</li>
<li>用原型方式；</li>
<li>用混合方式；</li>
</ol>
</blockquote>
<blockquote>
<p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener">原文链接，戳我直达~</a><br><a href="http://www.yuanlairc.com/program/jsobject.html" target="_blank" rel="noopener">javascript创建对象的几种模式</a></p>
</blockquote>
<h3 id="谈谈对在JS中This的理解"><a href="#谈谈对在JS中This的理解" class="headerlink" title="谈谈对在JS中This的理解"></a>谈谈对在JS中This的理解</h3><blockquote>
<ul>
<li>this总是指向函数的直接调用者（而非间接调用者）；</li>
<li>如果有new关键字，this指向new出来的那个对象；</li>
<li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</li>
</ul>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">Javascript中this的用法 by 阮一峰</a></p>
</blockquote>
<h3 id="null和undefined有什么区别？"><a href="#null和undefined有什么区别？" class="headerlink" title="null和undefined有什么区别？"></a>null和undefined有什么区别？</h3><blockquote>
<p>null最常见的用法表示一个对象被定义了，但值为空值；<br>undefined最常用的用法表示一个对象未被定义或者需要访问的对象的属性不存在；</p>
</blockquote>
<blockquote>
<p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#core.undefined" target="_blank" rel="noopener">undefined和null——《秘密花园》</a><br><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">undefined和null的区别，阮一峰</a></p>
</blockquote>
<h3 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><blockquote>
<p>答案是[1, NaN, NaN]。<br>map方法中的回调函数可以有三个参数来声明，第一个为数组元素的值，第二个为数组元素的数字索引，但三个为包含该元素的数组对象。<br>在这个例子中，回调函数为parseInt，传入参数为待解析字符串及进制数，其中进制数为可选参数。<br>然后在这个，parseInt函数正好将数组元素的数字索引当做进制数来进行运算，所以最终的结果如上所说。</p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000005956935" target="_blank" rel="noopener">想知道更详细的解释？戳我~</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《Bootstrap 初体验》]]></title>
      <url>http://detachment.club/2016/08/09/Bootstrap%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;了解了jQuery的基本语法之后，就开始准备学习Bootstrap框架了。在慕课网上看过姜维老师讲述的<a href="http://www.imooc.com/learn/182" target="_blank" rel="noopener">《基于bootstrap的网页开发》</a>后，真正被Bootstrap的强大功能惊艳到。随后又在网易云课堂接触到李炎恢老师是<a href="http://study.163.com/course/courseMain.htm?courseId=1017002" target="_blank" rel="noopener">《Bootstrap视频教程》</a>，再一次被惊艳。在用一通宵的时间看完李老师的基础教程后，跃跃欲试，然后决定跟着老师的步骤做一个自己的网页。</p>
<a id="more"></a>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;虽说是准备跟着老师做，但也不想完全照搬老师的内容，这时候一转头，正好看到电脑屏幕上电影《Detachment》的截图，瞬间就决定了以此为主题制作网页。<br>&nbsp;&nbsp;&nbsp;&nbsp;由于整体框架和老师是完全一样的，所以制作的过程还算是比较顺利。整个网页大概花费了两天时间，其中有很大一部分时间花在找材料上，而且为了使网页实际体验效果比较好，在需要加链接的地方都尽量贴上了链接。做完以后面临的一个问题就是怎么展示这些网页，自己看的话在本地当然没有问题，但是如果要和别人分享的话，最好还是放在网上。为了达到这个目的，尝试了三个方法：</p>
<ol>
<li>购买域名，部署网站；工作量较大，涉及到前后端的知识，稍微尝试了一下后放弃此方案；</li>
<li>结合博客展示；在博客中新建了一个页面展示，但是文件格式是<code>.md</code>的，而且展示的时候博客的固定框架仍在，影响美观，随放弃；</li>
<li>利用在线编辑器Codepen；只需将其中一个页面布置到codepen中，另外的几个页面通过外链（七牛云）的方式链接到主页面即可，方法可行且十分方便，以后都可以类似处理；</li>
</ol>
<p>最终的效果如下图： <img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut1.JPG" alt><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut2.JPG" alt><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut3.JPG" alt><br><img src="http://o9ybnkuir.bkt.clouddn.com/Bootstrap/shotcups/shotcut4.JPG" alt><br>（想看完整版的可从博客左侧的“关于”栏获取链接）。</p>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这个页面是第一次完整的制作页面，当看到整体呈现在面前的时候，还是有点小激动的。感觉特别冲击的是，居然可以几乎不手写js代码就能做出这样的效果！和对照网站的功能及视觉效果来说，比较突出的两点不足是：</p>
<ol>
<li>首页轮播图和背景并没有十分契合；</li>
<li>首页的整体色调不是很完美；</li>
<li>最后一个页面的滚动监听功能没有实现，虽然重新看了几遍教程也看过了中文文档，但还是没有找出问题出在哪里，暂时搁置，待对bootsrap的功能了解更全面后再来找出问题所在。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;虽然这个页面已经做完了，但自知整体布局都是老师已经选好的，并没有什么难度。这只是一个开始而已，路还很长，加油。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Bootstrap </tag>
            
            <tag> 框架 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《jQuery学习教程》]]></title>
      <url>http://detachment.club/2016/07/31/jQuery%20%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;网上学习JS的过程告一段落，然后就马不停蹄的开始找JS框架和库的教程（感觉知乎上很多学习课程都是不负责任推荐，有点怀疑他们本身有没有看过那些推荐的教程。当然了，也可能是那些课程仅仅是不适合我。），找了一圈下来（网易云课堂、慕课网、极客学院、codecademy、free code camp等）没有发现适合的，要么讲的太简单了，要么信息量太大了。这时候，终于想起了w3school。以下的学习内容大部分都是基于这上面的，需要更详细的内容可以上<a href="http://www.w3school.com.cn/jquery" target="_blank" rel="noopener">w3school</a>查看。</p>
<a id="more"></a>
<h2 id="课程章节"><a href="#课程章节" class="headerlink" title="课程章节"></a>课程章节</h2><h3 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h3><h4 id="关键词：简介、安装、语法、选择器、事件、名称冲突"><a href="#关键词：简介、安装、语法、选择器、事件、名称冲突" class="headerlink" title="关键词：简介、安装、语法、选择器、事件、名称冲突"></a>关键词：简介、安装、语法、选择器、事件、名称冲突</h4><ul>
<li><strong>简介</strong>：jQuery是一个轻量级的JavaScript库，能极大的简化JavaScript编程，宗旨是“write less, do more”；包含的功能非常多（1. HTML元素选取；2. HTML元素操作；3. CSS操作；4. HTML事件函数；5. JavaScript特效和动画；6. HTML DOM遍历和修改；7. AJAX；8. Utilities；）；</li>
<li><strong>安装</strong>：可以将jQuery库下载到本地引用，也可以直接引用Microsoft或者google的CDN；使用引用CDN的方式有一个很大的优势就是许多用户在访问其他站点的时候已经加载过jQuery，结果就是当这些人访问站点时，会直接从缓存中加载jQuery，从而减少加载时间。而且，大多数CDN都可以确保用户在请求文件时，从最近的服务器上返回响应，从而提高加载速度；</li>
<li><strong>语法</strong>：语法形式为<code>$(selector).action()</code>，其中美元符号定义了jQuery，选择符（seclector）查询出符合条件的html元素，action函数对筛选出来的元素进行操作；举个最常见的例子：<code>$(document).ready(function(){});</code>这段代码表示在整个页面加载完成后再执行其中的操作；</li>
<li><strong>选择器</strong>：常见的选择器有以下几种：<ol>
<li>元素选择器：例如<code>$(&#39;p&#39;)</code>表示选取<code>&lt;p&gt;</code>元素；<code>$(&#39;p.intro&#39;)</code>表示选择类别为intro的<code>&lt;p&gt;</code>元素；</li>
<li>属性选择器：例如<code>$(&quot;[href]&quot;)</code>表示选取所有带有href属性的元素；<code>$(&quot;[href=&#39;#&#39;]&quot;)</code>表示选择所有带有href值等于#的元素；<code>$(&quot;[href$=&#39;.jpg&#39;]&quot;)</code>表示选择所有href值以.jpg结尾的元素；</li>
<li>更多是选择器参考<a href="http://www.w3school.com.cn/jquery/jquery_ref_selectors.asp" target="_blank" rel="noopener">jQuery选择器手册</a>。</li>
</ol>
</li>
<li><strong>事件</strong>：jQuery事件处理方法是jQuery的核心函数，事件处理程序指的是当HTML中发生某些事件所调用的方法，也叫作“触发”；（通常把jQuery代码放在<code>&lt;head&gt;</code>部分的事件处理方法中；详细的事件参考<a href="http://www.w3school.com.cn/jquery/jquery_ref_events.asp" target="_blank" rel="noopener">jQuery事件手册</a></li>
<li><strong>名称冲突</strong>：由于其他库也可能使用<code>$</code>符号，那么就会引起冲突，jQuery中使用<code>noConflict()</code>方法来解决这个问题；</li>
<li><strong>注意</strong>：为了使代码更容易维护，以下事项需要注意：<ol>
<li>把所有的jQuery代码置于事件处理函数中；</li>
<li>把所有事件处理函数置于文档就绪事件处理器中；</li>
<li>把jQuery代码置于单独的<code>.js</code>文件中;</li>
<li>如果存在名称冲突，则重命名jQuery库；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码"><a href="#实例及代码" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/akawvG/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/akawvG/" target="_blank" rel="noopener">jQuery01</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>注意：由于CodePen后台提供了jQuery的链接，所以在面板上看不到引入库的这一段代码。</p>
</blockquote>
<h4 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h4><p>本节主要是关于jQuery的简单介绍，其中选择器及事件为重点内容，可以查看手册后挑几个练习，使得具有最基本的功能：</p>
<blockquote>
<ol>
<li>下载jQuery库后本地引用或者直接引用链接；</li>
<li>具有基本的选择器及事件函数；</li>
</ol>
</blockquote>
<hr>
<h3 id="jQuery效果"><a href="#jQuery效果" class="headerlink" title="jQuery效果"></a>jQuery效果</h3><h4 id="关键词：隐藏显示，淡入淡出，滑动，动画，stop-，Callback-Chaining"><a href="#关键词：隐藏显示，淡入淡出，滑动，动画，stop-，Callback-Chaining" class="headerlink" title="关键词：隐藏显示，淡入淡出，滑动，动画，stop()，Callback, Chaining"></a>关键词：隐藏显示，淡入淡出，滑动，动画，stop()，Callback, Chaining</h4><ul>
<li><strong>隐藏显示</strong>：方法为<code>hide(), show()</code>，使用语法为<code>$(selector).hide(speed, callback)</code>，其中speed可以是slow，fast或者毫秒；而callback表示的是完成这个动作之后执行的函数；除了这两个方法之外，可以用<code>toggle()</code>的方法来切换显示隐藏，效果不错；</li>
<li><strong>淡入淡出</strong>：方法为<code>fadeIn(), fadeOut(), fadeToggle(), fadeTo()</code>，使用语法为<code>$(selector).fadeIn(speed, callback)</code>，其中speed和callback的理解和上面的一样；其中<code>fadeTo()</code>方法略有不同，语法为<code>$(selector).fadeTo(speed,opacity,callback)</code>，表示的是将选择出的元素的透明度变成目标值；</li>
<li><strong>滑动</strong>：方法为<code>slideDown(), slideUp(), slideToggle()</code>使用语法为<code>$(selector).slideDown(speed, callback)</code>，其中speed和callback的解释同上；</li>
<li><strong>动画</strong>：方法为<code>animate()</code>，使用语法为<code>$(selector).animate({params}, speed, callback)</code>，其中params参数定义形成动画的css属性，speed和callback的含义解释同上；其中属性的动画值可以设置成<code>&quot;show&quot;,&quot;hide&quot;,&quot;toggle&quot;</code>，具体见实例；如果需要实现步骤有先后的动画，那么可以通过编写多个animate()方法，jQuery就会逐一运行这些代码，这种功能叫做队列功能；animate方法几乎能操作所有的CSS属性，但是需要注意的是需要使用Camel标记法来书写属性名，比如paddingLeft,marginRight等；</li>
<li><strong>stop()</strong>: 此方法用于停止动画或者效果，适用于所有jQuery效果函数，语法为<code>$(selector).stop(stopAll,goToEnd)</code>，其中可选参数stopAll规定是否应该清除动画队列，默认是false，即仅停止活动的动画，但允许队列中的其他动画执行；可选参数goToEnd表示是否立即完成当前动画，默认为false；</li>
<li><strong>Callback</strong>：此函数在当前动画100%完成之后执行；因为JS语句是逐一执行的，为了避免因为动画还没执行完成而造成动画与之后的语句之间可能产生的错误或者页面冲突，建议以参数的形式添加Callback函数；</li>
<li><strong>Chaining</strong>：Chaining允许我们在一条语句中添加多个方法，例如<code>$(&#39;p&#39;).css(&#39;color&#39;, &#39;red&#39;).slideUp(2000).slideDown(2000);</code>，这是p元素就会先改变css样式，然后收缩，最后张开；为了易读性及格式的美观，可以通过换行及空格来美化；</li>
</ul>
<h4 id="实例及代码-1"><a href="#实例及代码-1" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EyZZQY/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EyZZQY/" target="_blank" rel="noopener">jQuery02</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="小测试-1"><a href="#小测试-1" class="headerlink" title="小测试"></a>小测试</h4><p>利用这节课所学的知识点，重现具有以上功能的div。</p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>  既然很多方法中已经都有callback函数的可选参数来达到链式运动的目的，那么为什么jQuery还需要有链式运动的功能？</p>
<pre><code>1. callback函数可以是任意函数，函数改变的对象可以是任意对象；
2. 链式运动改变的对象是同一元素，链式运动的写法更简单；
3. 还有类似功能的是动画的队列功能，不过动画改变的是具体的css属性；
</code></pre><hr>
<h3 id="jQuery-HTML"><a href="#jQuery-HTML" class="headerlink" title="jQuery HTML"></a>jQuery HTML</h3><h4 id="关键词：获取、设置、添加、删除、css类、css-、尺寸"><a href="#关键词：获取、设置、添加、删除、css类、css-、尺寸" class="headerlink" title="关键词：获取、设置、添加、删除、css类、css()、尺寸"></a>关键词：获取、设置、添加、删除、css类、css()、尺寸</h4><ul>
<li>获取:用于获取内容的DOM操作方法主要有三个，获取属性值的方法主要有一个，分别是：<ol>
<li>text(): 设置或返回所选元素的文本内容；</li>
<li>html(): 设置或者返回所选元素的内容（包括html标签）；</li>
<li>val(): 设置或返回表单字段的值；</li>
<li>attr(): 用于获取属性值；</li>
</ol>
</li>
<li>设置：设置内容也是用上一节提到的三个函数，不过需要在括号中加入需要设置的内容，具体方法可见例子；同时需要知道，这三个jQuery方法都拥有回调函数，函数有两个参数，分别为被选元素列表中当前元素的下标以及原始值，<a href="http://www.w3school.com.cn/jquery/jquery_dom_set.asp" target="_blank" rel="noopener">text()、html() 以及 val() 的回调函数</a>；利用attr()来设置属性时可以同时设置多个属性，属性之间利用逗号隔开，此方法同样具有回调函数；</li>
<li>添加：利用jQuery可以很容易的添加新元素或者新内容，方法如下：<ol>
<li>append()：在被选元素的结尾插入内容或元素；</li>
<li>prepend()：在被选元素的开头插入内容或元素；</li>
<li>after()：在被选元素之后插入内容或元素；</li>
<li>before()：在被选元素之前插入内容或元素；</li>
</ol>
</li>
<li>删除：删除元素或内容主要通过以下两个jQuery方法：<ol>
<li>remove()：删除被选元素及其子元素，括号中可添加选择器，用于删除符合选择器条件的元素及其子元素；</li>
<li>empty(): 从被选元素中删除子元素；</li>
</ol>
</li>
<li>css类：通过jQuery可以很容易对css元素进行操作，主要方法有：<ol>
<li>addClass()：向被选元素添加一个或多个类（添加多个类的时候类名称之间用空格隔开）；</li>
<li>removeClass()：从被选元素删除一个或多个类；</li>
<li>toggle()：对被选元素添加/删除类的切换操作；</li>
<li>css()：设置或返回被选元素的一个或多个样式属性，语法为<code>css(&#39;propertyName&#39;)</code>如果有多个满足被选条件，则只返回第一个元素的属性；如需设置CSS属性，则需使用语法为<code>css(&#39;propertyName&#39;, &#39;value&#39;)</code>，此时将所有满足条件的元素的样式都设置成目标样式；</li>
</ol>
</li>
<li>尺寸：通过jQuery很容易处理元素和浏览器窗口的尺寸，主要的方法如下：<ol>
<li>width()：设置或返回元素的宽度（不包括内边距、边框和外边距），如果对象为document或者window，则表示返回HTML文档或者浏览器窗口的宽度和高度；如果在括号中加入数字，则表示将对应的尺寸设置为对应的值；</li>
<li>height()：设置或返回元素的高度（不包括内边距、边框和外边距）；</li>
<li>innerWidth()：返回元素的宽度（包括内边距）；</li>
<li>innerHeight()：返回元素的高度（包括内边距）；</li>
<li>outerWidth()：返回元素的宽度（包括内边距和边框），如果括号中增加参数‘true’则表示返回包括内外边距及边框的宽度；</li>
<li>outerHeight()：返回元素的高度（包括内边距和边框），如果括号中增加参数‘true’则表示返回包括内外边距及边框的高度；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码-2"><a href="#实例及代码-2" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/OXBzLX/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/OXBzLX/" target="_blank" rel="noopener">jQuery03</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>本小程序具有的功能：</p>
<ol>
<li>点击第一个按钮，能在方框中添加一个list，list的内容为输入框中的内容，且添加都是从头开始添加；</li>
<li>点击第二个按钮，移除方框中的一个list，且每次移除都是移除第一个；</li>
<li>点击第三个按钮能够改变方框中list的样式，具体为改变字体、字体颜色及list的样式；</li>
<li>点击第四个按钮能够改变方框的尺寸；</li>
</ol>
</blockquote>
<h4 id="小问题-1"><a href="#小问题-1" class="headerlink" title="小问题"></a>小问题</h4><p>利用append()及after()来添加内容的话，有何不同？</p>
<blockquote>
<p>前者是在所选元素的结尾处添加内容，也就是说，并没有新增加一个节点；而后者则在所选元素的后面增加内容，很显然这时候增加了一个节点。可以通过一个很小的例子来证明，局部代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;p&gt;This is a paragraph!&lt;/</span>p&gt;</span><br><span class="line">hello!                           <span class="comment">//利用after()来添加 "Hello!"</span></span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">This is a paragraph!</span><br><span class="line">Hello!                          <span class="comment">//利用append()来添加 "Hello!"</span></span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="小测试-2"><a href="#小测试-2" class="headerlink" title="小测试"></a>小测试</h4><p>通过本节的学习，应该已经知道了利用jQuery来控制html元素的添加与删除以及css样式的设置，那么可以从添加、删除及设置样式的方法中任选几个来制作一个和上面所示类似功能的程序。</p>
<hr>
<h3 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h3><h4 id="关键词：遍历、祖先、后代、同胞、过滤"><a href="#关键词：遍历、祖先、后代、同胞、过滤" class="headerlink" title="关键词：遍历、祖先、后代、同胞、过滤"></a>关键词：遍历、祖先、后代、同胞、过滤</h4><ul>
<li>遍历：用于根据其相对于其他元素的关系来查找或者选取HTML元素；</li>
<li>祖先：祖先元素包括父元素、祖父元素等等，常用的方法为：<ol>
<li>parent()：返回被选元素的直接父元素；</li>
<li>parents()：返回被选元素的所有祖先元素，其中甚至包括文档的根元素（即<html>)；</html></li>
<li>parentsUntil()：返回介于两个给定元素之间的祖先元素；</li>
</ol>
</li>
<li>后代：与祖先相对的，后代指的是子、孙、曾孙等，常用的方法为：<ol>
<li>children()：返回被选元素的直接子元素；</li>
<li>find()：返回被选元素的被find的元素，包括所有后代；</li>
</ol>
</li>
<li>同胞：同胞拥有相同的父元素，常用的方法为：<ol>
<li>siblings()：返回所有被选元素的同胞元素；</li>
<li>next()：返回被选元素的下一个同胞元素；</li>
<li>nextAll()：返回被选元素的所有跟随的同胞元素；</li>
<li>nextUntil()：返回介于两个给定参数之间的所有跟随的同胞元素；</li>
<li>prev()：返回被选元素的上一个同胞元素；</li>
<li>prevAll():返回被选元素的所有前面的同胞元素；</li>
<li>prevUntil()：返回介于两个给定参数之间的所有的同胞元素；</li>
</ol>
</li>
<li>过滤：缩小搜索元素的范围，常用的方位有以下几种：<ol>
<li>first()：返回被选元素的首个子元素；</li>
<li>last()：返回被选元素的最后一个元素；</li>
<li>eq()：返回被选元素中带有指定索引号的元素；</li>
<li>filter()：返回符合匹配标准的元素集合；</li>
<li>not()：返回不匹配标准的所有元素集合；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例"><a href="#代码及实例" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/BzqvZJ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/BzqvZJ/" target="_blank" rel="noopener">jQuery04</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>注意：<br>在使用filter()进行筛选的时候，<code>$(selector).filter(some)</code>其中seclector和some是同一等级的，也就是说是在很多selector中找出符合‘some’这个筛选要求的selector。</p>
</blockquote>
<h4 id="小测试-3"><a href="#小测试-3" class="headerlink" title="小测试"></a>小测试</h4><p>本节的内容比较简单，只需要注意方法之间的细微差异就好。通过本节的学习，应该已经能够快速的找出所需要的元素或元素合集了。为了加深印象，可从上面那么多的遍历方法中挑出几个来进行练习。</p>
<hr>
<h3 id="jQuery-AJAX"><a href="#jQuery-AJAX" class="headerlink" title="jQuery AJAX"></a>jQuery AJAX</h3><h4 id="关键词：AJAX简介、加载、Get-Post"><a href="#关键词：AJAX简介、加载、Get-Post" class="headerlink" title="关键词：AJAX简介、加载、Get/Post"></a>关键词：AJAX简介、加载、Get/Post</h4><ul>
<li>简介：全称为Asynchronous JavaScript and XML，异步的JavaScript和XML，此功能能够在不重载整个页面的情况下通过后台加载数据，并在页面上显示出来；</li>
<li>加载：在jQuery中的AJAX方式为：load()，此方法能够从服务器中加载数据，并把返回的数据放入到被选元素中；语法为：<code>$(selector).load(URL, data, callback)</code>其中URL参数表示希望加载的地址；可选参数data规定了与请求一同发送的查询字符串键/值对集合；可选参数callback是load方法完成后所执行的函数名称，可设置参数为responsTxt（包含调用成功时的结果内容）,statusTxt（包含调用的状态）,xhr（包含XMLHttpRequest对象）；</li>
<li>Get/Post：两种常见的从服务器请求数据的方法，<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">点击这个链接可了解这两者的详细区别</a>；</li>
</ul>
<h4 id="代码及实例-1"><a href="#代码及实例-1" class="headerlink" title="代码及实例"></a>代码及实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">" src='https://code.jquery.com/jquery-2.2.4.min.js'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        $(document).ready(function () &#123;</span></span><br><span class="line"><span class="string">            $('#btn').click(function () &#123;</span></span><br><span class="line"><span class="string">                $.get('a.txt?t='+ new Date().getTime(), function (data, status) &#123;</span></span><br><span class="line"><span class="string">                    alert('Date:'+data+"</span>\nStatus:<span class="string">"+status);</span></span><br><span class="line"><span class="string">                &#125;);</span></span><br><span class="line"><span class="string">            &#125;);</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;button type="</span>button<span class="string">" id="</span>btn<span class="string">"&gt;Get&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：由于ajax部分的内容需要在服务器环境下进行测试，所以本节只给出了代码的例子。</p>
</blockquote>
<h4 id="小测试-4"><a href="#小测试-4" class="headerlink" title="小测试"></a>小测试</h4><p>利用jquery我们不再需要自己去手写ajax文件了，确实是非常的方便。通过本节课程的学习，可自己动手在服务器环境下测试一下获取信息。（需要注意的是最好将html文件和待查询文件放在同一个服务器的文件夹中）</p>
<hr>
<h3 id="jQuery杂项"><a href="#jQuery杂项" class="headerlink" title="jQuery杂项"></a>jQuery杂项</h3><h4 id="关键词：命名冲突"><a href="#关键词：命名冲突" class="headerlink" title="关键词：命名冲突"></a>关键词：命名冲突</h4><ul>
<li>命名冲突：noConflict()，由于有可能其他框架也使用$符号作为简写，那么如果同时使用这两种框架的话就可能导致脚本停止运行，为了解决这个问题，在jQuery中使用noConflict()方法。语法为<code>$.noConflict()</code>这样写完以后，就需要用全名jQuery来代替$符号了。如果希望直接用$符号且不引起冲突，那么可以将$符号作为变量传给ready函数，但是需要注意的是在函数外还是需要用全名。</li>
</ul>
<h4 id="实例及代码-3"><a href="#实例及代码-3" class="headerlink" title="实例及代码"></a>实例及代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.noConflict();</span><br><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"p"</span>).text(<span class="string">"jQuery 仍在运行！"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; 接触jquery其实有一段时间了，但是真正开始学习的时间并不长。初步学完JS之后，又接触到bootstrap，然后了解到其中也包含了jquery的内容，所以决定先全面了解jquery然后再来学习bootstrap。<br>&nbsp; &nbsp; &nbsp; &nbsp; jQuery作为JS的轻量级的库存在，自然而然的在应用层面上比原生JS有着很大的优势，在利用jQuery写效果的时候就能明显的感觉到这一点。在jQuery中各种选择器应有尽有，各种事件也非常多，还有很好用的链式写法，这一切都与jQuery的宗旨“Write less, do more”不谋而合。<br>&nbsp; &nbsp; &nbsp; &nbsp; 由于时间关系，并没有去了解jQuery的内部写法的精妙，在之后的学习生涯中一定会找出时间来认真了解下。同样的由于时间关系，并没有将每种事件，每个选择器，每个效果都去实现一遍，但私以为在应用层面上效果只不过是外表，其内核都是一样的，所以这并不影响在需要这种效果的时候来调用。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 基础 </tag>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【置顶】 《精通JavaScript开发》]]></title>
      <url>http://detachment.club/2016/07/02/%E5%9F%BA%E4%BA%8E%E3%80%8A%E7%B2%BE%E9%80%9AJavaScript%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从5月25日开始开始学习，用了将近一个月的时间将<a href="http://study.163.com/course/courseMain.htm?courseId=224014" target="_blank" rel="noopener">视频课程</a>过了一遍，对比W3school及另外一套课程，这个课程给我的体验是整体进度设置很合理，Blue老师循循善诱，讲课风格非常适合新手学习。为了更好的掌握JavaScript的内容，下文将对每一章节做对应的总结与复习，并有相应的小测试来巩固复习。本文内容适合所有正在学习此课程的同学。<b>对于本课程或者本博客有任何问题，非常欢迎给我发邮件，我会尽我所能回答你的问题。</b></p>
<a id="more"></a>
<h2 id="课程章节"><a href="#课程章节" class="headerlink" title="课程章节"></a>课程章节</h2><h3 id="《初探JavaScript魅力01》"><a href="#《初探JavaScript魅力01》" class="headerlink" title="《初探JavaScript魅力01》"></a>《初探JavaScript魅力01》</h3><h4 id="关键词：JS、事件、属性、函数、重用、变量"><a href="#关键词：JS、事件、属性、函数、重用、变量" class="headerlink" title="关键词：JS、事件、属性、函数、重用、变量"></a>关键词：JS、事件、属性、函数、重用、变量</h4><ul>
<li>JavaScript：交互、功能；</li>
<li>事件：用户操作或者其他改变；</li>
<li>属性：属性是与对象相关的值；</li>
<li>函数：函数是指由事件驱动的或者当它被调用时执行的可重复使用的代码块；</li>
<li>重用：使开发效率更高，布局更简洁；</li>
<li>变量：存储信息的容器；</li>
</ul>
<h4 id="实例及代码"><a href="#实例及代码" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="277" scrolling="no" src="//codepen.io/Leon-Zhao/embed/kXwLYb/?height=277&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/kXwLYb/" target="_blank" rel="noopener">JavaScript-01</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h4><p>请利用这节课的知识，完成具有下面功能的区块：</p>
<blockquote>
<ol>
<li>区块大小200px*200px；背景颜色为红色；</li>
<li>鼠标移入区块大小变成300px*300px，背景颜色变成蓝色；</li>
<li>鼠标移出区块大小及颜色变成初始状态。</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力02》"><a href="#《初探JavaScript魅力02》" class="headerlink" title="《初探JavaScript魅力02》"></a>《初探JavaScript魅力02》</h3><h4 id="关键词：变量、函数的定义及调用、ID、if判断、双等号、className"><a href="#关键词：变量、函数的定义及调用、ID、if判断、双等号、className" class="headerlink" title="关键词：变量、函数的定义及调用、ID、if判断、双等号、className"></a>关键词：变量、函数的定义及调用、ID、if判断、双等号、className</h4><ul>
<li>函数定义及调用：定义时只是告诉系统有这个函数，但不会执行；调用的时候函数执行；</li>
<li>ID：任何标签都可以加ID，包括link。任何标签的任何属性都可以改，而且html上怎么写，js里就怎么写（除了className）；</li>
<li>if：条件判断；</li>
<li>双等号：用于判断双等号两边是否相等；</li>
<li>className： 列别名，为js中的保留字，唯一一个在html及js中写法不同的属性；</li>
</ul>
<h4 id="实例及代码-1"><a href="#实例及代码-1" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/zBzpjv/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBzpjv/" target="_blank" rel="noopener">JavaScript-02-01</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/XKgVoX/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/XKgVoX/" target="_blank" rel="noopener">JavaScript-02-02</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>


<h4 id="测试题-1"><a href="#测试题-1" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>新建一个按钮及div；</li>
<li>点击按钮更改div的样式（可以是背景颜色、大小或者其他）；</li>
<li>必须通过更改div的类来达到上面的效果；</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力03》"><a href="#《初探JavaScript魅力03》" class="headerlink" title="《初探JavaScript魅力03》"></a>《初探JavaScript魅力03》</h3><h4 id="关键词：函数传参、操作属性方法、字符串及参数"><a href="#关键词：函数传参、操作属性方法、字符串及参数" class="headerlink" title="关键词：函数传参、操作属性方法、字符串及参数"></a>关键词：函数传参、操作属性方法、字符串及参数</h4><ul>
<li>函数传参：当函数中有参数有多个值时使用传参，参数就是占位符；</li>
<li>操作属性方法：最常用的为通过“.”，但是当属性作为参数的时候，需要用”[]”的形式来改变参数，否则无法被识别；所有用.的地方都能用[]替换，但反过来不成立；</li>
<li>字符串为常量，设定后即为定值；参数则为变量，传入时才确定；传入字符串时需要加双引号，而后者不需要；</li>
</ul>
<h4 id="实例及代码-2"><a href="#实例及代码-2" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/grRZBL/?height=265&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/grRZBL/" target="_blank" rel="noopener">JavaScript-03</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-2"><a href="#测试题-2" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>新建三个按钮及一个有字体内容的div；</li>
<li>分别点击按钮改变div中字体的大小、颜色及样式；</li>
<li>通过函数传参的方式达到上面所要求的效果。</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力04》"><a href="#《初探JavaScript魅力04》" class="headerlink" title="《初探JavaScript魅力04》"></a>《初探JavaScript魅力04》</h3><h4 id="关键词：样式优先级、提取行间事件、匿名函数、window-onload、获取元素组、循环"><a href="#关键词：样式优先级、提取行间事件、匿名函数、window-onload、获取元素组、循环" class="headerlink" title="关键词：样式优先级、提取行间事件、匿名函数、window.onload、获取元素组、循环"></a>关键词：样式优先级、提取行间事件、匿名函数、window.onload、获取元素组、循环</h4><ul>
<li>样式优先级：表示样式优先执行的顺序，如右： 通配符&lt;标签&lt;class&lt;ID&lt;行间；（对于同一个元素，修改样式的时候建议在同一优先级进行修改。）</li>
<li>提取行间事件：行间事件也是一种特殊的属性；</li>
<li>匿名函数：不进行命名的函数；</li>
<li>获取元素组：利用getElementsByTagName获取;</li>
<li>循环：while（包括初始化、条件、语句和自增）；for 循环。</li>
</ul>
<h4 id="实例及代码-3"><a href="#实例及代码-3" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/zBzJAV/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBzJAV/" target="_blank" rel="noopener">JavaScript-04</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-3"><a href="#测试题-3" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面的一个小程序：</p>
<blockquote>
<ol>
<li>新建两个按钮及若干个div，大小及背景颜色随意；</li>
<li>点击按钮分别能改变所有div的大小或者颜色。</li>
</ol>
</blockquote>
<hr>
<h3 id="《初探JavaScript魅力05》"><a href="#《初探JavaScript魅力05》" class="headerlink" title="《初探JavaScript魅力05》"></a>《初探JavaScript魅力05》</h3><h4 id="关键词：This、innerHTML、字符串连接、数组"><a href="#关键词：This、innerHTML、字符串连接、数组" class="headerlink" title="关键词：This、innerHTML、字符串连接、数组"></a>关键词：This、innerHTML、字符串连接、数组</h4><ul>
<li>This：当前发生事件的元素（目前这么理解就行了，更多的用法后面会涉及到）；</li>
<li>innerHTML：写入到html页面中，写入的内容本身可以包含html标签；</li>
<li>字符串连接：通过了解符 <code>+</code> 来实现，注意有优先级的问题；</li>
<li>数组：一系列值的组合；</li>
</ul>
<h4 id="实例及代码-4"><a href="#实例及代码-4" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="559" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/ZOydkq/?height=559&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/ZOydkq/" target="_blank" rel="noopener">JavaScript-05</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-4"><a href="#测试题-4" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个选项卡；</li>
<li>有四个选项，且每一项都对应不同的内容；</li>
<li>鼠标移动到不同选项卡的时候，显示不同的内容；</li>
<li>鼠标移入选项卡的时候，选项卡本身的样式也会发生一些变化。</li>
</ol>
</blockquote>
<hr>
<h3 id="《JavaScript基础01》"><a href="#《JavaScript基础01》" class="headerlink" title="《JavaScript基础01》"></a>《JavaScript基础01》</h3><h4 id="关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范"><a href="#关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范" class="headerlink" title="关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范"></a>关键词：JS组成、变量类型、parseInt、NaN、作用域、闭包、命名规范</h4><ul>
<li>JS组成：JS由ECMAScript（解释器、翻译）、DOM（操纵html）、BOM（操作浏览器，兼容性）；ECMA几乎没有兼容问题，DOM有一些操作不兼容，BOM没有兼容问题（完全不兼容）；</li>
<li>变量类型：数字、字符、对象、函数、布尔值、未定义；（一个变量最好只存一种类型的变量）；</li>
<li>parseInt：将字符转换成数字，从左到右扫描字符，一旦遇到不是数字的就直接返回，因此也可提取字符串中的数字；字符串不为数字，则返回NAN；只用于转换整数，如要转换成小数，则为parseFloat；</li>
<li>NaN：唯一一个不等于本身，isNaN用于判断是否为NaN；</li>
<li>类型转换：显示类型转换（如上面提到的）及隐式类型转换（系统自动转换），然后就涉及到<code>==</code>和<code>===</code>后者不进行隐式类型转换就开始比较；<code>+</code>运算时不会进行隐形类型转换而<code>-</code>符号则会先进行类型转换再运算；</li>
<li>作用域：变量作用范围，局部变量及全局变量；</li>
<li>闭包：子函数可使用父函数的局部变量；</li>
<li>命名规范：可读性及规范性（匈牙利命名法）；</li>
</ul>
<h4 id="实例及代码-5"><a href="#实例及代码-5" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="124" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/bZAbVk/?height=124&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/bZAbVk/" target="_blank" rel="noopener">JavaScript-06</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-5"><a href="#测试题-5" class="headerlink" title="测试题"></a>测试题</h4><p>请根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个加法计算器；</li>
<li>计算器形式为<code>a + b = c</code>，其中a和b为输入框中的数字，c为输出的数字；</li>
<li>计算前先判断是否为数字类型，如果不是则弹出提示；</li>
<li>能计算整数及小数；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JavaScript基础02》"><a href="#《JavaScript基础02》" class="headerlink" title="《JavaScript基础02》"></a>《JavaScript基础02》</h3><h4 id="关键词：运算符、程序流程控制、True和False、Json、Json和数组"><a href="#关键词：运算符、程序流程控制、True和False、Json、Json和数组" class="headerlink" title="关键词：运算符、程序流程控制、True和False、Json、Json和数组"></a>关键词：运算符、程序流程控制、True和False、Json、Json和数组</h4><ul>
<li>运算符：用于算数、赋值、关系、逻辑、优先级等；</li>
<li>程序流程控制：判断（if、switch、？：），循环（while、for），跳出（continue、break）</li>
<li>True和False： 表示的是计算机用于计算的真与假，true包括：true、非零数字、非空字符串、非空对象；false包括：false、0、空字符串、空对象、undefined；</li>
<li>Json：一种轻量级的数据交换格式，是基于JavaScript的一个子集；（注意Json没有length属性，使用循环的话需要for（var i in json）这种形式）；</li>
<li>Json与数组的区别：1.Json的下标为字符串，而数组为数字；2.前者无length属性而后者有；3.前者循环只能用for（var i in json）的形式，而后者两种形式都可以；</li>
</ul>
<h4 id="实例及代码-6"><a href="#实例及代码-6" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/NAvGjb/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/NAvGjb/" target="_blank" rel="noopener">JavaScript-07</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-6"><a href="#测试题-6" class="headerlink" title="测试题"></a>测试题</h4><p>由于本节内容多为介绍性，基本上每个程序都非常简单，可用练习下列小程序：</p>
<blockquote>
<ol>
<li>制作一个隔行变色的表格；</li>
<li>利用switch制作一个小程序；</li>
<li>利用三运算符<code>?:</code>制作一个小程序；</li>
<li>利用break或者continue制作一个小程序；</li>
<li>利用Json制作一个小程序。</li>
</ol>
</blockquote>
<hr>
<h3 id="《深入JavaScript》"><a href="#《深入JavaScript》" class="headerlink" title="《深入JavaScript》"></a>《深入JavaScript》</h3><h4 id="关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort"><a href="#关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort" class="headerlink" title="关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort"></a>关键词：函数返回值、函数传参（不定参）、取非行间样式、数组、splice、concat、join、sort</h4><ul>
<li>函数返回值：即为函数的执行结果；</li>
<li>传不定参：arguments，参数的个数可变；（例子：求和、css函数）</li>
<li>取非行间样式：如果样式没有写在行间，那么应该利用currentStyle(IE)或者getComputedStyle(obj，false).name。利用if，else来进行兼容性处理；获取复合样式的属性时需要注明所取的明确样式（如获取背景颜色，需要写backgroundColor，直接写background是没有作用的）。</li>
<li>数组：使用单一变量的值存储一系列的值；数组的length属性既可读亦可写，因此可利用可写功能快速清空数组；添加：push及unshift（分别表示在尾部及头部添加）；删除：pop及shift（分别表示从尾部及头部删除）；</li>
<li>splice：splice(n1,n2)表示从数组的n1位置开始删n2个元素；splice(n1,n2,”a”,”b”,”c”…)表示在n1位置删除n2个元素，并添加后面的”a”,”b”,”c”,等等；</li>
<li>concat：数组的连接，语法:<code>a.concat(b)</code>,则数组a和b连接，a是元素在b的元素前面；</li>
<li>join：表示用给定的参数连接数组里面的值，语法为<code>arr.join(&quot;value&quot;)</code>,那么arr中的值就将会被value连接起来；</li>
<li>sort：数组的排序，语法为<code>arr.sort()</code>,其中sort()括号中可传入函数，表示排序的依据；在对数字排序的时候，因为sort属性只认字符串，所以必须传入比较函数；</li>
</ul>
<h4 id="实例及代码-7"><a href="#实例及代码-7" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EyvXLd/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EyvXLd/" target="_blank" rel="noopener">JavaScript-08</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-7"><a href="#测试题-7" class="headerlink" title="测试题"></a>测试题</h4><p>同样的，本节也主要是在讲一些非常基础的知识，没有涉及到复杂程序的练习，所以大家可选择性练习下方小程序：</p>
<blockquote>
<ol>
<li>利用不定参argument制作一个程序，如果传入的是两个参数则获取参数值；如传入三个值，则设置参数；</li>
<li>练习数组的相关属性：pop、unshift、push、shift、concat、join、sort、splice、length；</li>
</ol>
</blockquote>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><blockquote>
<p>有没有什么方法能够直接修改css样式中的参数值？（由本节讲到的可直接获取样式中的参数值想到的）</p>
</blockquote>
<hr>
<h3 id="《定时器的使用01》"><a href="#《定时器的使用01》" class="headerlink" title="《定时器的使用01》"></a>《定时器的使用01》</h3><h4 id="关键词：定时器、清除定时器、Date对象、charAt"><a href="#关键词：定时器、清除定时器、Date对象、charAt" class="headerlink" title="关键词：定时器、清除定时器、Date对象、charAt()"></a>关键词：定时器、清除定时器、Date对象、charAt()</h4><ul>
<li>定时器：间隔性(setInterval)、延时性(setTimeout);</li>
<li>清除定时器：clearInterval(name),name为需要关闭的定时器的名称；对应的还有clearTimeout;</li>
<li>Date(): 包括<code>getHours(),getMinutes(),getSeconds(),getFullYear(),getMonth(),getDate(),getDay()</code>，其中getMonth()获取的月份是从0开始的；</li>
<li>charAt: 兼容低版本的获取元素的方法，比如获取str中第i位元素：<code>str[i]=str.charAt(i)</code>;</li>
</ul>
<h4 id="实例及代码-8"><a href="#实例及代码-8" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="355" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/akyxYo/?height=355&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/akyxYo/" target="_blank" rel="noopener">JavaScript09</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-8"><a href="#测试题-8" class="headerlink" title="测试题"></a>测试题</h4><p>本节讲到了两个例子，一个就是上面的数码时钟，另一个就是下面的延时提示框，需要满足的功能如下：</p>
<blockquote>
<ol>
<li>有一大一小两个div，左右分布；</li>
<li>当鼠标放入小div区域时，大的div显示；</li>
<li>当鼠标移出小div到别处，大div经过500ms后消失；</li>
<li>如果在这500ms内，鼠标移入大div区域，则大div不消失；</li>
<li>从大div移出时，500ms后大div消失；</li>
<li>在500ms内如果鼠标移入小div，则大div不消失；<br>（简单来说：当鼠标在可见的div范围内，div常显；当鼠标在空白处500ms后，大div消失）</li>
</ol>
</blockquote>
<hr>
<h3 id="《定时器的使用02》"><a href="#《定时器的使用02》" class="headerlink" title="《定时器的使用02》"></a>《定时器的使用02》</h3><h4 id="关键词：offsetLeft、无缝滚动、innerHTML"><a href="#关键词：offsetLeft、无缝滚动、innerHTML" class="headerlink" title="关键词：offsetLeft、无缝滚动、innerHTML"></a>关键词：offsetLeft、无缝滚动、innerHTML</h4><ul>
<li>offsetLeft：元素的水平偏移位置（包括margin）；</li>
<li>无缝滚动：结合offsetLeft及定时器的综合应用；应该包括的功能：左右都能滚动、鼠标移入暂停，移出重新滚动；</li>
<li>innerHTML: 可以用innerHTML+=innerHTML来使得某元素内的内容为两份的之前的内容；</li>
<li>在编写本节课程的时候一定不要不要忘记了加上<code>px</code>.</li>
</ul>
<h4 id="实例及代码-9"><a href="#实例及代码-9" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/NAvkQj/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/NAvkQj/" target="_blank" rel="noopener">JavaScript10</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-9"><a href="#测试题-9" class="headerlink" title="测试题"></a>测试题</h4><p>根据所学的知识，拓展本节课的实例功能：</p>
<blockquote>
<ol>
<li>增加滚动速度选项：可分为快、一般、慢，三种滚动速度。</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM基础》"><a href="#《DOM基础》" class="headerlink" title="《DOM基础》"></a>《DOM基础》</h3><h4 id="关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className"><a href="#关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className" class="headerlink" title="关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className"></a>关键词：DOM节点、childNodes、文本节点及元素节点、nodeType、children、parentNode、offsetParent、firstChild、lastChild、setAttribute、className</h4><ul>
<li>节点：和css中的标签、js中的元素是一个意思；</li>
<li>childNodes：子节点集合，包括文本节点及元素节点（在IE8下不包括空白的文本节点）</li>
<li>文本节点及元素节点：前者不包括在标签中，后者包含在标签中；</li>
<li>nodeType：节点类型；nodeType为3时为文本节点，nodeType为1时为元素节点；</li>
<li>children：子节点集合，不包括文本节点，只包含元素节点；</li>
<li>parentNode：元素父节点；</li>
<li>offsetParent：表示用于定位的父级；</li>
<li>firstChild： 第一个子节点（包括文本子节点）。firstElementChild则不包括文本子节点，只包括元素子节点，但是低版本IE不兼容，因此要用if语气来兼容；</li>
<li>setAttribute：用DOM方式操纵元素，语法为<code>setAttribute(name, value)</code>，与此类似的还有getAttribute，语法为<code>getAttribute(name)</code>，以及removeAttribute，语法为<code>removeAttribute(name)</code>；</li>
<li>className：类别名，结合判断能批量修改特定类别的元素，也可以将if函数及类别封装成固定的函数，方便调用；</li>
</ul>
<h4 id="实例及代码-10"><a href="#实例及代码-10" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EywNVV/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EywNVV/" target="_blank" rel="noopener">JavaScript11</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-10"><a href="#测试题-10" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的知识，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>将有特定class属性的div的第一个子节点的所有内容的字体改为times；</li>
<li>提示：需要使用firstChild及className的使用，注意兼容性；</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM操作应用》"><a href="#《DOM操作应用》" class="headerlink" title="《DOM操作应用》"></a>《DOM操作应用》</h3><h4 id="关键词：createElement、appendChild、insertBefore、removeChild、文档碎片"><a href="#关键词：createElement、appendChild、insertBefore、removeChild、文档碎片" class="headerlink" title="关键词：createElement、appendChild、insertBefore、removeChild、文档碎片"></a>关键词：createElement、appendChild、insertBefore、removeChild、文档碎片</h4><ul>
<li>creatElement： 创建元素，语法<code>createElement(element)</code>，创建完成后还需要添加到父节点才有效；</li>
<li>appendChild：将创建的元素添加到父节点，语法：<code>obj.appendChild(element)</code>，其中obj为父节点，element为创建出来的元素；如果appendChild的元素为现有的元素，那么使用这个属性的时候会先从现有的父级上删除，然后添加到新的父级里；</li>
<li>注意：不管是html中原有的，还是通过DOM创建出来的，性质都是一样的，没有区别；</li>
<li>insertBefore：在父节点内插入子节点，语法：<code>obj.insertBefore(element, obj[i])</code>表示在父节点obj中的第i个元素前面插入元素；但是如果obj中本来没有元素，那么就没法obj[i]就不存在，这时候还得用appendChild，所以这两个经常结合使用，解决兼容性问题；</li>
<li>removeChild：移除子节点，语法<code>obj.removeChild(element)</code>，其中obj为父节点，element为需要移除的元素；</li>
<li>文档碎片：文档碎片可以提高DOM操作性能（理论上），语法：<code>createDocumentFragment()</code>；（实际上在高级浏览器上，文档碎片几乎不会提高效率）</li>
</ul>
<h4 id="实例及代码-11"><a href="#实例及代码-11" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="219" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/zBEPKE/?height=219&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBEPKE/" target="_blank" rel="noopener">JavaScript12</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-11"><a href="#测试题-11" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个表格。两个按钮：一个增加表格行数，一个删除表格行数；</li>
<li>每次增加的行数都在第一行，删除则从最后一行开始；</li>
<li>顺便加上各行变色的小功能；</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM操作应用高级-01》"><a href="#《DOM操作应用高级-01》" class="headerlink" title="《DOM操作应用高级-01》"></a>《DOM操作应用高级-01》</h3><h4 id="关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase-、search-、"><a href="#关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase-、search-、" class="headerlink" title="关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase()、search()、"></a>关键词：tBodies、隔行变色、移入高亮、搜索、toLowerCase()、search()、</h4><ul>
<li>tBodies:选出tbody元素，相当于<code>getElementsByTagName(&#39;tbody&#39;)</code>，同样的还有tHead、tFoot、rows及cells；</li>
<li>搜索：需要的功能有——忽略大小写、模糊搜索、多关键词搜索；</li>
<li>toLowerCase:转化成小写；</li>
<li>search：搜索文本，如果搜索到则返回所在位置，未找到则返回-1；</li>
<li>split：切分字符串，语法为<code>str.split(&#39;aa&#39;)</code>，表示用aa来切分str，aa可以为空格或者任何字符；</li>
</ul>
<h4 id="实例及代码-12"><a href="#实例及代码-12" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/jAGxaz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/jAGxaz/" target="_blank" rel="noopener">JavaScript13</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>本程序具有的功能：</p>
<ol>
<li>表格隔行变色；</li>
<li>鼠标移入移除高亮；</li>
<li>手动输入添加内容，并同时保证功能1和2有效，而且自动标号不重复；</li>
<li>具有删除所添加行的功能，同时保证1和2的功能有效；</li>
<li>只能搜索，可忽略大小写及模糊搜索；</li>
</ol>
</blockquote>
<h4 id="测试题-12"><a href="#测试题-12" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学内容，完善上面的小程序：</p>
<blockquote>
<ol>
<li>加入多关键词搜索功能（结合split功能及search）；</li>
<li>搜索功能与上述功能1，2兼容；（目前我还没想到更好的办法去解决）</li>
</ol>
</blockquote>
<hr>
<h3 id="《DOM操作应用高级-02》"><a href="#《DOM操作应用高级-02》" class="headerlink" title="《DOM操作应用高级-02》"></a>《DOM操作应用高级-02》</h3><h4 id="关键词：排序、aLi、表单、onsubmit、onreset、表单验证"><a href="#关键词：排序、aLi、表单、onsubmit、onreset、表单验证" class="headerlink" title="关键词：排序、aLi、表单、onsubmit、onreset、表单验证"></a>关键词：排序、aLi、表单、onsubmit、onreset、表单验证</h4><ul>
<li>排序：中心思想是结合利用appendChild的移动功能及sort的排序功能；</li>
<li>aLi：aLi=document.getElementById(‘li’),虽然看起来像是数组，但却又不是正真的数组，它不具备sort、join等功能，确切来说这只是一个元素集合；</li>
<li>表单：用于向服务器提交数据，action为链接地址；</li>
<li>onsubmit：提交数据是发生的事件；</li>
<li>onreset：重置表单时发生的事件；</li>
<li>表单验证：阻止用户输入非法字符等；</li>
</ul>
<h4 id="实例及代码-13"><a href="#实例及代码-13" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/YWABXk/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/YWABXk/" target="_blank" rel="noopener">JavaScript14</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>本小程序就有的功能：</p>
<ol>
<li>所有上节课程序所具有的功能；<ol start="2">
<li>在上节课的基础上具有排序功能；</li>
<li>与课程相比，本排序功能具有选择性，即可根据所需要的排序依据进行排序；</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="测试题-13"><a href="#测试题-13" class="headerlink" title="测试题"></a>测试题</h4><p>表单内容比较简单，可利用表单完成下面一个小程序：</p>
<blockquote>
<ol>
<li>制作一个表单，包括用户名、密码和提交；</li>
<li>提交时会弹出一个确认页面；</li>
<li>具有重置内容；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动基础-01》"><a href="#《JS运动基础-01》" class="headerlink" title="《JS运动基础-01》"></a>《JS运动基础-01》</h3><h4 id="关键词：运动框架、分享侧边栏、图片淡入淡出"><a href="#关键词：运动框架、分享侧边栏、图片淡入淡出" class="headerlink" title="关键词：运动框架、分享侧边栏、图片淡入淡出"></a>关键词：运动框架、分享侧边栏、图片淡入淡出</h4><ul>
<li>运动：利用定时器及offsetLeft来实现；</li>
<li>框架完善过程：<ol>
<li>到指定地点停止；</li>
<li>点击后，运动前先清除定时器，保证每次只有一个定时器处于工作状态；</li>
</ol>
</li>
<li>分享侧边栏：鼠标移入移出，运动方向相反；</li>
<li>图片淡入淡出：鼠标移入移出改变图片的透明度；</li>
</ul>
<h4 id="实例及代码-14"><a href="#实例及代码-14" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="353" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/XKZwyK/?height=353&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/XKZwyK/" target="_blank" rel="noopener">JavaScript15</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p><strong>注意：变量申明的位置非常重要，变量申明的位置能够直接影响到变量的值是否收到函数的影响</strong></p>
<h4 id="测试题-14"><a href="#测试题-14" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的运动框架的学习，完成下面的小程序：</p>
<blockquote>
<ol>
<li>新建一个分享侧边栏，侧边栏上有个小标签；</li>
<li>将整个div布局在视窗的左下角；</li>
<li>正常情况下侧边栏只有标签能看到，鼠标移入时，整个div出现，移出div后0.5s后侧边栏又隐藏到视窗外；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动基础-02》"><a href="#《JS运动基础-02》" class="headerlink" title="《JS运动基础-02》"></a>《JS运动基础-02》</h3><h4 id="关键词：缓冲运动、Math、右侧悬浮框"><a href="#关键词：缓冲运动、Math、右侧悬浮框" class="headerlink" title="关键词：缓冲运动、Math、右侧悬浮框"></a>关键词：缓冲运动、Math、右侧悬浮框</h4><ul>
<li>缓冲运动：运动速度与到目标位置相关；</li>
<li>Math：数学函数，常用的有Math.ceil()，表示向上取整；Math.floor()，表示向下取整；由于目标值可能大于也可能小于现在的值，所以需要根据速度来判断是向上还是向下取整，这时候就可以利用三元运算符简单的判断一下了，具体的操作可以在下面的实例中看到；Math.abs()，表示的是取绝对值，在匀速运动的停止条件的时候能用到；</li>
<li>匀速运动时，由于速度可能不能被运动量整除，那么为了正好达到目标，可以定义在距离目标近到一定程度（绝对值小于速度值）的时候，直接让程序到达目标点；在缓冲运动中由于运动在最后，速度值可能会是小数，而浏览器默认会将小数部分舍去，所以达不到目标，为了达到目标，只要直接对速度进行取整（整数时向上取整，负数时向下取整），保证在速度为小数时也能继续运动；</li>
</ul>
<h4 id="实例及代码-15"><a href="#实例及代码-15" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/zBPaLv/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBPaLv/" target="_blank" rel="noopener">JavaScript16</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>本程序具有的功能：</p>
<ol>
<li>这个小程序就综合了匀速运动与缓冲运动，水平方向上为匀速运动，竖直方向为缓冲运动；</li>
<li>注意：特别需要小心的是在写尺寸的时候别忘了加上“px”，否则代码无效而且不会报错！</li>
</ol>
</blockquote>
<h4 id="测试题-15"><a href="#测试题-15" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节缩写的内容，完成制作一个缓冲样式的滚动条，具体如下：</p>
<blockquote>
<ol>
<li>缓冲条位于视窗的右侧中间位置；</li>
<li>不管是向上滚动还是向下滚动，缓冲后滚动条都会停止在视窗右侧中间；</li>
<li>停止运动时不能抖动（用到parseInt属性）；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动应用-01》"><a href="#《JS运动应用-01》" class="headerlink" title="《JS运动应用-01》"></a>《JS运动应用-01》</h3><h4 id="关键词：多物体同时运动、offsetWidth、任意值运动框架"><a href="#关键词：多物体同时运动、offsetWidth、任意值运动框架" class="headerlink" title="关键词：多物体同时运动、offsetWidth、任意值运动框架"></a>关键词：多物体同时运动、offsetWidth、任意值运动框架</h4><ul>
<li>多物体运动框架：将定时器变成元素的属性，那么调用时则不会相互干扰；（例子：改变div的长度，互不影响；或者改变透明度；）</li>
<li>补充：在多物体运动的情况下，所有的属性都不能共用，例如上面提到的透明度，需要先把透明度赋值给一个变量，那么就需要将这个变量变成所有需要调用的对象的属性；</li>
<li>offsetWidth：本节讨论到了与offset相关的属性，<strong>提到这是包含padding及border的属性</strong>，那么在有border的情况下，前面的例子就会有一定的变化；为了避免因为border及padding带来的影响，建议使用本身的属性来带入程序（因为一般样式属性写在样式表中，那么就会用到之前学到的currentStyle活getComputeStyle属性了）；</li>
<li>任意值运动框架：一套运动框架能控制几乎所有的属性变化，其包含三个属性：作用对象、作用属性、变化值；</li>
</ul>
<h4 id="代码及实例"><a href="#代码及实例" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/mEqNoE/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/mEqNoE/" target="_blank" rel="noopener">JavaScript17</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-16"><a href="#测试题-16" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的知识，制作如下一个小程序：</p>
<blockquote>
<ol>
<li>自己重写一个完美运动框架；</li>
<li>利用这个框架来改变不同的样式，但是别包括上面已经写过的长度、宽度或者透明度；</li>
<li>给对象加上border属性后检查效果是否仍然相符。</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动应用-02》"><a href="#《JS运动应用-02》" class="headerlink" title="《JS运动应用-02》"></a>《JS运动应用-02》</h3><h4 id="关键词：仿flash运动"><a href="#关键词：仿flash运动" class="headerlink" title="关键词：仿flash运动"></a>关键词：仿flash运动</h4><ul>
<li>仿flash运动：这个小程序结合了近几节课所学的知识点，非常值得联系，具体的实现过程如下：<ol>
<li>左右按钮移入移出显示隐藏；（包括在左右键上）；</li>
<li>点击小图能起到切换大图的功能（更改大图的Zindex–写在行间为Zindex，写在样式表中为Z-index，缓冲运动改高度）；切换之前需要判断切换到的是否为当前，如果为当前则不发生变化；</li>
<li>点击时，小图除切换功能外还会变成不透明；所有的小图移入移出透明度都有变化，但是当前图片移出时不变化；</li>
<li>增加左右按钮点击时大图切换的功能；（第一张图及最后一张图的时候则开始自循环）</li>
<li>点击左右按钮时除了大图要切换，小图也需要滚动，而且也要注意第一张及最后一张的特殊情况；</li>
<li>增加自动播放的功能，也加入鼠标移入移出时的消除启动播放；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码-16"><a href="#实例及代码-16" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="769" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/grorbK/?height=769&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/grorbK/" target="_blank" rel="noopener">JavaScript18</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>注：</p>
<ol>
<li>本程序实现的过程中没有利用课程中所讲到的利用Z-index属性的叠加，而是利用了之前课程中学到的轮播，效果算是各有特色；</li>
<li>实现的过程中发现布局对JS的影响非常大，第一次跟着课程实现效果的时候因为CSS还学习的很糟糕，所以就知识重写了JS部分，这次再重写的时候，写到CSS才发现为什么用到Z-index，以及不用也行的道理；</li>
<li>实践出真知。</li>
</ol>
</blockquote>
<h4 id="测试题-17"><a href="#测试题-17" class="headerlink" title="测试题"></a>测试题</h4><p>根据这节课所学到的知识点，完成下面的小程序：</p>
<blockquote>
<ol>
<li>利用Z-index或者我上面使用的轮播的形式重写一次这个程序，巩固学习效果；</li>
<li>所重写的程序应该具有上面提到的所有功能；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS运动中级》"><a href="#《JS运动中级》" class="headerlink" title="《JS运动中级》"></a>《JS运动中级》</h3><h4 id="关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）"><a href="#关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）" class="headerlink" title="关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）"></a>关键词：链式运动（土豆提示栏）、完美运动框架（新浪微博）</h4><ul>
<li>链式运动：完成一个运动之后，开始另一个运动。原理即为在原来的运动框架中加入一个函数参数，即在动作完成的部分加入一条新的语句；</li>
<li>完美运动：结合json及运动框架，构建一个完美运动框架，能同时改变多个属性值；（注意：在同时改变多个属性值的时候，需要所有值都达到目标值后才能关闭定时器）；</li>
</ul>
<h4 id="实例及代码-17"><a href="#实例及代码-17" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/groGqv/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/groGqv/" target="_blank" rel="noopener">JavaScript19</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>注：</p>
<ol>
<li>本例为完美运动框架的简单运用，这个运动框架能满足多个元素属性值的同时改变直到所有的属性值都达到目标值才停止；</li>
</ol>
</blockquote>
<h4 id="测试题-18"><a href="#测试题-18" class="headerlink" title="测试题"></a>测试题</h4><p>根据这节课所学到的完美运动框架，写出下面一个小程序：</p>
<blockquote>
<ol>
<li>形式如新浪微博的新消息发布；</li>
<li>点击发布后，公告栏则会生成输入的信息；</li>
<li>信息显示按时间排布，最新的消息显示在最上端；</li>
<li>新生成消息的过程加上完美运动框架，达到高度缓慢撑开，透明度逐渐增加的效果；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件基础》"><a href="#《JS事件基础》" class="headerlink" title="《JS事件基础》"></a>《JS事件基础》</h3><h4 id="关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性"><a href="#关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性" class="headerlink" title="关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性"></a>关键词：event对象、document、事件流（事件冒泡）、鼠标事件、keyCode、其他属性</h4><ul>
<li>event对象：事件对象，应用在IE6-8及高版本的chrome浏览器，在低版本的chrome浏览器及Firefox中需要用到一个参数：ev，在调用函数时，系统就将这个参数传给函数；为了解决这个兼容问题，可以用一个“或”的表达式，例如：<code>var oEvent=event||ev;</code>，然后调用的时候，直接用oEvent就好了；</li>
<li>document：包含整个页面的内容，上至&lt;!DOCTYPE html&gt;，下至;如果需要给整个页面加点击事件，应该加在document上而不是body上，因为body的范围由它所包含的内容决定；</li>
<li>事件流：最简单的一个事件流的例子——事件冒泡（一般会带来一些困扰，所以很多时候需要取消冒泡：通过事件对象来解决——<code>oEvent.cancelBubble=true;</code>，典型的例子为仿select下拉框）；</li>
<li>鼠标事件：鼠标坐标，clientX及clientY(表示的是可视区的坐标，所有如果有滚动的时候需要加上scrollTop和scrollLeft)；</li>
<li>keyCode：表示键盘上按键的键码，按键事件为onkeydown及onkeyup；（按键卡顿现象：照顾特殊人群，但是会造成不好的影响，解决方案为将事件加上setInterval函数来将延迟给掩饰掉，按键抬起时清除定时器）；</li>
<li>其他属性：ctrlKey，shiftKey、altKey，使用的时候都需要结合事件对象，例如：<code>oEvent.ctrlKey</code>；</li>
</ul>
<h4 id="实例及代码-18"><a href="#实例及代码-18" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/EyQxLk/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/EyQxLk/" target="_blank" rel="noopener">JavaScript20</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<blockquote>
<p>注：</p>
<ol>
<li>在输入框中输入任意字符；</li>
<li>鼠标点击enter或者直接用键盘enter；</li>
<li>移动鼠标就能按到效果，输入的字符越多，效果越明显；</li>
<li>如果未输入任何字符，那么将会提示输入；</li>
</ol>
</blockquote>
<h4 id="测试题-19"><a href="#测试题-19" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的鼠标及键盘事件，写出下面一个小程序：</p>
<blockquote>
<ol>
<li>能通过鼠标及键盘控制一个div的运动；</li>
<li>需要将scroll因素考虑在移动的范围内；</li>
<li>需要避免连续按住不放时产生的卡顿现象（利用定时器）；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件中级》"><a href="#《JS事件中级》" class="headerlink" title="《JS事件中级》"></a>《JS事件中级》</h3><h4 id="关键词：默认行为、拖拽"><a href="#关键词：默认行为、拖拽" class="headerlink" title="关键词：默认行为、拖拽"></a>关键词：默认行为、拖拽</h4><ul>
<li>默认行为：浏览器自带的一些行为，有些时候需要阻止系统自带的默认行为，加上自己设置的行为；（比如右键菜单-oncontextmenu）<ol>
<li>阻止右键菜单：需要阻止时，直接oncontexmenu函数返回为false即可；自己设置一个菜单，并且在鼠标右键的时候改变display属性，将定制菜单的位置改为鼠标的位置，然后在页面空白处点击的时候（给document加上onclick事件）将定制菜单栏收回；</li>
<li>设置一个只能输入数字的输入框：默认时，在输入框按下按键则会在输入框显示相应字符或者操作。这也是一种默认行为，当onkeydown事件返回为false的时候，则能阻止这种默认行为。结合keyCode和阻止这种默认事件的功能，则可以设计一个能输入数字及特定按钮（如方向键及退格键）功能的小程序；</li>
</ol>
</li>
<li>拖拽：保证鼠标的位置及被拖动元素的相对位置不变，需要注意的点如下：<ol>
<li>应该是只有杂鼠标按下之后才能移动，鼠标抬起时移动停止；</li>
<li>对于鼠标快速移动时可能移出元素范围带来的移动异常，将移动事件加在document上即可解决；</li>
<li>当移动出视窗时释放鼠标按键，仍然能够移动，为了解决这个问题，需要将鼠标释放按钮事件也加在document上；</li>
<li>在Firefox中拖拽空元素的时候会出现重影，这也是FF中的一种默认事件，可以用返回false的方法来组织这个bug；</li>
<li>被拖拽元素被拖出视窗范围，这时候就可以判断来阻止元素被拖出视窗；</li>
</ol>
</li>
</ul>
<h4 id="实例及代码-19"><a href="#实例及代码-19" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/zBRKYz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/zBRKYz/" target="_blank" rel="noopener">JavaScript21</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-20"><a href="#测试题-20" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，制作一个小程序：</p>
<blockquote>
<ol>
<li>在整个页面组织右键菜单的默认属性；</li>
<li>自己定制一个菜单栏，里面可以包括一些链接之类的；</li>
<li>页面空白处单击则菜单栏消失；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件高级应用-01》"><a href="#《JS事件高级应用-01》" class="headerlink" title="《JS事件高级应用-01》"></a>《JS事件高级应用-01》</h3><h4 id="关键词：事件绑定、高级拖拽"><a href="#关键词：事件绑定、高级拖拽" class="headerlink" title="关键词：事件绑定、高级拖拽"></a>关键词：事件绑定、高级拖拽</h4><ul>
<li>事件绑定：attachEvent(name, function)，可以将多个函数加到同一个事件上，在chrome及FF上不兼容，为了兼容需要用到addEventListener（name，function，false）（此属性也不兼容IE9以下的IE浏览器）。所以为了都兼容，应该使用一个判断函数整合这个属性的不同写法，但是要注意addEventListerner属性中的事件是没有“on”的（具体写法可见实例）；</li>
<li>高级拖拽：新增功能———— 1.不拖出父级div或者其他指定对象的区域；2.边缘吸附；3.利用事件捕获来解决在低版本IE下拖拽时会选中文字的问题，setCapture（只兼容IE，功能是将页面的所有事件都集中在加了事件捕获的对象上），与之相应的为releaseCapture，即解除对象的捕获；</li>
</ul>
<h4 id="代码及实例-1"><a href="#代码及实例-1" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/qNoPxz/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/qNoPxz/" target="_blank" rel="noopener">JavaScript22</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>这个小程序所具有的功能：</p>
<blockquote>
<ol>
<li>事件绑定，点击内部的div后会弹出两次会话框；</li>
<li>可以在指定外框自由移动；</li>
<li>不会产生移动时文字的选中；</li>
<li>兼容低版本的IE浏览器；</li>
</ol>
</blockquote>
<h4 id="测试题-21"><a href="#测试题-21" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，重写事件绑定及完美拖拽的小程序，特别注意以下两点：</p>
<blockquote>
<ol>
<li>兼容性问题；</li>
<li>代码重用性；</li>
</ol>
</blockquote>
<hr>
<h3 id="《JS事件高级应用-02》"><a href="#《JS事件高级应用-02》" class="headerlink" title="《JS事件高级应用-02》"></a>《JS事件高级应用-02》</h3><h4 id="关键词：带框拖拽、自定义滚动条"><a href="#关键词：带框拖拽、自定义滚动条" class="headerlink" title="关键词：带框拖拽、自定义滚动条"></a>关键词：带框拖拽、自定义滚动条</h4><ul>
<li>带框拖拽：预先设置一个样式，按下鼠标产生一个div并赋予样式，div的大小与框相同，位置与框相同，移动时只移动框，松开鼠标时才移动框，并且将产生的div移出；</li>
<li>自定义滚动条：控制对象的大小、透明度、文字滚动等；</li>
</ul>
<h4 id="代码及实例-2"><a href="#代码及实例-2" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/wWmQjx/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/wWmQjx/" target="_blank" rel="noopener">JavaScript23</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>这个小程序具有的功能：</p>
<blockquote>
<ol>
<li>利用滚动条能控制div的大小；</li>
<li>div具有带框移动的功能；</li>
</ol>
</blockquote>
<h4 id="测试题-22"><a href="#测试题-22" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的知识，制作一个自定义的滚动条：</p>
<blockquote>
<ol>
<li>自定义滚动条样式；</li>
<li>能实现通过滚动来控制文字上下翻转的功能；</li>
</ol>
</blockquote>
<hr>
<h3 id="《Ajax基础》"><a href="#《Ajax基础》" class="headerlink" title="《Ajax基础》"></a>《Ajax基础》</h3><h4 id="关键词：服务器、字符集编码、缓存、eval、Ajax原理"><a href="#关键词：服务器、字符集编码、缓存、eval、Ajax原理" class="headerlink" title="关键词：服务器、字符集编码、缓存、eval、Ajax原理"></a>关键词：服务器、字符集编码、缓存、eval、Ajax原理</h4><ul>
<li>服务器：有两种含义：一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器；运行以上软件的计算机，或称为网络主机（Host）。（我自己用的服务器程序为XAMPP）</li>
<li>字符集编码：把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递；</li>
<li>缓存：存储在本地电脑中的资料，通过url来识别是否为同一网站，所以为了避免缓存带来不好的影响，可以通过加上一个时间戳的方式来解决这个问题；</li>
<li>eval：将语句解析成js能够识别的内容；</li>
<li>Ajax原理：<ol>
<li>http请求分为两种方式： get方式及post方式；前者提交的数据直接加在网址上，而后者通过http content传递；前者长度有限制（容量小，不适合传输数据），后者可传输容量较大的数据；前者安全性较差，后者安全性较好；前者有缓存，后者无缓存；因此前者适合获取数据，后者适合上传数据；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例-3"><a href="#代码及实例-3" class="headerlink" title="代码及实例"></a>代码及实例</h4><p>由于本节需要用到本地服务器，因此这里就不上传实例了。</p>
<h4 id="测试题-23"><a href="#测试题-23" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的内容，完成小程序：</p>
<blockquote>
<ol>
<li>搭建本地服务器（我自己用的是XAMPP);</li>
<li>结合已有的ajax文件（如果自己不会写，可参照下节内容中的源代码），新建一个html及txt文本来创建一个实时更新显示内容的页面（通过按钮）；</li>
</ol>
</blockquote>
<hr>
<h3 id="《Ajax中级》"><a href="#《Ajax中级》" class="headerlink" title="《Ajax中级》"></a>《Ajax中级》</h3><h4 id="关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText"><a href="#关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText" class="headerlink" title="关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText"></a>关键词：编写Ajax对象、接收状态值、onreadystatechange、responseText</h4><ul>
<li>编写Ajax对象：<ol>
<li>创建Ajax对象；</li>
<li>连接到服务器；</li>
<li>发送请求；</li>
<li>接收返回值；</li>
</ol>
</li>
<li>注意：在JS中利用没有定义的变量时会弹出错误，而利用没有定义的属性时则会提示undifined；</li>
<li>接收状态值（readyState）：<ol>
<li>0 （未初始化）还没有调用open（）方法；</li>
<li>1 （载入）已调用send（）方法，正在发送请求；</li>
<li>2 （载入完成）send（）方法完成，已收到全部相应内容；</li>
<li>3 （解析）正在解析相应内容；</li>
<li>4 （完成）相应内容解析完成，可以在客户端调用了；</li>
</ol>
</li>
<li>http状态码（status）：最常见的为200，表示读取成功；</li>
<li>onreadystatechange: 表示返回状态；</li>
<li>responseText: 读取的文件内容；</li>
</ul>
<h4 id="实例及代码-20"><a href="#实例及代码-20" class="headerlink" title="实例及代码"></a>实例及代码</h4><p>由于本节也需要在本地服务器运行，所以只能讲代码贴出来，ajax代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">url, fnsucc, fnfail</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. Set a new ajax object:</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">        <span class="keyword">var</span> oAjax=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> oAjax=<span class="keyword">new</span> ActivaXObject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Get connected:</span></span><br><span class="line">    oAjax.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Send the request:</span></span><br><span class="line">    oAjax.send();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Get data back:</span></span><br><span class="line">    oAjax.onreadystatechange=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oAjax.status==<span class="number">200</span>)&#123;</span><br><span class="line">                fnsucc(oAjax.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fnfail)&#123;</span><br><span class="line">                    fnfail(oAjax.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="测试题-24"><a href="#测试题-24" class="headerlink" title="测试题"></a>测试题</h4><p>由于本节所学的内容比较单一，所以根据本节所学的内容自己手写一个完整的Ajax程序。</p>
<hr>
<h3 id="《JS面向对象基础-01》"><a href="#《JS面向对象基础-01》" class="headerlink" title="《JS面向对象基础-01》"></a>《JS面向对象基础-01》</h3><h4 id="关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、"><a href="#关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、" class="headerlink" title="关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、"></a>关键词：面向对象、对象组成、this、object对象、构造函数、工厂方式、</h4><ul>
<li>面向对象：对象是一个整体，对外提供一些操作；面向对象指的是使用对象时只关注对象提供的功能，而不关注其内部细节；（这是一种通用思想，而非只在编程中适用）</li>
<li>JS中面向对象：简称OOP，具有以下三个特点：<ol>
<li>抽象：抓住主要问题；</li>
<li>封装：不考虑内部实现，只考虑功能使用；</li>
<li>继承：从已有对象上，继承出新的对象，可以最大限度重用现有代码，包括多重继承（继承多个对象的功能）和多态；</li>
</ol>
</li>
<li>对象组成：包括方法和属性<ol>
<li>方法：和函数类似，函数是自由的，但方法具有归属的对象，这两者都是过程量，是动态的；</li>
<li>属性：和变量类似，变量时自由的，但属性具有归属的对象，这两者都是状态量，是静态的；</li>
</ol>
</li>
<li>this：当前的方法属于谁就指向谁；</li>
<li>注意：不能在系统对象中随意附加方法、属性，否则会覆盖已有方法、属性；</li>
<li>object对象：空白对象；</li>
<li>构造函数：用于构造一个对象的函数，功能与普通函数一样；</li>
<li>工厂方式：创建空白对象，加工对象，返回对象；缺点：创建时没有’new’，函数重复导致资源浪费；</li>
</ul>
<h4 id="实例及代码-21"><a href="#实例及代码-21" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="304" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJQmL/?height=304&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJQmL/" target="_blank" rel="noopener">JavaScript26</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-25"><a href="#测试题-25" class="headerlink" title="测试题"></a>测试题</h4><p>用工厂方式重写一个面向对象的程序。</p>
<hr>
<h3 id="《JS面向对象基础-02》"><a href="#《JS面向对象基础-02》" class="headerlink" title="《JS面向对象基础-02》"></a>《JS面向对象基础-02》</h3><h4 id="关键词：new、原型-prototype-、类和对象、对象命名规范"><a href="#关键词：new、原型-prototype-、类和对象、对象命名规范" class="headerlink" title="关键词：new、原型(prototype)、类和对象、对象命名规范"></a>关键词：new、原型(prototype)、类和对象、对象命名规范</h4><ul>
<li>new：通过new+构造函数来构造对象，可以理解为“new”会先通过系统在函数内部创建<code>var this=new Object()</code>这个对象，然后在最后的时候又自动返回<code>return this</code>这个对象，这样理解之后，面向对象的方式和工厂方式原理上也是一样的；</li>
<li>原型(prototype)：可以理解为css中的class， 能够同时给多个对象加方法；</li>
<li>类和对象：前者不具备实际功能，而后者具有，它们之间的关系就相当于模子和产品的关系；为了同时给多个对象加方法，那么就需要在类上面加原型，既可以给系统对象加也可以在创建的对象加；</li>
<li>注意：用构造函数加属性，用原型加方法。区别于工厂方式，这种方式叫做混合的构造函数/原型方式，简称混合方式构造对象；</li>
<li>对象命名规范：为了和系统对象保持一致，自己构造出来的对象命名时最好也保持首字母大写；</li>
</ul>
<h4 id="实例及代码-22"><a href="#实例及代码-22" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/OXkrVB/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/OXkrVB/" target="_blank" rel="noopener">JavaScript27</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-26"><a href="#测试题-26" class="headerlink" title="测试题"></a>测试题</h4><p>用混合方式重写一个面向对象的小程序。</p>
<hr>
<h3 id="《JS面向对象实例》"><a href="#《JS面向对象实例》" class="headerlink" title="《JS面向对象实例》"></a>《JS面向对象实例》</h3><h4 id="关键词：将面向过程的函数改写成面向对象的形式"><a href="#关键词：将面向过程的函数改写成面向对象的形式" class="headerlink" title="关键词：将面向过程的函数改写成面向对象的形式"></a>关键词：将面向过程的函数改写成面向对象的形式</h4><ul>
<li>改写：<ol>
<li>不能有函数嵌套，但可以有全局变量；</li>
<li>将onload改写成构造函数，将全局变量改写成属性，将函数改写成方法；</li>
<li>debug，主要容易出现在this、事件、闭包及传参上；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例-4"><a href="#代码及实例-4" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/jAxqQa/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/jAxqQa/" target="_blank" rel="noopener">JavaScript28</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-27"><a href="#测试题-27" class="headerlink" title="测试题"></a>测试题</h4><p>按照这节课所学的内容，利用面向对象的方式重写选项卡或者之前写过的任何一个程序。</p>
<hr>
<h3 id="《JS面向对象高级》"><a href="#《JS面向对象高级》" class="headerlink" title="《JS面向对象高级》"></a>《JS面向对象高级》</h3><h4 id="关键词：Json方式、命名空间、继承、call、引用、系统对象"><a href="#关键词：Json方式、命名空间、继承、call、引用、系统对象" class="headerlink" title="关键词：Json方式、命名空间、继承、call、引用、系统对象"></a>关键词：Json方式、命名空间、继承、call、引用、系统对象</h4><ul>
<li>Json方式面对对象：用Json的方式来实现对象虽然比较简单，但是如果对象超过一个，那么又回到了之前写对象的方法。这种方式也有人叫做单体方式。</li>
<li>命名空间：在不同的Json中写具有相同名字的函数，可以让具有相同名字的函数同时工作；</li>
<li>继承：能够继承父级的属性和方法；</li>
<li>call：通过call的方式调用属性时，如果call传入的参数，则参数会替换掉函数中的this；</li>
<li>引用：通过<code>=</code>号使数组、方法或者其他相等的时候，系统会将等号两边指向同一内存位置，所以不管是针对谁做出改变，最终的结果是两者都会发生改变。比如：有两个数组A和B，其中A中有1，2，3，三个变量，又有A=B，这时候如果在B中push一个变量4，那么数组A中也会存在这个变量。为了解决这个问题，可以利用循环将A中的变量一个个都push到数组B中；</li>
<li>总结：属性的继承利用call，方法的继承利用循环；</li>
<li>系统对象：本地对象（非静态对象，如Object/Function/Array/String等），内置对象（静态对象，如Global/Math）,宿主对象（由浏览器提供，如BOM/DOM）；</li>
</ul>
<h4 id="实例及代码-23"><a href="#实例及代码-23" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="265" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJpzZ/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJpzZ/" target="_blank" rel="noopener">JavaScript29</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-28"><a href="#测试题-28" class="headerlink" title="测试题"></a>测试题</h4><p>利用继承的特点，用面向对象的方式重写拖拽的小程序。</p>
<hr>
<h3 id="《BOM应用》"><a href="#《BOM应用》" class="headerlink" title="《BOM应用》"></a>《BOM应用》</h3><h4 id="关键词：BOM基础"><a href="#关键词：BOM基础" class="headerlink" title="关键词：BOM基础"></a>关键词：BOM基础</h4><ul>
<li>BOM基础：<ol>
<li>window.open(a, b) 打开新的页面，b表示是打开的新窗口是显示在本页还是新的页面；</li>
<li>window.close() FF中不能用这个去关闭非脚本打开的窗口；</li>
<li>document.write() 先清空，然后写入；</li>
<li>window.navigator.userAgent 表示的是浏览器的类型及版本；</li>
<li>window.location 表示当前页面的地址；</li>
<li>document.documentElement.clientWidth及document.documentElement.clientHeight：表示可视区的宽度及高度；</li>
<li>document.documentElement.scrollTop(IE)及document.body.scrollTop（chrome）：表示滚动条高度；</li>
<li>window.onscroll及window.onresize分别表示在页面滚动及更改窗口尺寸时发生的事件；</li>
<li>alert/confirm/prompt: 系统对话框；</li>
</ol>
</li>
</ul>
<h4 id="代码及实例-5"><a href="#代码及实例-5" class="headerlink" title="代码及实例"></a>代码及实例</h4><iframe height="250" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/dXZRXY/?height=250&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/dXZRXY/" target="_blank" rel="noopener">JavaScript30</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-29"><a href="#测试题-29" class="headerlink" title="测试题"></a>测试题</h4><p>由于本节课所学的大部分为基础知识，应用都较简单，所以可重写上例中的小程序，巩固知识点。</p>
<hr>
<h3 id="《COOKIES基础与应用》"><a href="#《COOKIES基础与应用》" class="headerlink" title="《COOKIES基础与应用》"></a>《COOKIES基础与应用》</h3><h4 id="关键词：cookie、setDate-、读取cookie、删除cookie"><a href="#关键词：cookie、setDate-、读取cookie、删除cookie" class="headerlink" title="关键词：cookie、setDate()、读取cookie、删除cookie"></a>关键词：cookie、setDate()、读取cookie、删除cookie</h4><ul>
<li>cookie：<ol>
<li>页面用来保存信息；</li>
<li>同一个网站共享一套cookie；</li>
<li>数量、大小有限（一般数量小于50，大小不超过4k或10k）；</li>
<li>有过期时间；（expires）</li>
<li>使用方式<code>document.cookie=&#39;name=value&#39;</code>;</li>
</ol>
</li>
<li>setDate(): 相对于getDate()获取系统时间，setDate()能够设置对象的时间；</li>
<li>读取cookie：需要利用字符串分割，具体见例子；</li>
<li>删除cookie：设置需要删除的cookie的有效期为’-1’即可；</li>
</ul>
<h4 id="实例及代码-24"><a href="#实例及代码-24" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="224" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJOBL/?height=224&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJOBL/" target="_blank" rel="noopener">JavaScript31</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-30"><a href="#测试题-30" class="headerlink" title="测试题"></a>测试题</h4><p>在FireFox浏览器的环境下尝试使用cookie的相关功能，具体写法可参考上面的实例。</p>
<hr>
<h3 id="《JS中的正则表达式》"><a href="#《JS中的正则表达式》" class="headerlink" title="《JS中的正则表达式》"></a>《JS中的正则表达式》</h3><h4 id="关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test"><a href="#关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test" class="headerlink" title="关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test"></a>关键词：正则基础、正在表达式、写法、match、replace、元字符、转义字符、量词、test</h4><ul>
<li>正则基础：了解正则表达式需要从字符串操作开始，最常见的字符串操作如下<ol>
<li>name.search(a): 表示的是在name中查找a，并返回a的位置；如果不存在则返回-1；</li>
<li>name.substring(value1, value2): 表示在name中截取从第value1到value2（不包括结束位置）的字符；如果只给一个参数，则返回至最后一位；</li>
<li>name.charAt(value): 表示获取字符串的某一位；</li>
<li>name.split(s):利用s来切分name，其中s可以是字符串或者符号；</li>
</ol>
</li>
<li>正则表达式：舶来语，表示的是一套规则，这套规则是计算机可识别的；</li>
<li>写法：JS风格（新建对象，然后使用对象），Perl风格（正则最早是出现在perl语言中）；</li>
<li>match: 提取所有复合条件的元素；<code>i</code>表示忽略大小写，<code>g</code>表示全局搜索；</li>
<li>replace：替换复合要求的元素，用法为：<code>name.replace(a, b)</code>表示将name中的a替换成b（如果有多个，则只替换第一个，除非用正则匹配全局），常用于敏感词过滤；</li>
<li>元字符：用<code>[]</code>表示，<code>[abc]</code>表示a、b、c中的任意一个，<code>[a-z]</code>表示从所有字母，数字同理。<code>[^a]</code>表示出了a；</li>
<li>转义字符：<ol>
<li>\d  表示数字                    \D  表示除了数字</li>
<li>\w  表示英文、数字和下划线       \W  表示除了英文、数字和下划线</li>
<li>\s  空白字符                    \S  表示除了空白字符</li>
<li>.   表示任意字符，很容易出错，不建议使用；</li>
</ol>
</li>
<li>量词：表示个数，用{}<ol>
<li>{n}      表示正好出现n次；</li>
<li>{n, m}   最少n次，最多m次；</li>
<li>{n, }    最少n次，最多无限；</li>
<li><ul>
<li>相当于{1，}，即最少出现1次；</li>
</ul>
</li>
<li>?       相当于{0，1}，即可有可无；</li>
<li><ul>
<li>相当于{0，}，表示可有可无，而且出现多少次都无所谓，很容易出错，不建议使用；</li>
</ul>
</li>
</ol>
</li>
<li>test：<code>reg.test(name)</code>，用于检测name是否符合reg所表示的正则，如果符合则返回true；需要注意的是，只要name一部分符合reg的要求就会返回true，这时候就需要用到<code>^</code>及<code>$</code>，分别表示行首和行尾；</li>
</ul>
<h4 id="实例及代码-25"><a href="#实例及代码-25" class="headerlink" title="实例及代码"></a>实例及代码</h4><iframe height="335" scrolling="no" src="//codepen.io/Leon-Zhao/embed/preview/WxJrPO/?height=335&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/Leon-Zhao/pen/WxJrPO/" target="_blank" rel="noopener">JavaScript32</a> by Leon (<a href="http://codepen.io/Leon-Zhao" target="_blank" rel="noopener">@Leon-Zhao</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h4 id="测试题-31"><a href="#测试题-31" class="headerlink" title="测试题"></a>测试题</h4><p>根据本节所学的正则表达式，制作一个这样的小程序：</p>
<blockquote>
<ol>
<li>能够识别输入的数字是否为电话号码；</li>
<li>如果不是电话号码则弹出“输入的不是电话号码”；</li>
<li>如果符合要求则弹出“输入成功”。</li>
</ol>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从开始学习这门课程到今天正好两个月。当时虽然也已经花了将近一个月的时间去学习JS，但还是感觉很茫然，直到开始学习这门课程。最初是看视频跟着老师的讲解一步一步的写程序，学习完一遍以后，自知很多知识点掌握的还不是很牢固，然后果断作出了复习一遍，重写所有程序的决定。复习的时候，先是重新看一遍老师的讲解，巩固基础知识，然后将当节课的知识点尽量综合起来放在一个程序里面重写出来，这个过程就是举一反三的过程。举几个例子：</p>
<blockquote>
<ol>
<li>第五节课制作日历，第一遍写的时候没有写任何布局相关的内容，重写时所有的css、js和html都是独立完成；</li>
<li>第九节课制作超酷时钟，同样关系到布局问题，而且首次结合图床来写程序；</li>
<li>第十三节课DOM高级应用，将这节课中所学的所有功能都集中在了一起，并且增加了按要求排序这个课程中并没有讲到的功能，而且没有bug；</li>
<li>第十八节课仿flash运动，这个小程序是目前写过的功能最多的程序了，而且实现过程并非照搬老师的讲解，实现的效果也基本一致；</li>
<li>……</li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在复习的过程中，对知识点的理解和掌握程度远远超过第一次学习。这个过程中积攒了些许经验，希望能和大家分享：</p>
<blockquote>
<ol>
<li>写程序之前先理清逻辑关系，否则debug的时候很难发现问题；</li>
<li>动手写比脑子想更重要，看似很简单很套路的知识点，如果自己不去套路一遍，这个套路就不属于你；</li>
<li>有足够的耐心。debug是个很烦人却又很让人兴奋的过程，程序成功运行的瞬间，所有debug的烦恼都消失了；</li>
<li>善用搜索引擎。前端发展了这么多年，我们所踩得坑前人都已经踩烂了，只要有疑问，直接搜关键词基本上都能搜出相关的博客或者问题；</li>
<li>不要好高骛远。基础知识永远不会过时。</li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;毋庸置疑，本课程非常适合新手学习，但同时也不难发现课程中很少触及真正基础的知识，而且后面还有一部分内容并没有讲到。下一步，我将通过书本继续巩固基础知识，同时开始学习JS框架，准备开始做几个简单的项目。这些内容都会在之后的博客中更新。<br>&nbsp;&nbsp;&nbsp;&nbsp;最后，作为一个初学者，我深知在学习过程中的种种疑惑和迷茫，即使在现在，这份心情依然存在。然而，只要不放弃努力，就始终在进步，目标终将会越来越近。<br> </p><h4>&nbsp;&nbsp;&nbsp;&nbsp;<em> The world is a fine place and worth fighting for !</em></h4><p></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML和css基础知识汇总（长期更新）]]></title>
      <url>http://detachment.club/2016/06/30/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)；</li>
<li>HTML 不是一种编程语言，而是一种标记语言 (markup language)；</li>
<li>标记语言是一套标记标签 (markup tag)；</li>
<li>HTML使用标记标签来描述网页；</li>
</ul>
<a id="more"></a>
<h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul>
<li>HTML：Hyper Text Markup Language；</li>
<li>标签：h1-h6; p; a; img; hr; strong; big; small; em; i; sub; sup; pre; code; kbd; tt; samp; var; address; abbr; acronym; bdo; blockquote; q; del; ins; map; area; table; tr; td; th; caption; thead; tbody; tfoot; dl; dt; dd; span; form; input; select ; option; textarea; fieldset; legend; optgroup; frameset(不与body同用); iframe; frameborder; object; embed; audio; video;</li>
<li>属性：align; bgcolor; dir；text-decoration; target; name; alt; background; align; rowspan; colspan; cellpadding; cellspacing; frame; raido; checkbox; action; method; selected; rows; cols; label; noresize;</li>
</ul>
<blockquote>
<p>HTML5部分网站上讲的太笼统了，之后在做项目的过程中再做具体的了解，其中canves这个属性被广泛应用；这两天把html和css复习一遍之后开始复习js，同时开始看书+做项目+写博客。按照这种速度的话,下个月底之前应该能够取得很大的进步。</p>
</blockquote>
<h2 id="CSS-部分"><a href="#CSS-部分" class="headerlink" title="CSS 部分"></a>CSS 部分</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets);</li>
<li>样式定义如何显示 HTML 元素;</li>
<li>样式通常存储在样式表中;</li>
<li>把样式添加到HTML4.0中，是为了解决内容与表现分离的问题;</li>
<li>外部样式表可以极大提高工作效率;</li>
<li>外部样式表通常存储在 CSS 文件中;</li>
<li>多个样式定义可层叠为一。</li>
</ul>
<h3 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h3><ul>
<li><strong>派生选择器</strong>：也被称为上下文选择器（contextual selector），根据元素在其位置的上下文关系来定义样式，是的标记更简洁；</li>
<li><strong>id选择器</strong>：用“#”来定义 （注意：id属性只能在每个HTML文档中出现一次）</li>
<li><strong>类选择器</strong>：以一个“.”显示；</li>
<li><strong>属性选择器</strong>：以“[属性]”的方式显示；（还有属性和值选择器）– 对于属性值有多重不同的选择方式，具体可参照w3school上的说明；</li>
<li><strong>背景</strong>：背景色；背景图像（不能继承）；背景重复（background-repeat）；背景定位（background-position–主要是针对当背景是图像的时候使用，如果只出现一个位置信息，则另一个默认为center）；背景关联（background-attachment，可将背景图像固定在可视区域）；</li>
<li><strong>文本</strong>：缩进文本（text-indent：一般来说，可以为所有块级元素应用text-indent，但无法将该属性应用于行内元素，图像之类的替换元素上也无法应用 text-indent 属性。不过，如果一个块级元素（比如段落）的首行中有一个图像，它会随该行的其余文本移动。如果想把一个行内元素的第一行“缩进”，可以用左内边距或外边距创造这种效果。它的值可为<strong>负数或者百分比</strong>。此属性可继承。）；水平对齐（text-align：justify可实现两端对齐——谨慎使用，因为各浏览器增加空间的方式不同造成效果各异；文字间隔（word-spacing）；字母间隔（letter-spacing）；字符转换（text-transform：uppercase、lowercase、capitalize）；文本装饰（text-decoration：underline、overline、line-through及blink；）；空白字符（white-space：pre、nowrap、pre-wrap及pre-line）；文本方向（direction：ltr、ltr；）</li>
<li><strong>字体</strong>：五种通用字体（font-family）——Serif、Sans-serif、Monospace、Cursive和Fantasy；字体风格（font-style：normal、italic和oblique）；字体变形（font-variant：小型大写字母）；字体加粗（font-weight：bold、bolder、lighter等）；字体大小（font-size：px、em和百分比，其中第一个是静态测量单位，后两者则是相对测量单位）；</li>
<li><strong>链接</strong>：链接的四种状态（link、visited、hover和active，设置时需要注意顺序问题。通过改变连接访问前后及鼠标是否悬停在链接上的属性设置的不同来达到改变样式的目的）；</li>
<li><strong>列表</strong>：列表类型（list-style-type）、列表项图像（list-style-image）、列表标志位置（list-style-position）（注意，这些属性一般都是作用在ul或者ol上的，但根据网站上的例子可以知道有时——比如list-style-image也可以施加到list上。）</li>
<li><strong>表格</strong>：表格边框（border），折叠边框（border-collapse：将表格边框折叠为单一边框），表格文本对齐（水平方向：text-align；垂直对齐方式：vertical-align），表格内边距（padding），表格颜色（background-color）；</li>
<li><strong>轮廓</strong>：（outline，区别于border，轮廓指的是边缘外框的外围，可以起到突出元素的作用。）</li>
<li><strong>框模型</strong>：<img src="http://www.w3school.com.cn/i/ct_boxmodel.gif" alt="image">元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。背景应用于由内容和内边距、边框组成的区域。内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表设置外边距和内边距。在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li>
<li><strong>内边距（padding）</strong>：属性定义元素边框与元素内容之间的空白区域。CSSpadding属性定义元素的内边距。padding属性接受长度值或百分比值，<strong>但不允许使用负值</strong>。单位可以有 <a href="https://www.w3.org/Style/Examples/007/units.en.html#units" target="_blank" rel="noopener">EM, PX, PT, CM</a>。如果使用百分比设置的内边距，那么这个百分比的基数是<strong>其父元素的width来计算的</strong>，这一点也同样适用在外边距（而且不管是左右边距还是上下边距）。</li>
<li><strong>边框（border）</strong>：围绕元素内容和内边距的一条或多条线，允许规定元素边框的样式、宽度和颜色；CSS 规范指出，边框绘制在“元素的背景之上”。这很重要，因为有些边框是“间断的”（例如，点线边框或虚线框），元素的背景应当出现在边框的可见部分之间。CSS2 指出背景只延伸到内边距，而不是边框。后来 CSS2.1 进行了更正：元素的背景是内容、内边距和边框区的背景。边框的样式（border-style：一共有十种，效果各不相同，而且可以分别为不同的边框设置不同的样式）；边框宽度（border-width：可以指定长度或者使用thin，medium或者thick中的任意一个，但是后面这三个关键词的具体宽度可能会根据不同的用户代理有不同的值）。因此，如果希望边框出现，就必须声明一个边框样式。然后设置边框的宽度才有意义。边框的颜色（border-color）：默认的边框颜色是元素本身的前景色。如果没有为边框声明颜色，它将与元素的文本颜色相同。另一方面，如果元素没有任何文本，假设它是一个表格，其中只包含图像，那么该表的边框颜色就是其父元素的文本颜色（因为 color 可以继承）。这个父元素很可能是body、div 或另一个 table。透明边框（transparent）：CSS2引入了边框颜色值transparent。这个值用于创建有宽度的不可见边框。</li>
<li><strong>外边距（margin）</strong>：围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。这个属性接受任何长度单位、百分数值甚至负值。margin的默认值是 0，所以如果没有为margin声明一个值，就不会出现外边距。但是，在实际中，浏览器对许多元素已经提供了预定的样式，外边距也不例外。块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。</li>
<li><strong>外边距合并</strong>：当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。除此之外，父元素与子元素之间，空块元素，也会发生合并，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener">具体可参考MDN上的内容</a>。<strong>（这个点可以写一篇博客了。）</strong></li>
<li><strong>定位和浮动</strong>：1. 一切都为框-块框、行内框或者无名块框；2. css中有三种基本的定位机制——普通流、浮动和绝对定位，默认都为普通流中定位；3. 位置属性（position）：包括static、relative、absolute和fixed。具体情况可以参考<a href="http://www.w3schools.com/css/css_positioning.asp" target="_blank" rel="noopener">w3school上面关于position的内容</a>。<strong>这个相关内容也可以写一篇剪短的博客了，:-D。</strong></li>
<li><strong>浮动（float）</strong>：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。<strong>浮动及浮动清除理解起来也有难度啊，搞清楚后也可以写博客了</strong>。<br>(关于浮动的博客已写，但是还是没有弄的太明白，之后再买书看吧）</li>
<li><strong>元素选择器</strong>：最常见的为元素选择器，在w3c中元素选择器也叫作类型选择器（type selector），类型选择器匹配文档语言元素类型的名称，可以匹配文档树中该元素类型的每一个实例。类型选择其也可适用在XML文档中。</li>
<li><strong>选择器分组</strong>：可以把具有同样样式的元素放在样式的左边，<strong>并且用逗号隔开</strong>，选择器的数量没有限制，可以有任意多组；如：h1，p，span { corlor：white；}；</li>
<li><strong>通配符选择器</strong>：css2中引入了一种新的简单选择器，叫做通配符选择器（universal selector），符号为*，可以与任何元素匹配；</li>
<li><strong>声明分组</strong>：对于同一个元素的不同样式，可以将样式声明在此元素后面，<strong>并用分号隔开</strong>，例如：h1 {corlor：black；background：yellow；font-size：strong；}；</li>
<li><strong>类选择器</strong>：要应用样式而不考虑具体设计的元素，最常用的方法就是使用类选择器，它允许以一种独立于文档元素的方式来指定样式；使用语法为：.className {porperty: value; };类选择器可结合元素选择器，选择出某一种元素中具有某个类名的个体，然后赋予其属性和值，例如：p.important {corlor：red；}；多类选择器指的是一个元素可以有多个类，类与类之间用空格分隔，例如：<p class="important warning">其中类名无顺序之分，通过把两个类选择器链接在一起，可以选择出同时包含这些类名的元素；</p></li>
<li><strong>ID选择器</strong>：ID选择器允许一种独立于文档元素的方式来指定样式，例如：#intro {font-size：14px；}指的是ID为intro的元素的字体大小为14px；与类选择器不同的是，ID选择器：1.只能在文档中出现一次；2. 不能结合使用；3. ID能包含更多含义；<strong>需要注意的是：选择器是区分大小写的，因此写的时候务必要注意！</strong></li>
<li><strong>属性选择器</strong>：属性选择器可以根据元素的属性及属性值来选择元素。属性选择器是在css2中引入的。如：[title] {color:red} （表示：把含有标题的所有元素变成红色）；再如：a[href] {color:red} (表示对有href属性的锚应用属性)；还可以结合起来使用，如：a[href][title] {color:red} (表示将同时具有href和title属性的锚的文本设置成红色）；除此之外，还可以规定具体的属性值，例如：<code>a[href=&quot;http://www.w3school.com.cn/about_us.asp&quot;] {color: red;}</code>（表示只有带有超链接且了解为上述的时候才会变红），而且每个属性选择器都可以对相应的属性赋值；而且需要注意，此时选择器中的属性值和必须完全匹配（注意：如果需要选择不完全匹配，则可以用约等号来选择，如：p[class~=”important”] {color: red;}）；字串匹配属性选择器，在css2完成之后发布，可以匹配属性值以某些字符串开头、结尾或者只是包含的情况，具体见<a href="http://www.w3school.com.cn/css/css_selector_attribute.asp" target="_blank" rel="noopener">字串属性选择器</a>; 特殊属性选择器，如<code>*[lang|=&quot;en&quot;] {color: red;}</code>，表示只选择lang属性等于en或者以en-开头的所有元素；（这种用法常见于匹配语言值）。</li>
<li><strong>后代选择器（descendant selector）</strong>，又称为包含选择器；比如<code>h1 em {color:red;}</code>，需要注意的是，后代选择器中两个元素之间的层级间隔可以是无限的（区别于后面要讲到的子元素选择器）；</li>
<li><strong>子元素选择器（Child selector）</strong>：只能选择作为某元素子元素的元素。比如下面的例子：<code>h1 &gt; strong {color:red;}</code>，子结合符为“&gt;”，结合符两边的空格是可选的；</li>
<li>相邻兄弟选择器（Adjacent sibling selector）：可选择紧接在一个元素后面的元素，且两者有相同的父元素；写法如下：<code>h1 + p {margin-top:50px;}</code>，表示的是“选择紧接在h1元素后面的段落增加边距，并且这两者有相同的父元素”；相邻兄弟选择器作用的对象是“+”号后面的元素，对前一个元素没有影响；</li>
<li><strong>伪类（Pseudo-classes）</strong>：用于向某些选择器添加特殊的效果；比如超链接中的a:link, a:visited, a:hover, a:active,(注意超链接使用伪类的时候有顺序问题）；:focus 伪类用于引起注意，一般用于<a href="http://www.w3school.com.cn/tiy/t.asp?f=csse_link_focus" target="_blank" rel="noopener">输入框</a>；除此之外，还有:first-child, :lang等伪类；其中:first-child伪类表示用来选择某元素的第一个子元素；</li>
<li><strong>伪元素（Pseudo-elements）</strong>：用于向某些选择器设置特殊效果；语法为：<code>selector:pseudo-element{property:value;}</code>，主要有<code>:first-line, :first-letter</code>, 在css2中引入了：<code>:before, :after</code>，表示的是在某元素前面（后面）插入新内容（这一点在清除浮动那一章节有重点应用）；</li>
<li><strong>css水平对齐</strong>：1. 使用margin属性（将左边距和右边距都设置为auto，则左右均等分配可用外边距，达到居中的效果。注意：如果宽度为100%，对齐则没有效果）；2. 利用Position属性（当使用绝对定位属性来定位时，元素将从正常流中删除，从而可能产生交叠元素）；3. 使用float属性进行左右对齐；<strong>注意：使用所有属性进行对齐时都应该声明<code>!DOCTYPE html</code>，否则在IE8及以下版本会在右侧增加17px的外边距（为滚动条预留空间）。</strong></li>
<li><strong>css尺寸（Dimension）</strong>：尺寸属性允许控制元素的高度和宽度。同样，也允许增加行间距。除了width，height之外，还有max-height，min-height，max-width，min-height，line-height等；且这些尺寸都可以用像素、百分比来设置；</li>
<li><strong>css分类（Classification）</strong>：css分类属性允许规定如何以及在何处显示元素；有inline，block等，其实就是display属性的值，然后这个值就和css的布局有很大的关联，同样影响布局的还有float以及position，它们之间的关系见我之前写的一篇博客<a href="http://detachment.club/2016/06/27/Float,%20position%20and%20display%20in%20CSS/">Float, Position and Display in CSS</a>;本节还讲到了一个很有意思的属性：cursor，用来实现不同 的光标，使用语法为<code>element {cursor:value; }</code>；</li>
<li><strong>导航栏</strong>：实现导航栏的关键在于对浮动的理解，其他属性都比较简单，实现过程可见：<a href="http://www.w3school.com.cn/css/css_navbar.asp" target="_blank" rel="noopener">导航条的实现</a>；</li>
<li><strong>图片库</strong>：其实也不是什么图片库，就是把相同的布局，运用在了几张尺寸一样的图片上罢了。在设定任何css属性之前，都需要认真弄清楚需求，一步一步的将布局分解到每一个<code>div</code>中，然后思考每个<code>div</code>中的布局，最终形成整体布局。</li>
<li><strong>图像透明</strong>：属性为<code>opacity; filter:alpha(opacity=value)</code>，如果需要用<code>:hover</code>属性来设置鼠标移入之后的效果，那么一定要声明<code>&lt;!DOCTYPE html&gt;</code>，否则不能应用在除了a以外的其他元素；</li>
<li><strong>css2媒介类型</strong>：媒介类型允许定义以何种媒介来提交文档，文档被显示在显示器、纸媒介或者听觉浏览器上等等；语法为<code>@media class</code>，类别中有screen、print、tv、handheld等等（然后就出现了Bootstrap的自适应？）</li>
</ul>
<blockquote>
<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><h4 id="本文内容主要来源为w3school，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。"><a href="#本文内容主要来源为w3school，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。" class="headerlink" title="本文内容主要来源为w3school，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。"></a>本文内容主要来源为<a href="http://www.w3school.com.cn/index.html" target="_blank" rel="noopener">w3school</a>，相关知识点都在在此网站找到更详细的说明，本博客仅供复习总结用。</h4></blockquote>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Float, Position and Display in CSS]]></title>
      <url>http://detachment.club/2016/06/27/Float,%20position%20and%20display%20in%20CSS/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;目前是第二遍学习CSS，第一遍学习的时候只是看了一遍教材，当时感觉还行，但是在之后学习JS的过程中就愈发感觉到没有学好这一章节的严重性，所有在第二遍学习的时候，一定要将这个知识点彻底的弄清楚才会进入到下一阶段，这也就是为什么我会花3天的时间来弄清楚这个知识点的原因了。<br>&nbsp;&nbsp;&nbsp;&nbsp;为了搞懂这个问题，首先能想到的当然是先多看几遍教材，然后直接Google，搜索到几篇中文博客，之后在StackOverFlow上搜索与Float相关的问题，这一遍下来，搜索的资料让我看了好久，而我所理解的都将在下面的文章中通过图文来表述。</p>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>normal flow:<blockquote>
<p>Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.<br>&nbsp;&nbsp;正常流：在正常流的盒子就属于格式化上下文，而这个格式化上下文可能是块级的也可能是行间的，但这两者不会同时存在。块级别的盒子参与到块级格式化上下文。行间级别的盒子参与到行间格式化上下文。</p>
</blockquote>
</li>
<li>relative positioning:<blockquote>
<p>Once a box has been laid out according to the normal flow or floated, it may shifted relative to this position. This is called relative positioning.<br>&nbsp;&nbsp;相对定位：如果一个盒子按照正常流或者浮动来进行布局，那么它可能会相对这个位置进行移动。这就是所谓的相对定位。</p>
</blockquote>
</li>
<li>floating:<blockquote>
<p>A float is a box that is shifted to the left or right on the current line. The most interesting characteristic of a float is that content may flow along its side(or be prohibited from doing so by the ‘clear’ property).<br>浮动：浮动就是一个被转移到所在行的左边或者右边的盒子。它最有意思的一个性质就是内容会沿着它的边缘流动（或者是因为有‘clear’属性而导致不能沿着它的边缘流动）</p>
</blockquote>
</li>
<li>clear:<blockquote>
<p>This property indicates which sides of an element’s box(es) may not be adjacent to an earlier floating box. The ‘clear’ property does not consider floats inside the element itself or in other block formatting context.<br>&nbsp;&nbsp;清除：这个属性是用来规定元素盒子的哪一边不能和浮动盒子相邻。‘清除’属性不会作用在浮动元素的本身也不会作用在其他块级层叠上下文中。</p>
</blockquote>
</li>
<li>absolute positioning:<blockquote>
<p>In the absolute positioning model, a box is explicitly offset with respect to its containing block. It is removed from the normal flow entirely (it has no impact on later siblings). An absolutely positioned box establishes a new containing block for normal flow children and absolutely (but not fixed) positioned descendants. The containing block for a positioned box is established by the nearest positioned ancestor.<br>&nbsp;&nbsp;绝对定位：在绝对定位模型中，盒子相对其被包含块的偏移量会被明确的设定。在正常流中它会被完全剔除（对之后的兄弟元素没有影响）。绝对定位的盒子会为其中的正常流子元素产生一个包含块以及绝对（不是固定）定位的后代元素。被定位元素盒子的包含块是由最近的被定为的祖先元素来产生。</p>
</blockquote>
</li>
<li>block formatting context:<blockquote>
<p>Floats, absolutely positioned elements, block containers (such as inline-block, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting context for their contents.<br>&nbsp;&nbsp;块级格式化上下文：浮动，绝对定位元素，非块级盒子以及块级盒子但拥有“overflow”属性不是“visible”（除了当那个值已经被传到视窗的时候）的块级包含者（例如行内块、表格单元以及表格头）会为它们的内容产生一个新的块级格式化上下文。</p>
</blockquote>
</li>
<li>Block-level elements and block boxes:<blockquote>
<p>Block-level elements are those elements of the source document that are formatting visually as blocks. The following values of the ‘display’ property make an element Block-level:’block’, ‘list-item’, and ‘table’.<br>Block-level boxes are boxes that participate in a block formatting context. Each Block-level element generates a principal block-level box that contains descendant boxes and generated content and is also the box involved in any positioning scheme.Except for table boxes, which are described in a later chapter, and replaced elements, a block-level box is also a block container box. A block container box either contains only block-level boxes or establishes an inline formatting context and thus contains only inline-level boxes. Not all block container boxes are block-level boxes: non-replaced inline blocks and non-replaced table cells are block containers but not block-level boxes. Block-level boxes that are also block containers are called block boxes.<br>&nbsp;&nbsp;块级元素以及块级盒子：块级元素指的是源文件中按照块级来进行可见的格式化的元素。下面关于“display”属性的值能够让一个元素变成块级元素：block，list-item 以及 table。<br>块级盒子指的是参与块级格式化上下文的盒子。每个块级元素会生成一个自己的块级盒子，这个块级盒子都包含后代盒子和内容，同时也是这个盒子参与到所有的定位中。除了将在下一节中将要讲到的表格盒子以及替代元素，块级盒子也是块包含盒子。块包含盒子中要么只包含块级盒子要么产生一个行内格式化上下文然后只包含行内盒子。并不是所有的块包含盒子都是块级盒子：不可替代的行内快以及不可替代的表格单元都是可以包含块，但并不是块级盒子。块级盒子，同时也是块包含者被称之为块盒子。</p>
</blockquote>
</li>
<li>Relationships between ‘display’, ‘position’, and ‘float’:<blockquote>
<p>The three properties that affect box generation and layout interact as follows:</p>
<ol>
<li>If ‘display’ has the value ‘none’, then ‘position’ and ‘float’ do not apply. In this case, the element generates no box.</li>
<li>Otherwise, if ‘position’ has the value ‘absolute’ or ‘fixed’, the box is absolutely positioned, the computed value of ‘float’ is ‘none’, and display is set according to the table below. The position of the box will be determined by the ‘top’, ‘right’, ‘bottom’ and ‘left’ properties and the box’s containing block.</li>
<li>Otherwise, if ‘float’ has a value other than ‘none’, the box is floated and ‘display’ is set according to the table below.</li>
<li>Otherwise, if the element is the root element, ‘display’ is set according to the table below, except that it is undefined in CSS 2.1 whether a specified value of ‘list-item’ becomes a computed value of ‘block’ or ‘list-item’.</li>
<li>Otherwise, the remaining ‘display’ property values apply as specified.</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="浮动（Float）"><a href="#浮动（Float）" class="headerlink" title="浮动（Float）"></a>浮动（Float）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;浮动属性可以施加给任何元素（只要此元素不是绝对定位），设定浮动属性的元素从普通流中脱离，形成块级格式化上下文（BFC），而普通流中的元素则表现的此浮动元素不存在一样（除了会使行框变短，从而形成文本绕浮动元素的现象）。浮动属性具有以下几个特点：</p>
<ol>
<li>只有横向浮动，没有纵向浮动；（属性值只有none、left及right）</li>
<li>浮动元素的上外边框不能超过其包含块的上边框；</li>
<li>浮动元素脱离普通流后其包含容器将得不到此元素的高度属性（然后就有了关于clearfix方法的讨论）；</li>
<li>更多特点见<a href="https://www.w3.org/TR/CSS21/visuren.html#propdef-float" target="_blank" rel="noopener">Float说明。</a></li>
</ol>
<h2 id="定位（Position）"><a href="#定位（Position）" class="headerlink" title="定位（Position）"></a>定位（Position）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;定位属性比较好理解，其值有 inhert, static, relative, absolute, fixed 这五种。其中static为默认值，表示没有定位，根据位置出现在文档的普通流中；inhert 为继承父元素的position属性；relative 为相对定位，相对的是其本身在普通流中的位置，而且设定为相对浮动后，元素仍然占据原来普通流中的位置；absolute 为绝对定位，定位基准是最靠近的定位属性不为static的祖先元素，当设置为未绝对定位后，元素的位置就与普通流无关了，同时也不占据文档流空间，而且在设置为绝对定位后，元素会形成一个新的块级格式化上下文（BFC），原来是行内元素的会变成块级元素，而块级元素的宽度则由其本身的内容决定，而不再是默认的100%了；fixed可以说是absolute的特殊类，它也是固定定位，但是它的定位基准为视窗（viewport），除此之外，与决定定位没有区别。</p>
<h2 id="显示类（Display）"><a href="#显示类（Display）" class="headerlink" title="显示类（Display）"></a>显示类（Display）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Display属性主要决定元素是块级元素还是行间元素。属性值主要有block、inline-block、inline、list-item和none。块级元素为垂直排列，块级元素会自动换行，可设置块的宽高信息；行间元素为水平排列，宽高由内容决定，外部设置对其无效。</p>
<h2 id="Float、Position-和-Display-之间的关系："><a href="#Float、Position-和-Display-之间的关系：" class="headerlink" title="Float、Position 和 Display 之间的关系："></a>Float、Position 和 Display 之间的关系：</h2><ol>
<li>如果display的值为none，那么后两者就不会产生作用，也不会有任何的盒子产生；</li>
<li>除此之外，如果元素为absolute或者fixed定位，那么浮动的属性值相当于‘none’，display的属性如下面的表格所示。元素的位置就由设定决定定位时的值以及所包含容器来决定；</li>
<li>除此之外，如果float属性的值为不是none，那么元素将会浮动，元素的display属性将如下表所示；</li>
<li>除此之外，如果元素是根元素，那么元素的属性如下表所示；</li>
<li>除此之外，元素的display属性则根据设定来取值。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">specified value</th>
<th style="text-align:left">computed value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">inline-table</td>
<td style="text-align:left">table</td>
</tr>
<tr>
<td style="text-align:left">inline, table-x, inline-block</td>
<td style="text-align:left">block</td>
</tr>
<tr>
<td style="text-align:left">others</td>
<td style="text-align:left">same as specified</td>
</tr>
</tbody>
</table>
<h2 id="清除浮动（Clearfix）"><a href="#清除浮动（Clearfix）" class="headerlink" title="清除浮动（Clearfix）"></a>清除浮动（Clearfix）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;容器内如果只存在浮动元素，那么则会因为浮动元素不在普通流中而造成父级容器高度塌陷且无法获取浮动元素高度的情况，为了解决这个问题，除了了各种各样的清除浮动的方法，下面简单介绍几种：</p>
<ol>
<li><p>利用伪类及伪元素来清除，代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用overflow属性，代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 或者是auto */</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block; <span class="comment">/* Necessary to trigger "hasLayout" in IE */</span></span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* Sets element back to block */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* Clearfix! */</span></span><br><span class="line">    <span class="attribute">zoom</span>: <span class="number">1</span>;  <span class="comment">/* Triggering "hasLayout" in IE */</span></span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* Element must be a block to wrap around contents. Unnecessary if only using block-level elements. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用clear属性，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> <span class="attr">style</span>=<span class="string">"clear:both"</span> /&gt;</span> <span class="comment">&lt;!-- So dirty! --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种增加<code>&lt;br&gt;</code>同时结合clear属性的方法虽然看起来非常简单，但非常不推荐使用。主要原因有：如果后期有更好的清除方式，你不想有<code>&lt;br&gt;</code>元素存在那么将存在很大的问题；而且这种增加也不是语义上的增加。</p>
<blockquote>
<h4 id="由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！"><a href="#由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！" class="headerlink" title="由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！"></a><strong>由于笔者水平有限，本文有很多需要完善的地方，将长期保持更新；如阅读发现任何问题，欢迎批评指正！</strong></h4></blockquote>
<h4 id="参考文章-Reference-："><a href="#参考文章-Reference-：" class="headerlink" title="参考文章(Reference)："></a>参考文章(Reference)：</h4><ul>
<li><a href="http://stackoverflow.com/questions/211383/what-methods-of-clearfix-can-i-use/1633170#1633170" target="_blank" rel="noopener">Stackoverflow–What methods of ‘clearfix’ can I use?</a></li>
<li><a href="http://www.quirksmode.org/css/clearing.html#top" target="_blank" rel="noopener">Blog–Clearing floats</a></li>
<li><a href="http://yuiblog.com/blog/2010/05/19/css-101-block-formatting-contexts/" target="_blank" rel="noopener">Blog–CSS 101: Block Formatting Contexts</a></li>
<li><a href="https://www.w3.org/TR/CSS21/visuren.html#dis-pos-flo" target="_blank" rel="noopener">W3C–Relationships between ‘display’, ‘position’, and ‘float’</a></li>
<li><a href="http://www.jianshu.com/p/07eb19957991#" target="_blank" rel="noopener">Blog–CSS浮动float详解</a></li>
<li><a href="http://www.cnblogs.com/dolphinX/archive/2012/10/13/2722501.html" target="_blank" rel="noopener">Blog–CSS布局 ——从display，position， float属性谈起</a></li>
<li><a href="http://www.cnblogs.com/coffeedeveloper/p/3145790.html" target="_blank" rel="noopener">Blog–对CSS中的Position、Float属性的一些深入探讨</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 基础 </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
